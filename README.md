<div align="center">

[![contributions welcome](https://img.shields.io/badge/contributions-welcome-brightgreen.svg?style=flat)](https://github.com/Nomadiix/ISO)
[![GitHub stars](https://img.shields.io/github/stars/Nomadiix/ISO)](https://github.com/FabianMartinez1234567/ISO/stargazers/)
[![GitHub repo size in bytes](https://img.shields.io/github/repo-size/Nomadiix/ISO)](https://github.com/Nomadiix/ISO)
 </div>

<h1 align="center"> üêß Introducci√≥n a Sistemas Operativos</h1>
<div align="center">
<img src="https://media.giphy.com/media/3oz8xNkfjM07d7dK0w/giphy.gif"/>
</div>

---
Antes de empezar la materia te recomiendo que mires mi blog sobre vim para que puedas instalar y configurar a tu gusto el editor para hacer las practicas. Tambien dejo links de los teoricos

- [Blog de Vim](https://mith-arg.github.io/EI-Materias/2022-10-04-vim/)
- [Teoria](/Documentos/Teoria.md)
- [Repaso Primer Parcial de Promoci√≥n](/Documentos/RepasoPrimerParcialPromocion.md)
- [Primer Parcial de Promoci√≥n](/Documentos/PrimerParcialPromocion.md)

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

# ü™ì Practicas

- ### [1Ô∏è‚É£ Practica 1 Conceptos b√°sicos del sistema operativo](#-practica-1)
  - [1) Caracter√≠sticas de GNU/Linux](#1-caracter√≠sticas-de-gnulinux)
  - [2) Distribuciones de GNU/Linux](#2-distribuciones-de-gnulinux)
  - [3) Estructura de GNU/Linux](#3-estructura-de-gnulinux)
  - [4) Kernel](#4-kernel)
  - [5) Int√©rprete de comandos (Shell)](#5-int√©rprete-de-comandos-shell)
  - [6) Sistema de Archivos (File System)](#6-sistema-de-archivos-file-system)
  - [7) Particiones](#7-particiones)
  - [8) Arranque (bootstrap) de un Sistema Operativo](#8-arranque-bootstrap-de-un-sistema-operativo)
  - [9) Archivos](#9-archivos)
  - [10) Indique qu√© comando es necesario utilizar para realizar cada una de las siguientes acciones.](#10-indique-qu√©-comando-es-necesario-utilizar-para-realizar-cada-una-de-las-siguientes-acciones-investigue-su-funcionamiento-y-par√°metros-m√°s-importantes)
  - [11) Investigue su funcionamiento y par√°metros m√°s importantes](#11-nvestigue-su-funcionamiento-y-par√°metros-m√°s-importantes)
  - [12) Investigue su funcionamiento y par√°metros m√°s importantes](#12-nvestigue-su-funcionamiento-y-par√°metros-m√°s-importantes)
- ### [2Ô∏è‚É£ Practica 2 Pocesos, usuarios, filesystems, permisos](/Documentos/Practica2.md)
  - [1) Editor de textos](#1-editor-de-textos)
  - [2) Proceso de Arranque SystemV](#2-proceso-de-arranque-systemv)
  - [3) Usuarios](#3-usuarios)
  - [4) FileSystem](#4-filesystem)
  - [5) Procesos](#5-procesos)
  - [6) Otros comandos de Linux](#6-otros-comandos-de-linux-indique-funcionalidad-y-par√°metros)
  - [7) Indique qu√© acci√≥n realiza cada uno de los comandos...](#7-ejercicio)
  - [8) Indique qu√© comando ser√≠a necesario ejecutar para realizar cada una de las siguientes acciones](#8-indique-qu√©-comando-ser√≠a-necesario-ejecutar-para-realizar-cada-una-de-las-siguientes-acciones)
  - [9) Indique qu√© comando ser√≠a necesario ejecutar para realizar cada una de las siguientes acciones](#9-indique-qu√©-comando-ser√≠a-necesario-ejecutar-para-realizar-cada-una-de-las-siguientes-acciones)
  - [10) Indique qu√© comando ser√≠a necesario ejecutar para realizar cada una de las siguientes acciones](#10-indique-qu√©-comando-ser√≠a-necesario-ejecutar-para-realizar-cada-una-de-las-siguientes-acciones)
  - [11) Indique qu√© acci√≥n realiza cada uno de los comandos indicados a continuaci√≥n....](#11-ejercicio)
  - [12) Cree una estructura desde el directorio /home que incluya varios directorios....](#12-ejercicio)
  - [13) Indique qu√© comando/s es necesario para realizar cada una de las acciones de la siguiente secuencia de paso](#13-indique-qu√©-comandos-es-necesario-para-realizar-cada-una-de-las-acciones-de-la-siguiente-secuencia-de-pasos-considerando-su-orden-de-aparici√≥n)
- ### [3Ô∏è‚É£ Practica 3 Shell Scripting](/Documentos/Practica3.md)
  - [1) ¬øQu√© es el Shell Scripting? ¬øA qu√© tipos de tareas est√°n orientados los script?](#1-ejercicio)
  - [2) Investigar la funcionalidad de los comandos echo y read](#2-ejercicio)
  - [3) Crear dentro del directorio personal del usuario logueado un directorio](#3-ejercicio)
  - [4) Parametrizaci√≥n](#4-ejercicio)
  - [5) ¬øCual es la funcionalidad de comando exit?](#5-ejercicio)
  - [6) El comando expr permite la evaluaci√≥n de expresiones](#6-ejercicio)
  - [7) El comando ‚Äútest expresi√≥n‚Äù permite evaluar expresiones](#7-ejercicio)
  - [8) Estructuras de control](#8-ejercicio)
  - [9) ¬øQu√© acciones realizan las sentencias break y continue dentro de un bucle?](#9-ejercicio)
  - [10) ¬øQu√© tipo de variables existen? ¬øEs shell script fuertemente tipado?](#10-ejercicio)
  - [11) ¬øPueden definirse funciones dentro de un script? ¬øC√≥mo?](#11-ejercicio)
  - [12) Evaluaci√≥n de expresiones](#12-ejercicio)
  - [13) Uso de las estructuras de control](#13-ejercicio)
  - [14) Renombrando Archivos: haga un script que renombre solo archivos](#14-ejercicio)
  - [15) Comando cut](#15-ejercicio)
  - [16) Realizar un script que reciba como par√°metro una extensi√≥n](#16-ejercicio)
  - [17) Escribir un script que al ejecutarse imprima en pantalla los nombre](#17-ejercicio)
  - [18) Crear un script que verifique cada 10 segundos si un usuario se ha](#18-ejercicio)
  - [19) Escribir un Programa de ‚ÄúMenu de Comandos Amigable con el Usuario‚Äù](#19-ejercicio)
  - [20) Realice un script que simule el comportamiento de una estructura de PILA](#20-ejercicio)
  - [21) Dentro del mismo script y utilizando las funciones implementadas](#21-ejercicio)
  - [22) Dada la siguiente declaraci√≥n al comienzo de un script](#23-ejercicio)
  - [23) Implemente un script que recorra un arreglo compuesto por n√∫meros](#23-ejercicio)
  - [24) Dada la definici√≥n de 2 vectores del mismo tama√±o y cuyas](#24-ejercicio)
  - [25) Realice un script que agregue en un arreglo todos los nombres](#25-ejercicio)
  - [26) Escriba un script que reciba una cantidad desconocida de par√°metros](#26-ejercicio)
  - [27) Realice un script que implemente a trav√©s de la utilizaci√≥n](#27-ejercicio)
  - [28) Realice un script que reciba como par√°metro el nombre de un directorio](#28-ejercicio)
  - [29) Implemente un script que agregue a un arreglo todos los archivos](#29-ejercicio)
  - [30) Realice un script que mueva todos los programas del directorio actual](#30-ejercicio)
- ### [4Ô∏è‚É£ Practica 4 Planificaci√≥n de proceso](/Documentos/Practica4.md)
  - [Ejercicio 1 Responda en forma sint√©tica sobre los siguientes conceptos](#1-responda-en-forma-sint√©tica-sobre-los-siguientes-conceptos)
  - [Ejercicio 2 Procesos](#2procesos)
  - [Ejercicio 3 Para los siguientes algoritmos de scheduling](#3-para-los-siguientes-algoritmos-de-scheduling)
  - [Ejercicio 4 Para el algoritmo Round Robin, existen 2 variantes](#4-para-el-algoritmo-round-robin-existen-2-variantes)
  - [Ejercicio 5 Se tiene el siguiente lote de procesos que arriban al sistema en el instante 0 (cero)](#5-se-tiene-el-siguiente-lote-de-procesos-que-arriban-al-sistema-en-el-instante-0-cero)
  - [Ejercicio 6 Se tiene el siguiente lote de procesos](#6-se-tiene-el-siguiente-lote-de-procesos)
  - [Ejercicio 7 Una variante al algoritmo SJF es el algoritmo SJF apropiativo o SRTF](#7-una-variante-al-algoritmo-sjf-es-el-algoritmo-sjf-apropiativo-o-srtf-shortest-remaining-time-first)
  - [Ejercicio 8 Suponga que se agregan las siguientes prioridades al lote de procesos](#8-suponga-que-se-agregan-las-siguientes-prioridades-al-lote-de-procesos-del-ejercicio-6-donde-un-menor-n√∫mero-indica-mayor-prioridad)
  - [Ejercicio 9 Inanici√≥n (Starvation)](#9-inanici√≥n-starvation)
  - [Ejercicio 10 Los procesos, durante su ciclo de vida, pueden realizar operaciones de I/O ](#10-los-procesos-durante-su-ciclo-de-vida-pueden-realizar-operaciones-de-io-como-lecturas-o-escrituras-a-disco-cintas-uso-de-impresoras-etc)
  - [Ejercicio 11 Algunos algoritmos pueden presentar ciertas desventajas cuando en el sistema](#11-algunos-algoritmos-pueden-presentar-ciertas-desventajas-cuando-en-el-sistema-se-cuenta-con-procesos-ligados-a-cpu-y-procesos-ligados-a-entrada-salida-analice-las-mismas-para-los-siguientes-algoritmos)
  - [Ejercicio 12 Para equiparar la desventaja planteada en el ejercicio 11)](#12-para-equiparar-la-desventaja-planteada-en-el-ejercicio-11-se-plantea-la-siguiente-modificaci√≥n-al-algoritmo)
  - [Ejercicio 13 ](#ejercicio-13)
  - [Ejercicio 14 ](#ejercicio-14)
  - [Ejercicio 15 Colas Multinivel](#15-colas-multinivel)
  - [Ejercicio 16 ](#ejercicio-16)
  - [Ejercicio 17 ](#ejercicio-17)
  - [Ejercicio 18 La situaci√≥n planteada en el ejercicio 17, donde un proceso puede cambiar](#18-la-situaci√≥n-planteada-en-el-ejercicio-17-donde-un-proceso-puede-cambiar-de-una-cola-a-otra-se-la-conoce-como-colas-multinivel-con-realimentaci√≥n)
  - [Ejercicio 19 Un caso real: ‚ÄúUnix Clasico ‚Äú (SVR3 y BSD 4.3)](#19-un-caso-real-unix-clasico--svr3-y-bsd-43)
  - [Ejercicio 20 A cu√°les de los siguientes tipos de trabajos:](#20-a-cu√°les-de-los-siguientes-tipos-de-trabajos)
  - [Ejercicio 21 Explicar porqu√© si el quantum "q.en Round-Robin se incrementa sin l√≠mite](#21-explicar-porqu√©-si-el-quantum-qen-round-robin-se-incrementa-sin-l√≠mite-el-m√©todo-se-aproxima-a-fifo)
  - [Ejercicio 22 Los sistemas multiprocesador pueden clasificarse en](#22-los-sistemas-multiprocesador-pueden-clasificarse-en)
  - [Ejercicio 23 Asumiendo el caso de procesadores homog√©neos](#23-asumiendo-el-caso-de-procesadores-homog√©neos)
  - [Ejercicio 24 Indique brevemente a que hacen referencia los siguientes conceptos](#24-indique-brevemente-a-que-hacen-referencia-los-siguientes-conceptos)
  - [Ejercicio 25 Si a la tabla del ejercicio 6 la modificamos de la siguiente manera](#25-si-a-la-tabla-del-ejercicio-6-la-modificamos-de-la-siguiente-manera-y-considerando-que-el)
- ### [5Ô∏è‚É£ Practica 5 Administraci√≥n de la Memoria Principal ](/Documentos/Practica5.md)
- ### [6Ô∏è‚É£ Practica 6 Planificaci√≥n de E/S y de discos](/Documentos/Practica6.md)
- [Comandos Importantes](/Documentos/Comandos.md)

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

<div align="center"> 

# üìí Practica 1

</div>

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">


El objetivo de esta pr√°ctica es que el alumno se familiarice con los conceptos b√°sicos del sistema
operativo GNU/Linux, as√≠ como con su entorno y comandos principales.


<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## `1)` Caracter√≠sticas de **GNU/Linux**:

#### `a)` Mencione y explique las caracter√≠sticas m√°s relevantes de **GNU/Linux**.

#### **`Es multiusuario`**

Cumple simult√°neamente las necesidades de dos o m√°s usuarios que comparten los mismos recursos, un sistema multiusuario permite que los usuarios accedan a los datos o procesos de una √∫nica maquina, desde diferentes computadoras o term√≠nales


#### **`Es multitarea y multiprocesador`**

Puede realizar varias operaciones, funciones o ejecuciones al mismo tiempo

Los SO multitarea permiten realizar varias operaciones gracias a una operaci√≥n denominada cambio de contexto que act√∫a de la siguiente manera, quita un proceso del CPU, ingresa uno nuevo, y luego vuelve a ingresar el proceso que quit√≥ del CPU en una especie de cola de ejecuci√≥n, sin que el procesador se entere de todo lo que est√° pasando, de modo, que pueda realizar varias tareas simult√°neas. Es como una especie de enga√±o, que permite mejorar el rendimiento de los ordenadores y facilitar el trabajo a los usuarios.

Multiprocesador se refiere al n√∫mero de procesadores del sistema, que es m√°s de uno y √©ste es capaz de usarlos todos para distribuir su carga de trabajo. 

#### **`Es altamente portable`**

Se puede usar en cualquier ordenador que tenga el SO para el que fue programado sin la
necesidad de una instalaci√≥n previa; significa que no hace falta la instalaci√≥n de bibliotecas adicionales en el sistema para que pueda funcionar. 

#### **`Posee diversos int√©rpretes de comandos, de los cuales algunos son programables`**

- Es el m√©todo de interacci√≥n entre el usuario y la m√°quina (shell)
- CLI (interfaz de l√≠nea de comando) un ejemplo seria la terminal bash. 

#### **`Permite el manejo de usuarios y permisos`**

Nos permite darle permisos particulares a usuarios y archivos del file system.

#### **`Todo es un archivo (hasta los dispositivos y directorios):`**

Todo es un fichero. Los directorios son ficheros, los ficheros son ficheros, y los dispositivos son ficheros. A veces a los dispositivos se les llama nodos, pero siguen siendo ficheros.

Los sistemas de ficheros de GNU/Linux se organizan en una estructura jer√°rquica, de tipo √°rbol.

El nivel m√°s alto del sistema de ficheros es / o directorio ra√≠z. Todos los dem√°s ficheros y directorios est√°n bajo el directorio ra√≠z. Por ejemplo, `/home/jebediah/cheeses.odt` muestra la ruta completa al fichero cheeses.odt que est√° en el directorio jebediah, que a su vez est√° bajo el directorio home, que por su parte est√° bajo el directorio ra√≠z (/).

#### **`Cada directorio puede estar en una partici√≥n diferente (/temp, /home, etc.)`**

En Linux, el sistema de archivos se organiza en una estructura de √°rbol con una ra√≠z denominada "/" (barra). Dentro de esta estructura de √°rbol, cada partici√≥n puede montarse en un directorio diferente, lo que significa que los archivos y directorios que se encuentran dentro de esa partici√≥n se har√°n accesibles a trav√©s del directorio montado.

Por ejemplo, si tienes una partici√≥n llamada /dev/sda1 y quieres montarla en el directorio /home, los archivos y directorios en esa partici√≥n estar√°n disponibles en el directorio /home. Si tienes otra partici√≥n llamada /dev/sda2 y quieres montarla en /temp, los archivos y directorios en esa partici√≥n estar√°n disponibles en el directorio /temp.

En resumen, en Linux, cada partici√≥n puede montarse en un directorio diferente en la estructura de √°rbol de archivos del sistema, lo que permite una mejor organizaci√≥n y gesti√≥n de los datos.

####  **`Es case sensitive`**

Sensible a las may√∫sculas y min√∫sculas

#### **`Es c√≥digo abierto`**

Software cuyo c√≥digo fuente y otros derechos que normalmente son exclusivos para quienes poseen los derechos de autor, son publicados bajo una licencia de c√≥digo abierto o forman parte del dominio p√∫blico. En las licencias compatibles con la Open Source Definition el propietario de los derechos de autor permite a los usuarios utilizarlo, modificarlo, estudiarlo, aprovechar su documentaci√≥n, redistribuir el software, a cualquiera, para cualquier prop√≥sito, ya sea en su forma modificada o en su forma original etc. 

---

#### `b)` Mencione otros sistemas operativos y comp√°relos con GNU/Linux en cuanto a los puntos mencionados en el inciso a.

- A diferencia de Windows y Mac, Linux no pertenece a ninguna compa√±√≠a, sino que su desarrollo depende de la colaboraci√≥n de un gran n√∫mero de empresas y profesionales.
- Su uso esta mas enfocado a programadores dado que sus interfaces son menos amigables.
- Los dem√°s sistemas suelen ser en su mayor√≠a pagos y enfocados mas a lo comercial
- El manejo de permisos de Linux vuelve mas dif√≠cil la creaci√≥n de un virus para dicho sistema mientras que en Windows es mas com√∫n.

---

#### `c)` ¬øQu√© es **GNU**?

GNU es un SO de tipo Unix pero libre, dise√±ado por miles de programadores, as√≠ como una gran colecci√≥n de programas inform√°ticos que componen al sistema, desarrollado por y para el GNU.

Est√° formado en su totalidad por software libre, mayoritariamente bajo t√©rminos
de copyleft. GNU es el acr√≥nimo recursivo de "GNU's Not Unix" **(GNU no es Unix)**, nombre elegido debido a que GNU sigue un dise√±o tipo Unix y se mantiene compatible con este, pero se distingue de Unix por ser software libre y por no contener c√≥digo de Unix.

---

#### `d)` Indique una breve historia sobre la evoluci√≥n del proyecto *GNU*

- El proyecto GNU fue iniciado por Richard M. Stallman con el prop√≥sito de crear un sistema operativo completo y libre: el sistema GNU.
- Se baso principalmente en 4 libertades
    - **Libertad 1:** la libertad para ejecutar el programa con cualquier fin.
    - **Libertad 2:** La libertad de estudiar c√≥mo trabaja el programa y de adecuarlo para que haga lo que usuario desee
    - **Libertad 3:** la libertad de redistribuir el programa de manera de colaborar con el resto de la sociedad.
    - **Libertad 4:** la libertad de hacer p√∫blica y distribuir a terceros la versi√≥n mejorada.

Pondria m√°s pero a nadie le importa la historia de linux salu2.

---

#### `e)` Explique qu√© es la multitarea, e indique si *GNU/Linux* hace uso de ella.

Puede realizar varias operaciones, funciones o ejecuciones al mismo tiempo

Los SO multitarea permiten realizar varias operaciones gracias a una operaci√≥n denominada cambio de contexto que act√∫a de la siguiente manera, quita un proceso del CPU, ingresa uno nuevo, y luego vuelve a ingresar el proceso que quit√≥ del CPU en una especie de cola de ejecuci√≥n, sin que el procesador se entere de todo lo que est√° pasando, de modo, que pueda realizar varias tareas simult√°neas. Es como una especie de enga√±o, que permite mejorar el rendimiento de los ordenadores y facilitar el trabajo a los usuarios. 

`Linux es Multitarea:` La multitarea no consiste en hacer que el procesador realice m√°s de un trabajo al mismo tiempo (un solo procesador no tiene esa capacidad), lo √∫nico que realiza es presentar las tareas de forma intercalada para que se ejecuten varias simult√°neamente. Por lo tanto en Linux es posible ejecutar varios programas a la vez sin necesidad de tener que parar la ejecuci√≥n de cada aplicaci√≥n. 

**GNU/Linux si es multitarea.**

---

#### `f)` ¬øQu√© es **POSIX**?

POSIX (Interfaz de sistema operativo port√°til) es un conjunto de interfaces de sistema
operativo est√°ndar basadas en el sistema operativo Unix .

Definen una interfaz y un entorno est√°ndar que puede utilizar un sistema operativo para proporcionar acceso a aplicaciones compatibles con POSIX.

El est√°ndar tambi√©n define un int√©rprete de comandos ( shell ) y programas de utilidad comunes . POSIX admite la portabilidad de aplicaciones en el nivel del c√≥digo fuente , por lo que las aplicaciones se pueden crear para ejecutarse en cualquier sistema operativo compatible con POSIX.

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## `2)` Distribuciones de **GNU/Linux**:

#### `a)` ¬øQu√© es una distribuci√≥n de GNU/Linux? Nombre al menos 4 distribuciones de GNU/- Linux y cite diferencias b√°sicas entre ellas.

Una distribuci√≥n es un conjunto de software de GNU, as√≠ como programas de sistema, librer√≠as y aplicaciones de usuario, con tambi√©n software de terceros (a veces), con una versi√≥n de un kernel de Linux, todo compilado, empaquetado, configurado y preparado para su instalaci√≥n en una computadora.

En resumen una distribuci√≥n de GNU/Linux es el sistema operativo preparado para ser instalado y usado en una computadora.

Desarrollar una distribuci√≥n es elegir de entre todos los programas de sistema (compiladores, int√©rpretes, etc.) y aplicaciones de usuario (entornos gr√°ficos de escritorio, editores de texto, paquetes de ofim√°tica, etc.) de GNU y de software de terceros (a veces, no siempre), los que se crean convenientes seg√∫n la distribuci√≥n que se quiera crear, m√°s pesada, m√°s ligera, etc., sumado a una versi√≥n de un kernel de Linux.

**Distribuci√≥n GNU/Linux = Software GNU + Software de terceros (no siempre) + Kernel de Linux.**

Cualquier persona con conocimientos de programaci√≥n puede crear una distribuci√≥n
GNU/Linux, por eso hay cientos de ellas.

Es tan indispensable el kernel de Linux como el conjunto de programas y librer√≠as de GNU. Por ello cuando a una distribuci√≥n GNU/Linux se le llama Linux a secas, es una falta de respeto hacia todo el software que GNU ha desarrollado y continua desarrollando como software libre y gratuito.

Debian, Opensuse, Fedora, Ubuntu.

- **`Debian:`** Se orienta a la estabilidad, en t√©rminos de ciclo de desarrollo. Sus actualizaciones y versiones se liberan cuando est√°n listas y bien probadas. Lo cual es bueno para servidores, pero por otra parte nos limita compatibilidad con dispositivos de hardware m√°s novedosos. Son muy exigentes en lo que respecta a Software Libre.
- **`Fedora:`** Se orienta a innovaci√≥n con un ciclo de desarrollo corto de seis meses, y un tiempo de soporte de un a√±o sobre sus paquetes. Lo m√°s nuevo se encuentra en Fedora, a veces la gente desconf√≠a de la solidez de sus paquetes sin embargo lo que sucede es que est√°n en fase de maduraci√≥n y se le integran mejores funcionalidades. Por ah√≠ le√≠ que Fedora es como probar lo que Linux ofrecer√° dentro de seis meses.
- **`Opensuse:`** Novel se qued√≥ sin sistema operativo para su plataforma de servidores y redes, as√≠ que compro Suse. Su panel de control para configuraci√≥n lo hace f√°cil de configurar. Es un buena elecci√≥n para aprender de servidores, pero posiblemente para cosas m√°s sofisticadas dejar√°n las herramientas de configuraci√≥n y har√°n ajustes personalizados. El mundo de Software Libre les critica fuertemente sus acuerdos de interoperabilidad con Microsoft.
- **`Ubuntu:`** Se propuso cambiarle la cara al mundo Linux y ciertamente lo ha logrado. Apuntando a ser f√°cil de usar hace bien simple la instalaci√≥n de drivers y decodificadores privativos, cosa que se le critican los fundamentalistas del software libre. Su programa de enviar discos gratis hasta la puerta de tu casa ha significado su creciente popularidad. Tiene ciclo de desarrollo r√°pido, pero sus versiones tienen ciclos de soporte alternado, entre periodos largos y cortos, tratando de tener estabilidad de soporte y flexibilidad de desarrollo.

---

#### `b)` ¬øEn qu√© se diferencia una distribuci√≥n de otra?

Las mayores diferencias se encuentran sobre todo en distribuciones comerciales, donde se han introducido herramientas para una f√°cil instalaci√≥n, detecci√≥n de software etc... 

**Diferencias:**

- Proceso de instalaci√≥n.
- Ayudantes o wizard que te ayuden en la configuraci√≥n de tu m√°quina.
- Gestores de paquetes.
- Secuencia en el proceso de arranque.

---

#### `c)` ¬øQu√© es Debian? Acceda al sitio 1 e indique cu√°les son los objetivos del proyecto y una breve cronolog√≠a del mismo.

Debian es una comunidad de desarrolladores , que mantiene un sistema operativo GNU basado en software libre. El sistema se encuentra precompilado, empaquetado y en formato deb para m√∫ltiples arquitecturas de computador y para varios n√∫cleos.

El proyecto Debian fue anunciado inicialmente 1993 por Ian Murdock. Debian 0.01 fue lanzado el 16 de agosto de 1993 y la primera versi√≥n estable fue hecha en 1996.

Naci√≥ como una apuesta por separar en sus versiones el software libre del software no libre. El modelo de desarrollo del proyecto es ajeno a motivos empresariales o comerciales, siendo llevado adelante por los propios usuarios, aunque cuenta con el apoyo de varias empresas en forma de infraestructuras.

Debian no vende directamente su software, lo pone a disposici√≥n de cualquiera en Internet, aunque s√≠ permite a personas o empresas distribuirlo comercialmente mientras se respete su licencia.

La primera adaptaci√≥n del sistema Debian, siendo tambi√©n la m√°s desarrollada, es Debian GNU/Linux, basada en el n√∫cleo Linux, y como siempre utilizando herramientas de GNU

Los nombres de las versiones de Debian son tomados de la pel√≠cula Toy Story. Hasta la fecha,
hay quince versiones estables (con sus respectivas revisiones) enumeradas en la tabla adjunta:

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## `3)` Estructura de GNU/Linux:

#### `a)` Nombre cuales son los 3 componentes fundamentales de GNU/Linux.

Kernel, shell y Filesystem.

---

#### `b)` Mencione y explique la estructura b√°sica del Sistema Operativo GNU/Linux.

Estructura. Nos ocuparemos de tres componentes principales:

- **`Kernel:`** El n√∫cleo se podr√≠a definir como el coraz√≥n de este sistema operativo. Es a grandes rasgos, el encargado de que el software y el hardware de una computadora puedan trabajar juntos.
- **`Shell:`** Es un programa que recibe lo que se escribe en una terminal de texto y lo convierte en instrucciones para el sistema operativo.
- **`Filesystem:`** Es la forma l√≥gica en que dentro de un SO se organizan y se administran los archivos. 

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## `4)` Kernel: 

#### `a)` ¬øQu√© es? Indique una breve rese√±a hist√≥rica acerca de la evoluci√≥n del Kernel de GNU/Linux.

El kernel es la estructura principal del SO, es el que se encarga de que el software y el hardware puedan trabajar juntos.

Es un n√∫cleo monol√≠tico hibrido, y esta licenciado bajo la licencia GPL v2. 

***Evoluci√≥n***


En 1991 Linus Torvalds inicia la programaci√≥n del kernel Linux bas√°ndose en Minix (un clon de Unix desarrollado por Tenembaum en 1987).

En octubre de 1991 sale la primera versi√≥n oficial Linux(0.02) .

En 1992 se une Linux con el proyecto Gnu de Richard Stallman , la versi√≥n 1.0 aparece el 14 de marzo del 94‚Äô , luego el desarrollo de Gnu/Linux se sigue desarrollando por miles de programadores, en el 96‚Äô adoptan como mascota oficial a Tux (ping√ºinito).

En julio de 1996 se lanza la versi√≥n 2.0 y se define la nomenclatura de versionado. Se desarrollo hasta febrero de 2004 y termino con la 2.0.40. En enero de 1999 se lanza la versi√≥n 2.2, que provee mejoras de portabilidad entre otras y se desarrolla hasta febrero de 2004 terminando en la versi√≥n 2.2.26.

En 2001 se lanza la versi√≥n 2.4 y se deja de desarrollar a fines del 2010 con la 2.4.37.11. La versi√≥n 2.4 fue la que catapulto a GNU/Linux como un SO estable y robusto.

Durante este per√≠odo es que se comienza a utilizar Linux m√°s asiduamente N√∫cleo.

A fines del 2003 se lanza la versi√≥n 2.6, Esta versi√≥n ha tenido muchas mejoras para el SO dentro de las que se destacan soporte de hilos, mejoras en la planificaci√≥n y soporte de nuevo hardware.

El 3 de agosto de 2011 se lanza la versi√≥n 2.6.39.4 anunci√°ndose la misma desde meses
previos como la √∫ltima en su revisi√≥n.

El 17 de julio de 2011 se lanza la versi√≥n 3.01, No agrega mayores cambios.

La decisi√≥n del cambio son los 20 a√±os del SO y no superar los 40 n√∫meros de revisi√≥n. Totalmente compatible con 2.6. La √∫ltima versi√≥n estable es la 5.19.6 (agosto de 2022). 


---

#### `b)` ¬øCu√°les son sus funciones principales?

Funciones principales: Administrar la memoria, CPU y E/S, administraci√≥n de procesos y
comunicaci√≥n y concurrencia. 

---

#### `c)` ¬øCu√°l es la versi√≥n actual? 

La versi√≥n del kernel actual es 5.16. Lo demas a nadie le importa 

#### **¬øC√≥mo se defin√≠a el esquema de versionado del Kernel en versiones anteriores a la 2.4?**

En la versi√≥n 2.0 se define la nomenclatura del versionado:

Modo de Versionar: A.B.C.[D]

- `A)` Denota Versi√≥n. Cambia con menor Frecuencia. en 1994 (versi√≥n 1.0), en 1996 (versi√≥n 2.0) y en 2010(3.0).
- `B)` Denota Mayor revisi√≥n. Antes de la versi√≥n 2.6, los n√∫meros impares indicaban desarrollo, los pares producci√≥n.
- `C)` Denota Menor revisi√≥n. Solo cambia cuando hay nuevos drivers o caracter√≠sticas. -------------------------- la D se agrega a partir de la visi√≥n 2.4 ------------------------------------------
- `D)` Cambia cuando se corrige un grave error sin agregar nueva funcionalidad.
(casi no se usan en la rama de versiones 3.x, 4.x y 5.x vi√©ndose reflejado en el componente C del SO).

Ejemplo actualidad: versi√≥n 5.19.6

#### **¬øQu√© cambi√≥ en el versionado se impuso a partir de la versi√≥n 2.6?**

- Antes de la versi√≥n 2.6, los n√∫meros impares indicaban desarrollo, los pares producci√≥n.


---

#### `d)` ¬øEs posible tener m√°s de un Kernel de GNU/Linux instalado en la misma m√°quina?

S√≠. Se puede instalar en la misma m√°quina, pero 2 n√∫cleos corriendo simult√°neamente en Linux es imposible

---

#### `e)` ¬øD√≥nde se encuentra ubicado dentro del File System?

Se encuentra ubicado el /lib/: librer√≠as esenciales compartidas y m√≥dulos de kernel

Directorio ra√≠z de toda la jerarqu√≠a de archivos del sistema.

`\` Jerarquia Primaria

- `/bin/` Comandos binarios esenciales de usuario
- `/boot/` Archivos est√°ticos del selector de arranque
- `/dev/` Archivos de unidades
- `/etc/` Configuraci√≥n del sistema de Host Especifico
- `/home/` Directorio "home" de usuario
- `/lib/` Librerias esenciales compartidas y m√≥dulos de Kernel
- `/media/` Punto de Montaje para medios removibles
- `/mnt/` Punto de Montaje temporal para sistemas de archivos
- `/opt/` Agregados de paquetes de Software y Aplicaciones
- `/sbin/` Binarios de Sistema
- `/srv/` Datos para los servicios provistos por este sistema
- `/tmp/` Archivos temporales
- `/usr/` Unidades y aplicaciones de (Multi) usuario
- `/var/` Variables de archivo
- `/root/` Directorio "Home" del usuario Root
- `/proc/` Documentaci√≥n del sistema de archivos virtual del Kernel y las condiciones de los procesos en archivos de texto

---

#### `f)` ¬øEl Kernel de GNU/Linux es monol√≠tico? Justifique.

El kernel Gnu/Linux si es **monol√≠tico**.

**`Kernel monol√≠tico`** quiere decir que toda funcionalidad que implementa el SO se ejecuta en modo kernel o supervisor, ejemplo cuando un usuario quiere ejecutar un proceso se pasa a modo kernel se resuelve todo ah√≠ y despu√©s regresa a modo usuario cuando esa resoluci√≥n termino, toda la l√≥gica se encuentra en el modo kernel. 

**`Ventajas`** el modelado, el dise√±o implica menos tiempo en la resoluci√≥n de las cosas. (cambio de modo - resuelvo lo que tengo que resolver - vuelvo a modo usuario). 

Tambi√©n existe el ***kernel microkernel***, se trata de que el modo kernel o supervisor este el menos tiempo posible y trata de dejar en modo usuario diferentes componentes para que se ejecuten en modo usuario y que hagan de apoyo al modo kernel.

**`Ejemplo:`** el SO tiene un conjunto de procesos que van a ir cambiando cada 3 segundos, cada vez que cambia de proceso eso debe estar en modo kernel, ahora la selecci√≥n de cu√°l de esos 3 procesos va a ser seleccionado para a entrar a ejecutarse se puede hacer en modo usuario.

B√°sicamente el kernel microkernel reduce al m√°ximo el uso del modo kernel y delega cosas al modo usuario cosa que no sucede con el modo kernel.

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## `5)` Int√©rprete de comandos (Shell):

#### `a)` ¬øQu√© es?

La shell tambi√©n conocida como CLI (interfaz de l√≠nea de comando), es el que gestiona la interacci√≥n entre el usuario y el sistema operativo.

(es solo un programa que har√° de mediador entre nosotros y el kernel del SO. Puede ser tanto gr√°fico Ej. La interfase X-Window, como de texto Linux (Ej. El bash).

La Shell no forma parte b√°sico del sistema operativo si no que la misma dialogo con el kernel.\
La shell es iniciada por un proceso llamado login y dado que cada usuario tiene asignado una shell por defecto la misma se inicia cada vez que un usuario comienza a trabajar en su estaci√≥n de trabajo, es decir se loguea en una terminal. Dentro del contenido del archivo /etc/passwd, se puede ver cual es la shell que cada usuario tiene asignada por defecto.

---

#### `b)` ¬øCu√°les son sus funciones?

Es el encargado de ejecutar programas a partir del ingreso de comandos.

Ejemplo: control de procesos, redirecci√≥n de entrada/salida, listado y lectura de ficheros, protecci√≥n, comunicaciones y un lenguaje de √≥rdenes para escribir programas por lotes o (scripts o guiones).


---

#### `c)` Mencione al menos 3 int√©rpretes de comandos que posee GNU/Linux y comp√°relos entre ellos.

- **`Bourne Shell (sh)`** Creado por S. Bourne, es el m√°s utilizado en la actualidad. Su s√≠mbolo del sistema es $. Es el shell est√°ndar y el que se monta en casi todos los sistemas UNIX/Linux.
- **`Korn Shell (ksh)`** Escrito por David Korn, ampl√≠a el shell del sistema a√±adiendo historial de √≥rdenes, edici√≥n en l√≠nea de √≥rdenes y caracter√≠sticas ampliadas de programaci√≥n. 
- **`Bourne Again Shell (bash)`** Fue creado para usarlo en el proyecto GNU. BASH, por lo tanto, es un shell o int√©rprete de comandos GNU que incorpora la mayor√≠a de distribuciones de Linux. Es compatible con el shell sh. Adem√°s, incorpora algunas caracter√≠sticas √∫tiles de ksh y csh, y otras propias como la edici√≥n de l√≠nea de comandos, tama√±o ilimitado del historial de comandos, control de los trabajos y procesos, funciones y alias, c√°lculos aritm√©ticos con n√∫meros enteros, etc. Su s√≠mbolo del sistema es nombre_usuario@nombre_equipo. 


Los int√©rpretes se diferencian entre s√≠ b√°sicamente en la sintaxis de sus comandos y en la interacci√≥n con el usuario.

---

#### `d)` ¬øD√≥nde se ubican (path) los comandos propios y externos al Shell?

**PATH:** es una variable y su contenido es una cadena que contiene rutas de
directorios separadas por dos puntos.

Por ejemplo, para mostrar el valor de una variable en la shell se debe escribir:

- `echo $ nombrevariable `
- en el caso de la variable path seria
- echo$ PATH

la variable PATH contiene una lista de directorios separados por dos puntos. Estos son los directorios en los que el shell busca el comando que el usuario escribe desde el teclado.

La b√∫squeda no se realiza en el orden en el que est√°n los directorios en la variable PATH.

- Los `comandos propios`, tambi√©n conocidos como built-in commands, son aquellos que est√°n integrados en la propia shell. Estos comandos suelen ser los m√°s b√°sicos y necesarios para la gesti√≥n de la sesi√≥n y del sistema, como por ejemplo: cd (para cambiar de directorio), echo (para imprimir texto en la pantalla), exit (para salir de la sesi√≥n), entre otros.
- Por otro lado, los `comandos externos` son aquellos que se encuentran en el sistema operativo y que son invocados desde la shell. Estos comandos pueden ser programas completos o scripts que realizan una tarea espec√≠fica. Ejemplos de comandos externos son ls (para listar los archivos en un directorio), cat (para mostrar el contenido de un archivo), grep (para buscar patrones en un archivo), entre otros.

En resumen, los comandos propios est√°n integrados en la propia shell y los comandos externos son programas o scripts que se ejecutan desde la shell.


---

#### `e)` ¬øPor qu√© considera que el Shell no es parte del Kernel de GNU/Linux?

La principal razon es que es muy remplazable, en caso de que falle, se puede reiniciar y todo tendria que seguir andando.

Y tambien

La shell no forma parte del kernel de Linux porque es una aplicaci√≥n que proporciona una interfaz de l√≠nea de comandos para interactuar con el sistema operativo, mientras que el kernel es la parte central del sistema operativo que administra los recursos del hardware y proporciona servicios b√°sicos al software. Aunque la shell y el kernel trabajan juntos, son dos componentes distintos con diferentes funciones y responsabilidades.

---

#### `f)` ¬øEs posible definir un int√©rprete de comandos distinto para cada usuario? 

Si, es posible. 

#### ¬øDesde d√≥nde se define?

Se definen en etc/passwd 

#### ¬øCualquier usuario puede realizar dicha tarea?

No, cada usuario puede definir su o sus int√©rpretes

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## `6)` Sistema de Archivos (File System):

#### `a)` ¬øQu√© es?

Es la forma en que dentro de un SO se organizan y se administran los archivos.

Los usuarios de Linux hacen una distinci√≥n del filesystem. Dicen que un filesystem es un esquema de programaci√≥n que se utiliza para organizar y buscar archivos en una
partici√≥n. Mientras que el sistema de archivos se refiere a todos los archivos de la
computadora.

Lo que esto significa, b√°sicamente, es que el filesystem es la estructura que se utiliza para ver, buscar y usar los archivos mediante Ubuntu. Mientras que el sistema de archivos son todos los archivos separados de esa estructura y el formato de esos archivos. 

---

#### `b)` Mencione sistemas de archivos soportados por GNU/Linux.

A continuaci√≥n veremos una lista con algunos filesystem utilizados hoy en d√≠a:

- ext2
- ext3
- ReiserFS
- XFS

---

#### `c)` ¬øEs posible visualizar particiones del tipo FAT y NTFS en GNU/Linux?

Si. En estos momentos existen distribuciones de GNU-Linux que pueden realizar operaciones de lectura y escritura sobre ellas. 

#### `d)`  ¬øCu√°l es la estructura b√°sica de los File System en GNU/Linux? 

![image](https://user-images.githubusercontent.com/55964635/227661611-40497548-8ce3-4142-88f9-e193515a9d88.png)

#### Mencione los directorios m√°s importantes e indique qu√© tipo de informaci√≥n se encuentra en ellos.

- **`/`** Tope de la estructura de directorios. Es como el C:\ (ra√≠z).
- **`/home`** Se almacenan archivos de usuarios (Mis documentos)
- **`/var`** Informaci√≥n que var√≠a de tama√±o (logs, BD, spools)
- **`/etc`** Archivos de configuraci√≥n del sistema.
- **`/bin`** Archivos binarios y ejecutables.
- **`/dev`** Enlace a dispositivos.
- **`/usr`** Aplicaciones de usuarios

#### ¬øA qu√© hace referencia la sigla FHS?

(Filesystem Hierarchy Standard - Est√°ndar de jerarqu√≠a del sistema de archivos).

FHS: es el est√°ndar que siguen todos los sistemas operativos unix, para organizar el sistema de archivos. 

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## `7)` Particiones:

#### `a)`  Definici√≥n

Es el nombre que recibe cada divisi√≥n de una sola unidad f√≠sica de almacenamiento
de datos. (es un pedazo de una unidad ).

Toda partici√≥n tiene su propio sistema de archivos (formato); generalmente, casi cualquier sistema operativo interpreta, utiliza y manipula cada partici√≥n como un disco f√≠sico independiente, a pesar de que dichas particiones est√©n en un solo disco f√≠sico.

---

#### Tipos de particiones

Existen 3 tipos diferentes de particiones:

- **`Partici√≥n primaria`** Son las divisiones crudas o primarias del disco, solo puede haber 4 de √©stas o 3 primarias y una extendida. Depende de una tabla de particiones. Un disco f√≠sico completamente formateado consiste, en realidad, de una partici√≥n primaria que ocupa todo el espacio del disco y posee un sistema de archivos. A este tipo de particiones, pr√°cticamente cualquier sistema operativo puede detectarlas y asignarles una unidad, siempre y cuando el sistema operativo reconozca su formato (sistema de archivos). 
- **`Partici√≥n extendida`** Tambi√©n conocida como partici√≥n secundaria es otro tipo de partici√≥n que act√∫a como una partici√≥n primaria; sirve para contener m√∫ltiples unidades l√≥gicas en su interior. Fue ideada para romper la limitaci√≥n de 4 particiones primarias en un solo disco f√≠sico. Solo puede existir una partici√≥n de este tipo por disco, y solo sirve para contener particiones l√≥gicas. Por lo tanto, es el √∫nico tipo de partici√≥n que no soporta un sistema de archivos directamente.
- **`Partici√≥n l√≥gica`** Ocupa una porci√≥n de la partici√≥n extendida o la totalidad de la misma, la cual se ha formateado con un tipo espec√≠fico de sistema de archivos (FAT32, NTFS, ext2,...) y se le ha asignado una unidad, as√≠ el sistema operativo reconoce las particiones l√≥gicas o su sistema de archivos. Puede haber un m√°ximo de 23 particiones l√≥gicas en una partici√≥n extendida.

---

#### Ventajas

- **`Facilidad de reinstalaci√≥n.`** Si separamos los archivos Windows de nuestra informaci√≥n personal, ser√° mucho m√°s f√°cil reinstalar Windows. Esto es porque nos ¬´ata¬ª todo lo que tenemos guardado, evitando formatear o intentando hallar otras soluciones antes que esa. De hecho, podemos clonar la partici√≥n de Windows para hacer restauraci√≥n.
- **`Copias de seguridad.`** Las copias de seguridad son las que nos salvan de los problemas catastr√≥ficos (que me lo digan a m√≠). Siempre hay que funcionar sobreseguro, lo que se traduce en tener backups de toda la informaci√≥n, o de la m√°s importante. Las particiones nos dan la ventaja de tener un volumen para copias de seguridad.
- **`M√°s seguridad.`** Imaginad que nuestra partici√≥n de Windows queda infectada por un virus y perdemos toda la informaci√≥n hallada en ella. Tener nuestra informaci√≥n importante en otra partici√≥n nos salva de un gran apuro, especialmente si el virus es ransomware. Igualmente, instalad un antivirus y funcionad con √©l.
- **`Mejor organizaci√≥n.`** Esto depende de la persona, pero es innegable que podemos organizarnos mucho mejor teniendo varias particiones. As√≠, podemos clasificar toda nuestra informaci√≥n de mayor a menor importancia, o seg√∫n el tipo de informaci√≥n, tama√±o, etc. 
- **`Instalar dos o m√°s sistemas operativos.`** En mi opini√≥n, es uno de los motivos principales por los que las personas hacen particiones. En el pasado, hice una partici√≥n para usar OS X y Windows, creando un arranque dual que me permitiera elegir el sistema operativo que quisiese iniciar. Al fin y al cabo, ten√©is un volumen listo para usar. 
- **`M√°quinas virtuales.`** Quienes trabaj√©is con ellas, har√©is particiones para instalar una m√°quina virtual en ella. Es una gran idea para separar nuestro PC de nuestra m√°quina virtual. Por tanto, podemos tener ambos contenidos separados; de lo contrario, si algo falla, podr√≠amos perder toda la informaci√≥n de nuestro PC y m√°quina virtual.

---

#### Desventajas

- **`Experiencia m√°s lenta.`** Si tenemos muchas particiones, puede que nos cueste encontrar un archivo en concreto. Aqu√≠ hay que ser muy met√≥dico y ordenado para saber qu√© partici√≥n es vital, como cu√°l es prescindible. Al final, tardamos en encontrar algo por tener demasiadas particiones.
- **`Posibilidad de errores.`** Existe la posibilidad de que surjan m√°s fallos cuando tenemos muchas particiones. Son meras cuestiones de probabilidad, as√≠ que no hay que volverse loco.
- **`Desorden en los vol√∫menes.`** Es f√°cil que esto ocurra; de hecho, me ha pasado muchas veces a m√≠. Cuando hacemos una partici√≥n, formateamos, volvemos a crear un volumen, etc., podemos crear particiones extendidas que no van a ning√∫n sitio. En mi caso, se trataba de una partici√≥n de 700 MB en un HDD de 2 TB: el impacto es m√≠nimo. Sin embargo, no tiene gracia que nos pase en un SSD de poca capacidad.
- **`Innecesario para el usuario medio.`** Al final, las personas que utilizan el PC para ¬´3 cosas¬ª, no requieren particiones, ni se quieren liar a aprender c√≥mo funciona esto. Por tanto, es una opci√≥n limitada a aquellos que buscan cierta utilidad. 

---

#### `b)` ¬øC√≥mo se identifican las particiones en GNU/Linux? (Considere discos **IDE**, **SCSI** y **SATA**).

El primer disco duro **`IDE`** se conoce como /dev/hda. Si tenemos un segundo disco duro IDE se llamar√° /dev/hdb, etc.

Los discos duros **`SCSI`** y **`SATA`** se denominan /dev/sda, /dev/sdb, etc. En cada disco son representadas **a√±adiendo un n√∫mero decimal al nombre del disco**: sda1 y sda2 representan a la primera y segunda partici√≥n en la primera unidad de disco SCSI en el sistema.

---

#### `c)` ¬øCu√°ntas particiones son necesarias como m√≠nimo para instalar GNU/Linux? N√≥mbrelas indicando tipo de partici√≥n, identificaci√≥n, tipo de File System y punto de montaje.

Si bien el n√∫mero **m√≠nimo absoluto de particiones ser√≠a uno (1)**, una **instalaci√≥n t√≠pica de GNU / Linux tendr√° al menos dos (2)** particiones: la partici√≥n ra√≠z (indicada como /) y la partici√≥n de **intercambio**. Puede optar por tener todos los archivos en una sola partici√≥n dentro de la mayor√≠a de las distribuciones durante la instalaci√≥n.

El esquema de particiones est√°ndar para la mayor√≠a de las instalaciones dom√©sticas de Linux es el siguiente: Una partici√≥n de 12-20 GB para el sistema operativo, que se monta como / (llamada **‚Äúra√≠z‚Äù** o **root**) Una partici√≥n m√°s peque√±a que se utiliza para aumentar su RAM, montada y denominada **/swap**. Una mampara m√°s grande para uso personal, montada como **/home**

Para una instalaci√≥n de **GNU/Linux saludable se recomiendan 3 particiones swap, root y home**.

**Hay 2 tipos de particiones principales en un sistema Linux:**

- **`Partici√≥n de datos`** datos normales del sistema Linux, incluida la partici√≥n ra√≠z que contiene todos los datos para iniciar y ejecutar el sistema; y.
- **`Partici√≥n de intercambio`** expansi√≥n de la memoria f√≠sica de la computadora, memoria extra en el disco duro.
- **`Tipo de filesystem`** Sistema de archivos Ext2, ext3 y ext4: As√≠ como Apple y Microsoft tienen sus propios sistemas, estos tres (cada uno evoluci√≥n del anterior) son los utilizados por las distribuciones GNU/Linux. El principal inconveniente es que s√≥lo puede ser utilizado en esta familia de sistemas operativos. 

**`Tipo de filesystem`** Sistema de archivos **Ext2, ext3 y ext4**: As√≠ como Apple y Microsoft tienen sus propios sistemas, estos tres (cada uno evoluci√≥n del anterior) son los utilizados por las distribuciones GNU/Linux. El principal inconveniente es que s√≥lo puede ser utilizado en esta familia de sistemas operativos. 


#### `d)` Ejemplifique diversos casos de particionamiento dependiendo del tipo de tarea que se deba realizar en su sistema operativo.

**`Integraci√≥n de nuevas adquisiciones`** Si forma una empresa nueva. La empresa reci√©n formada no utiliza las mismas aplicaciones para las n√≥minas, el inventario y la facturaci√≥n. Tiene previsto consolidar las dos empresas en un solo conjunto de aplicaciones, pero esta consolidaci√≥n tardar√° un tiempo. Mientras tanto, debe reducir el coste de los centros de datos con rapidez. 

Por tanto, decide crear particiones l√≥gicas para las aplicaciones utilizadas por la empresa reci√©n adquirida. Instala un sistema operativo y las aplicaciones utilizadas por la empresa nueva en la partici√≥n l√≥gica. Si las cargas de trabajo combinadas necesitan m√°s recursos. 

**`Creaci√≥n de varios entornos de cliente`** El usuario suministra servicios e-commerce de alta disponibilidad a diversos clientes. Proporciona recursos de sistema, aplicaciones y soporte t√©cnico a cada cliente, y cada cliente puede configurar y utilizar independientemente las aplicaciones ejecutadas en los recursos de sistema suministrados. En un entorno de este tipo, es esencial aislar a los clientes para que s√≥lotengan acceso a sus recursos. Sin embargo, dedicar un servidor f√≠sico a cada cliente tiene un coste prohibitivo, y no permite aumentar ni disminuir f√°cilmente la cantidad de recursos de sistema utilizados por cada cliente. 

Por tanto, decide crear una partici√≥n l√≥gica para cada cliente. Instala un sistema operativo y aplicaciones en cada partici√≥n l√≥gica. A continuaci√≥n, puede utilizar el particionamiento din√°mico para a√±adir recursos a particiones l√≥gicas o eliminar recursos de ellas seg√∫n sea necesario. Si un cliente deja de utilizar el servicio, puede suprimir la partici√≥n l√≥gica de dicho cliente y reasignar los recursos a otras particiones l√≥gicas 


#### `e)` ¬øQu√© tipo de software para particionar existe? Menci√≥nelos y compare

Existen 2 tipos:

- **Destructivos:** permiten crear y eliminar particiones (fdisk)
- **No destructivo:** permiten crear, eliminar y modificar particiones

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## `8)` Arranque (bootstrap) de un Sistema Operativo:

#### `a)` ¬øQu√© es el BIOS? 

La BIOS (Sistema B√°sico de Entrada/Salida) es un software que inicializa y comprueba todos los componentes de hardware durante el arranque de la m√°quina. Tambi√©n prepara el equipo para que el Sistema Operativo se cargue y se ejecute. Su nombre viene de las siglas en ingl√©s Basic Input Output System.

La Bios es un software de bajo nivel que se encuentra en el Motherboard. Cuando se arranca la computadora el bios se ejecuta, realizando el POST (power ‚Äì on Self -test) que incluye rutinas que, entre otras actividades, fijan valores de se√±ales internas y ejecutan test internos (ram , teclado etc). 

#### ¬øQu√© tarea realiza?

- **`POST`** POST es un acr√≥nimo de Power-On Self Test (Autocomprobaci√≥n de encendido) que se ejecuta en tu PC en el momento en que la enciendes. El POST prueba el hardware de tu computadora y se asegura de que no exista ninguna aver√≠a ni haya errores presentes en su sistema operativo.
El POST comprueba todo, desde el teclado y la unidad de disco, hasta la velocidad de la RAM en una computadora y los puertos integrados. Si todo est√° en orden, POST continuar√° como de costumbre y permitir√° que tu PC se inicie normalmente. Si se detecta un error, el BIOS emitir√° un mensaje de error que puede aparecer en forma de texto en la pantalla o una serie de pitidos indicativos de dicho error. Estos sonidos siempre son se√±ales para mensajes determinados, por lo que, si te sucede esto, deber√°s verificar lo que ello significa para el hardware de tu computadora.
- **`Configuraci√≥n del CMOS`** Tu PC almacena todas las configuraciones de bajo nivel como la hora del sistema y la configuraci√≥n de hardware dentro del CMOS. Esto significa que cada cambio que realices en la estructura del BIOS se guardar√° en este chip de memoria especial llamado Semiconductor Complementario de √ìxido Met√°lico, o CMOS (por sus siglas en ingl√©s). La configuraci√≥n del CMOS es responsable, a su vez, de configurar tu contrase√±a, hora y fecha.
- **`Cargador de arranque`** El cargador de arranque, programa que vive dentro de la EPROM o ROM de tu computadora, tiene la tarea de leer el sector de arranque del disco duro de tu PC para moverse a lo largo de todo el proceso de carga del sistema operativo. 

---

#### `b)` ¬øQu√© es UEFI? 

UEFI (Unified Extensible Firmware Interface o Interfaz de Firmware Extensible Unificada). Es la Alianza entre varias compa√±√≠as con el objetivo de modernizar el proceso de arranque, quer√≠an reemplazar a la BIOS. Sus funciones son parecidas a los de la BIOS, pero mejoradas. UEFI aporta criptograf√≠a, autenticaci√≥n por red, y una interfaz gr√°fica. 


#### ¬øCu√°l es su funci√≥n?

Usa el sistema GPT (GUID Partition table) para solucionar algunas limitaciones del MBR, tales como la cantidad de particiones y capacidad m√°xima del dispositivo particionado.

---

#### `c)` ¬øQu√© es el MBR? 

Sector de arranque ‚Äì MBR

El Master Boot Record es el primer sector del disco f√≠sico.

Se ubica en el cilindro 0, cabeza 0, sector 1. En todos los discos existe un MBR, pero el mismo es tenido en cuenta si el disco contiene las particiones del sistema.

El tama√±o de MBR coincide con el tama√±o estandard de sector del disco, generalmente 512 bytes. Estos bytes contienen lo siguiente:

#### ¬øQue es el MBC?

El MBC es un peque√±o c√≥digo que permite arrancar el sistema operativo. La tarea del MBC consiste en buscar una entrada de la tabla de particiones marcada con el valor 0x80 indicando que esta entrada es booteable lo cual indica que la partici√≥n correspondiente a esta entrada es booteable. La √∫ltima acci√≥n del BIOS es leer el MBC. Lo lleva a memoria y lo ejecuta. 

---

#### `d)` ¬øA qu√© hacen referencia las siglas GPT? 

Una partici√≥n GPT GUID Partition Table es un est√°ndar dise√±ado para realizar la configuraci√≥n de las tablas de particiones y su ubicaci√≥n en medios de almacenamiento como los discos duros f√≠sicos.

Puede ser utilizado independientemente de la UEFI.

#### ¬øQu√© sustituye? Indique cu√°l es su formato.

`MBR` es la tabla de particiones tradicional que soporta los sistemas operativos m√°s antiguos, mientras que `GPT` es un nuevo sustituto que no tiene l√≠mites en cuanto al tama√±o del disco y el n√∫mero de particiones que se pueden crear

**`Las ventajas de GPT sobre MBR`**

- Soporta discos duros m√°s grandes que 2TiB.
- Permite crear particiones te√≥ricamente ilimitadas. 
- Contiene una verificaci√≥n de redundancia c√≠clica para comprobar la integridad de sus datos.
- Contiene la copia de seguridad del encabezado GPT primario y las entradas de la partici√≥n que protege mejor los datos del disco.

---

#### `e)` ¬øCu√°l es la funcionalidad de un ‚ÄúGestor de Arranque‚Äù? ¬øQu√© tipos existen? ¬øD√≥nde se instalan? Cite gestores de arranque conocidos.

Un gestor de arranque, es un programa que se encarga del inicio del ordenador, antes del sistema operativo, y que nos permite elegir el sistema operativo que queremos cargar, es decir se encarga del bootstrap (carga) o booteo del sistema.

Es el encargado de carga el sistema operativo (kernel) de un ordenador en la memoria RAM.

Se ejecuta luego del c√≥digo de la BIOS.

Los datos de un sistema operativo deben cargarse directamente en la memoria RAM al iniciarse el dispositivo. Esto es posible con el bootloader, tambi√©n conocido como gestor de arranque. El bootloader suele ejecutarse directamente al arrancar un dispositivo usando alg√∫n medio que sea booteable, es decir, que sirva como unidad de arranque, como puede ser un disco duro, un CD o DVD, o un stick booteable. El medio de arranque recibe la informaci√≥n acerca de d√≥nde se encuentra el bootloader por parte del firmware del ordenador (BIOS, por ejemplo). Al proceso completo se le denomina inicio, arranque o, en ingl√©s to boot. 

En lo que a la ubicaci√≥n de los bootloaders se refiere, se han consolidado dos opciones: 

- **`El bootloader se guarda en el primer bloque del medio booteable o de arranque (MBR):`** Est√° estrechamente relacionada con el principio de los Master Boot Records, que no solo contienen la referencia necesaria por parte del firmware hacia el bootloader, sino tambi√©n el software de inicio en s√≠. Para el record se reserva siempre el primer bloque o sector de memoria disponible en el medio. Este bloque o sector tambi√©n es llamado, precisamente por esta funci√≥n tan importante, boot block o boot sector.
- **`El bootloader se guarda en una partici√≥n espec√≠fica del medio de arranque:`** El sistema operativo usa como lugar de almacenamiento del bootloader una partici√≥n seleccionada, si bien el sistema de archivos de base y la tabla de particiones utilizada no tienen por qu√© coincidir en absoluto. El firmware siempre es un factor decisivo y, este tipo de ubicaci√≥n del bootloader, requiere adem√°s un formato de archivo espec√≠fico del gestor de arranque. En dispositivos con UEFI se trata, por ejemplo, del formato PE/COFF (Portable Executable / Common Object File Format). 

**Algunos gestores de arranque: GRUB**
- GRUB 2
- LILO o SYSLINUX.
- NTLDR
- GAG
- YaST 

GRand Unified Bootloader(grub): gestor de arranque m√∫ltiple que se usa para iniciar dos o m√°s sistemas operativos instalados en un mismo ordenador. 

---

#### `f)` ¬øCu√°les son los pasos que se suceden desde que se prende una computadora hasta que el Sistema Operativo es cargado (proceso de bootstrap)?

Cuando aprietas el bot√≥n de arranque de un ordenador, lo primero que aparece en la pantalla son los datos acerca del hardware del equipo. El software responsable de esta informaci√≥n es, en primer lugar, el ya mencionado firmware, que los productores de los dispositivos por lo general implementan en una memoria flash en la placa base o mainboard. En la mayor√≠a de los ordenadores de mesa y port√°tiles se apuesta por el ya veterano BIOS (Basic Input/Output System) o por el m√°s reciente UEFI (Unified Extensible Firmware Interface). Ambos programas re√∫nen diferentes datos del hardware y para generar, entre otras cosas, una lista completa de todas las unidades de disco disponibles en el dispositivo. 

Una vez se ha completado este proceso, el firmware comprueba uno a uno los soportes de datos encontrados en busca del bootloader o, m√°s concretamente, la llamada boot signature o boot record. La b√∫squeda se inicia siempre en los medios extra√≠bles conectados (CD/DVD, stick USB, discos duros externos, etc.) y luego pasa a los discos duros internos. En estos √∫ltimos, el bootloader (o la boot signature) suele estar en el Master Boot Record (MBR), que tambi√©n aloja la tabla de particiones del soporte de datos. Cuando se encuentre un bootloader, este se cargar√° y se iniciar√° as√≠ el sistema. Si la b√∫squeda, en cambio, no tiene √©xito, el firmware mostrar√° un mensaje de error. 

---

####  `g)` Analice el proceso de arranque en GNU/Linux y describa sus principales pasos.

Ell flujo de control durante el arranque es desde el¬†**[BIOS]()**, al¬†**[gestor de arranque]()**¬†y al n√∫cleo (**[kernel]())**). 

- **Kernel:** Este inicia el planificador (para permitir la¬†**[multitarea]()**) y ejecuta el primer¬†**[espacio de usuario]()**¬†(fuera del espacio del n√∫cleo) y el programa de inicializaci√≥n (que establece el entorno de usuario y permite la interacci√≥n del usuario y el¬†**[inicio de sesi√≥n]())**, momento en el que el n√∫cleo se inactiva hasta que sea llamado externamente.

- La etapa del¬†**[cargador de arranque]()**¬†no es totalmente necesaria. Determinadas BIOS pueden cargar y pasar el control a Linux sin hacer uso del cargador. Cada proceso de arranque ser√° diferente dependiendo de la arquitectura del¬†**[procesador]()**¬†y el¬†*BIOS*.

- En el apagado,¬†Init¬†es llamado a cerrar toda las funcionalidades del espacio de usuario de una manera controlada, de nuevo a trav√©s de secuencias de comandos, tras lo cual el¬†Init¬†termina y el n√∫cleo ejecuta el apagado.

---

#### `h)` ¬øCu√°les son los pasos que se suceden en el proceso de parada (shutdown) de GNU/Linux?

- Se notifica a los usuarios este hecho.
- Se bloquea el sistema para que nadie m√°s pueda acceder exceptuando el **root**.
- Se env√≠a la se√±al **SIGTERM** (se√±al de terminaci√≥n) a todos los procesos no definidos en **inittab**(contiene un registro para cada proceso que define los niveles de ejecuci√≥n para ese proceso) para el siguiente run level, provocando que terminen su ejecuci√≥n de modo ordenado.

---

#### `i)` ¬øEs posible tener en una PC GNU/Linux y otro Sistema Operativo instalado? Justifique

Si es posible ya lo vimos anteriormente gracias a las particiones de disco instalar m√∫ltiples sistema operativos o a trav√©s de maquinas virtuales.

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## `9)` Archivos

#### `a)` ¬øC√≥mo se identifican los archivos en GNU/Linux?

Un nombre de archivo puede tener entre 1 y 255 caracteres. recomendable emplear los caracteres con significado especial en Linux, que son los siguientes: **= \ ^ ~ ' " ` * ; - ? ( )! & ~ < >**

---

#### `b)` Investigue el funcionamiento de los editores vi y mcedit, y los comandos cat y more.

- **VI**
Es el editor de texto cl√°sico en UNIX. Puede usarse en cualquier tipo de terminal con un m√≠nimo de teclas.

**MODOS DE VI:**
Existen tres modos o estados de vi:

- **Modo comando:** Este es el modo en el que se encuentra el editor cada vez que se inicia.
Las teclas ejecutan acciones (comandos) que permiten mover el cursor, ejecutar comandos de edici√≥n de texto, salir de **vi**, guardar cambios, etc.
- **Modo inserci√≥n o texto:** Este es el modo que se usa para insertar el texto. Existen varios
comandos que se pueden utilizar para ingresar a este modo.
- **Modo l√≠nea o ex:** Se escriben comandos en la √∫ltima l√≠nea al final de la pantalla.

- **MCEDIT**

Al igual que Vi funciona como gestor de archivos

- **cat**
Es la abreviatura de concatenar. Esto se refiere al hecho de que cat puede ser utilizado para combinar m√∫ltiples archivos en un archivo, tambi√©n se puede utilizar para crear nuevos archivos y para mostrar el contenido de los archivos existentes.

- **more**
Es un¬†comando para ver (pero no modificar) el contenido de un archivo o comando y visualizarlo por p√°ginas.

---

#### `c)` Cree un archivo llamado ‚Äúprueba.exe‚Äù en su directorio personal usando el vi. El mismo debe contener su n√∫mero de alumno y su nombre.

- Utilice el siguiente comando para crear un archivo (en este ejemplo, .htaccess). Tambi√©n puede editar un archivo existente con el mismo comando. 

```
nvim fabianmartinezrincon.txt
```

- Pulse la tecla de la letra i para cambiar al modo de entrada.
- Inserte el contenido deseado o realice las modificaciones deseadas.
- Pulse la tecla ESC para salir del modo de entrada.
- Guarde el nuevo archivo o los cambios realizados con el siguiente comando:

```
:wq
```

---

#### `d)` Investigue el funcionamiento del comando file. Pru√©belo con diferentes archivos. ¬øQu√© diferencia nota?

Permite detectar el tipo y¬†formato¬†de un archivo

```css
file [opciones] archivo
```

- `b)` muestra solo el tipo de archivo sin ninguna informaci√≥n adicional.
- `i)` fuerza el uso de la sintaxis MIME para mostrar el tipo de archivo.
- `z)` trata los archivos como si estuvieran comprimidos.

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

### `10)` Indique qu√© comando es necesario utilizar para realizar cada una de las siguientes acciones. Investigue su funcionamiento y par√°metros m√°s importantes:

- `mkdir "ISO 2022"` Cree la carpeta ISO2017 
- `cd 'ISO 2022'` Acceda a la carpeta (cd)
- `touch ISO2022-1 ISO2022-2` Cree dos archivos con los nombres iso2017-1 e iso2017-2 (touch)
- `ls` Liste el contenido del directorio actual (ls)
- `pwd` Visualizar la ruta donde estoy situado (pwd)
- `find ./'ISO 2022' -name "ISO*"` Busque todos los archivos en los que su nombre contiene la cadena ‚Äúiso*‚Äù (find)
- `df` Informar la cantidad de espacio libre en disco (df)
- `who` Verifique los usuarios conectado al sistema (who)
- `vi ISO2022-1` Acceder a el archivo iso2017-1 e ingresar Nombre y Apellido
- `tail ISO2022-1` Mostrar en pantalla las √∫ltimas l√≠neas de un archivo (tail).

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

### `11)` Investigue su funcionamiento y par√°metros m√°s importantes:

- `shutdown`  El comando de apagado (Shutdown) te permite apagar, reiniciar y detener tu sistema

```
sudo shutdown
sudo shutdown now
sudo shutdown [time]
sudo shutdown 11:50
sudo shutdown +5
sudo shutdown +2 "System update"
sudo shutdown -r
sudo shutdown +3 ‚Äìr "Update System"
sudo shutdown -c
```

| Options  | Description |
| ------------- | ------------- |
| -a  | To control access to the ‚Äúshutdown‚Äù command, it employs the control access file ‚Äú/etc/shutdown.allow.‚Äù  |
| -k  | Instead of shutting down, deliver warning messages as though the shutdown is actual.  |
| -P  | Tells the system to power down before shutting down.  |
| -f  | It skips fsck after reboot.  |
| -F  | After reboot it forces fsck.  |
| -H  | This option orders the system to descend into the boot the monitor on computers which provide support to it if -h is also supplied.  |

---

- `sudo reboot` Sirve para reiniciar el equipo
- `sudo halt` El comando¬†halt detiene la CPU del ordenador
- `locate` El comando locate es una alternativa √∫til, ya que es m√°s r√°pido que find para realizar b√∫squedas. Eso se debe a que s√≥lo escanea tu base de datos de Linux en lugar de todo el sistema. Adem√°s, la sintaxis es m√°s f√°cil de escribir `sudo apt install locate`
- `uname` Se usa para verificar la informaci√≥n del sistema
    ```
    uname -s
    uname -r
    uname -v
    uname -n
    uname -m
    uname -p
    uname -i
    uname -o
    uname -a
    ```
- `gmesg` (No entiendo porque esta diferente) El comando `dmesg` es una utilidad de Linux que muestra mensajes relacionados con el kernel recuperados del b√∫fer de anillo del kernel. `dmesg`
- `lspci` El comando lspci lista todos los componentes tipo pci como son las tarjetas de red, tarjetas de sonido o tarjetas de televisi√≥n. 
- `at` Ejecuta comandos a la hora especificada.
- `netstat` Los administradores de sistemas utilizan netstat el comando de Linux para ver informaci√≥n sobre las conexiones de red `sudo apt install net-tools`
- `mount` Se utiliza para montar dispositivos y particiones para su uso por el sistema operativo <br> <br>
    ```
    sudo apt install nfs-common
    sudo mkdir -p /mnt/client_ shareddirectory
    sudo mount [nfs_server]:/[nfs_shareddirectory] [client_mountpoint]
    ```
- `umount` El comando umount le permite eliminar un sistema de archivos remoto que est√© montando en la actualidad `umount --all`
- `head` Este¬†comando sirve principalmente para mostrar al principio de un archivo (de texto) o para reducir a lo especificado los datos mostrados por un¬†comando de¬†Linux
- `losetup` losetup de comandos de Linux se utiliza para fijar el dispositivo de bucle.
**par√°metros:**
    - `d` dispositivo extra√≠ble.
    - `e` <cifrado> Iniciar cifrado codificaci√≥n.
    - `o` <n√∫mero de traducci√≥n> Establecer el n√∫mero de conversi√≥n de datos.
- `write` sirve para enviar un mensaje a otro usuario del sistema.
    - write usuario
    - Escribo aqu√≠ lo que
    - quiera que le llegue y luego cierro.
    - Control-D
- `mkfs` Se utiliza para dar formato a un dispositivo de almacenamiento de bloque con un determinado sistema de archivos
- `fdisk` (con cuidado) Permite al usuario crear particiones en el disco duro de la misma manera que su contraparte de MS-DOS

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

### `12)` Investigue su funcionamiento y par√°metros m√°s importantes:

- `a)`  Indique en qu√© directorios se almacenan los comandos mencionados en el ejercicio anterior.

El directorio /bin es un directorio est√°tico y es donde se almacenan todos los binarios necesarios para garantizar las funciones b√°sicas a nivel de usuario. Solo almacena los ejecutables de usuario, ya que los binarios necesarios para tareas administra/vas gestionadas por el usuario root o s√∫per-usuario del sistema se encuentran en el directorio / sbin.

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

<div align="center"> 

# üìì Practica 2

</div>

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">



El objetivo de esta pr√°ctica es que el alumno comprenda los aspectos principales acerca de la estructura del sistema Operativo GNU/Linux en lo que respecta a procesos, usuarios, filesystems,
permisos, etc

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## `1)` Editor de textos:
#### `(a)` Nombre al menos 3 editores de texto que puede utilizar desde la l√≠nea de comandos.

-  **Vim:** Es un editor de texto que rompe las bolas pero aprendes
- **GNU Emacs:** La misma basura que vim pero con calculadora y administrador de archivos
- **mcedit:** Te permite navegar entre los ficheros con una interfaz.

---

#### `(b)` ¬øEn qu√© se diferencia un editor de texto de los comandos cat, more o less? Enumere los modos de operaci√≥n que posee el editor de textos vi.

Los **comandos cat, more y less** permiten mostrar el contenido de ficheros de texto desde la l√≠nea de comandos en sistemas **Unix**. 

En su lugar los **editores de texto**, justamente nos dejan **editar texto** adem√°s de poder **visualizarlo**. 

- `cat` imprimir√° por pantalla el contenido del fichero sin ning√∫n tipo de paginaci√≥n ni posibilidad de modificarlo. B√°sicamente concatena archivos o la salida est√°ndar en la salida est√°ndar. 
- `more` permite visualizar por pantalla el contenido de un fichero de texto, con la diferencia con el anterior de que `more` p√°gina los resultados. Primero mostrar√° por pantalla todo lo que se pueda visualizar sin hacer scroll y despu√©s, pulsando la tecla espacio avanzar√° de igual modo por el fichero. 
- `less` es el m√°s completo de los tres, pues puede hacer todo lo que hace `more` a√±adiendo mayor capacidad de navegaci√≥n por el fichero (avanzar y retroceder) adem√°s de que sus comandos est√°n basados en el editor `vi`, del cual se diferencia en que no tiene que leer todo el contenido del fichero antes de ser abierto.

---

`(c)` Nombre los comandos m√°s comunes que se le pueden enviar al editor de textos vi

- [Comandos basicos](https://docs.oracle.com/cd/E19620-01/805-7644/6j76klopr/index.html)

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## `2)` Proceso de Arranque SystemV:
#### `(a)` Enumere los pasos del proceso de inicio de un sistema GNU/Linux, desde que se prende la PC hasta que se logra obtener el login en el sistema.

- `Paso 1)` Se empieza a ejecutar el c√≥digo del BIOS
- `Paso 2)` El BIOS ejecuta el POST
- `Paso 3)` El BIOS lee el sector de arranque (MBR)
- `Paso 4)` Se carga el gestor de arranque (MBC)
- `Paso 5)` El bootloader carga el kernel y el initrd
- `Paso 6)` Se monta el initrd como sistema de archivos ra√≠z y se inicializan componentes esenciales (ej.: scheduler)
- `Paso 7)` El Kernel ejecuta el proceso init y se desmonta el initrd
- `Paso 8)` Se lee el /etc/inittab
- `Paso 9)` Se ejecutan los scripts apuntados por el ***runlevel 1***
- `Paso 10)` El final del ***runlevel 1*** le indica que vaya al runlevel por defecto
- `Paso 11)` Se ejecutan los scripts apuntados por el runlevel por defecto
- `Paso 12)` El sistema est¬¥a listo para usarse

---

#### `(b)` Proceso INIT. ¬øQui√©n lo ejecuta? ¬øCu√°l es su objetivo?
- Su funci√≥n es cargar todos los subprocesos necesarios para el correcto funcionamiento del SO
- El proceso init posee el PID 1 y se encuentra en **/sbin/init**
- En SysV se lo configura a traves del archivo **/etc/inittab**
- No tiene padre y es el padre de todos los procesos (pstree)
- Es el encargado de montar los filesystems y de hacer disponible los dem¬¥as dispositivos

---

#### `(c)` Ejecute el comando pstree. ¬øQu√© es lo que se puede observar a partir de la ejecuci√≥n de este comando?

El programa pstree facilita informaci√≥n sobre la finalizaci√≥n de una serie de procesos relacionados entre s√≠, esto es, todos los descendientes de un proceso particular. El programa deja claro desde un principio que proceso es el primario y cuales son los secundarios.

---

#### `(d)` RunLevels. ¬øQu√© son? ¬øCu√°l es su objetivo?
- Es el modo en que arranca Linux (3 en Redhat, 2 en Debian)
- El proceso de arranque lo dividimos en niveles
- Cada uno es responsable de levantar (iniciar) o bajar (parar) una serie de servicios
- Un nivel de ejecuci√≥n es b√°sicamente una configuraci√≥n de programas y servicios que se ejecutar√°n orientados a un determinado funcionamiento. 

Explicaci√≥n m√°s detallada

- `Paso 1)` Cuando un sistema GNU/Linux arranca, primero se carga el kernel del sistema, despu√©s se inicia el primer proceso, denominado **init**, que es el responsable de ejecutar y activar el resto del sistema, mediante la gesti√≥n de los niveles de ejecuci√≥n (o **runlevels**).
- `Paso 2)` En el caso del modelo runlevel de SystemV, cuando el proceso init arranca, utiliza un fichero de configuraci√≥n llamado **/etc/inittab** para decidir el modo de ejecuci√≥n en el que va a entrar.
- `Paso 3)` En este fichero se define el runlevel por defecto (initdefault) en arranque (por instalaci√≥n en Fedora el 5, en Debian el 2) y una serie de servicios de terminal por activar para atender la entrada del usuario.
- `Paso 4)` Despu√©s, el sistema, seg√∫n el runlevel escogido, consulta los ficheros contenidos en **/etc/rcn.d**, donde **n** es el n√∫mero asociado al runlevel (nivel escogido), en el que se encuentra una lista de servicios por activar o parar en caso de que arranquemos en el runlevel, o lo abandonemos
- `Paso 5)` Dentro del directorio encontraremos una serie de **scripts** o enlaces a los scripts que controlan el servicio. Cada script posee un nombre relacionado con el servicio, una S o K inicial que indica si es el script para iniciar **(S)** o matar **(K)** el servicio, y un n√∫mero que refleja el orden en que se ejecutar√°n los servicios. 


#### `(e)` ¬øA qu√© hace referencia cada nivel de ejecuci√≥n seg√∫n el est√°ndar? [Fuente](https://www.factor.mx/portal/base-de-conocimiento/niveles-de-ejecucion/)

- **`0`** Indica halt o apagado de la m√°quina.
- **`1`** Indica monousuario.
- **`2`** Indica modo multiusuario sin soporte de red.
- **`3`** Indica modo multiusuario completo con soporte de red.
- **`4`** No usado, con esta opci√≥n el administrador puede personalizar el inicio para cargar alg√∫n servicio.
- **`5`** Indica multiusuario completo con inicio gr√°fico (X11)
- **`6`** Indica shutdown y reboot: Se apaga inmediatamente la m√°quina para reinicio.

Un administrador (root) puede editar el archivo **/etc/inittab** como mejor convenga al usuario, sin embargo tambi√©n tiene el poder de establecerlo en 0 o en 6. Si se establece en 6, algo que hice como experimento en mi Mandriva, la pr√≥xima vez que la m√°quina se encienda, se leer√° el modo 6, shutdown y reboot, y se har√° exactamente eso. 

---

#### ¬øD√≥nde se define qu√© Runlevel ejecutar al iniciar el sistema operativo?

- Se encuentran definidos en **/etc/inittab**
- Los scripts que se ejecutan est√°n en **/etc/init.d**
- En **/etc/rcX.d** (donde X = 0..6) hay links a los archivos del /etc/init.d
- Formato de los links:

```
    [SjK]<orden><nombreScript>
```

- `S)` lanza el script con el argument start
- `K)` lanza el script con el argument stop

---

#### ¬øTodas las distribuciones respetan estos est√°ndares?

No todas las distribuciones respetan los est√°ndares.

---

#### `(f)` Archivo /etc/inittab. ¬øCu√°l es su finalidad?  

Es el archivo de configuraci√≥n de init, que decide el modo de ejecuci√≥n en el que va a entrar.

Cuando el sistema se arranca, se verifica si existe un runlevel predeterminado en el archivo **/etc/inittab**, si no, se debe introducir por medio de la consola del sistema. Despu√©s se procede a ejecutar todos los scripts relativos al runlevel especificado. 

---

#### ¬øQu√© tipo de informaci√≥n se almacena en el? ¬øCu√°l es la estructura de la informaci√≥n que en √©l se almacena?

`/etc/inittab`

**`id:nivelesEjecucion:acci√≥n:proceso`**
- **Id**: identifica la entrada en inittab (1 a 4 caracteres)
- **Niveles_ejecucion**: el/los nivel de ejecuci√≥n en los que se realiza la acci√≥n
- **Acci√≥n**: describe la acci√≥n a realizar
    - **wait**: Se inicia cuando se entra al runlevel e init espera a que termine
    - **initdefault**
    - **ctrlaltdel**: se ejecutar√° cuando init reciba la se√±al SIGINT
    - **off, repawn, once, boot, bootwait, powerwait, otras‚Ä¶**
- **Proceso**: el proceso exacto que ser√° ejecutado

---

#### `(g)` Suponga que se encuentra en el runlevel \<X>. Indique qu√© comando(s) ejecutar√≠a para cambiar al runlevel \<Y>. ¬øEste cambio es permanente? ¬øPor qu√©?

Existen dos formas de modificar los runlevels:

- **a) Cambiar de runlevel en ejecuci√≥n:**
Existe una utilidad para l√≠nea de comandos que permite cambiar de un nivel de ejecuci√≥n a otro. Esta es la herramienta init. Para cambiar de nivel de ejecuci√≥n s√≥lo hay que ejecutar init seguido del n√∫mero del runlevel.\
Por ejemplo
- **` init 0`** Cambia al runlevel 0 (se apaga el sistema, equivalente al comando halt).
- **` init 2`** Cambia al runlevel 2.
- **` init 6`** Cambia al runlevel 6 (reinicia el sistema, equivalente al comando reboot). 

Tambi√©n **`telinit`**, nos permite cambiar de nivel de ejecuci√≥n, s√≥lo tenemos que indicar el n√∫mero. Por ejemplo, necesitamos hacer una tarea cr√≠tica en root; sin usuarios trabajando, podemos hacer un **`tellinit 1`** (tambi√©n puede usarse S) para pasar a runlevel monousuario, y despu√©s de la tarea un tellinit 3 para volver a multiusuario

---

#### **`b) Modificar el runlevel por defecto`**

Por defecto, el sistema suele arrancar en el nivel de ejecuci√≥n 5 (modo gr√°fico). Si se quisiera modificar este comportamiento, habr√≠a que editar el fichero **`/etc/inittab.`**

M√°s concretamente, habr√≠a que modificar en el fichero /etc/inittab la l√≠nea donde el n√∫mero 5 indica que el nivel de ejecuci√≥n por defecto es el 5

No es permanente. En el caso de que el runlevel se cambie durante la secci√≥n de bash abierta y luego se apague la m√°quina, cuando se vuelva a prender la maquina se volver√° a restablecer al modo que tenga el sistema configurado (por defecto).

En el caso de que se quiera cambiar el modo de arranque del runlevel de manera permanente se tendr√° que configurar para que eso suceda. 


```shell
ls /etc/rc0.d
sudo runlevel
sudo telinit 2
```

---

#### `(h)` Scripts RC. ¬øCu√°l es su finalidad?

Los scripts RC se encargan de cargar o cerrar los servicios necesarios para que el sistema funcione, de acuerdo con el runlevel que se est√° iniciando. Por ejemplo: lpd (servicio para imprimir), fetchmail (servicio para leer correo-e), sshd (SecureShell para abrir sesiones remotas de una manera segura), networking (abre las conexiones de red).


---

#### ¬øD√≥nde se almacenan? 

Todos estos servicios se encuentran en **/etc/init.d/**

Sin embargo, no todos los servicios se cargan en todos los runlevels. **¬øC√≥mo sabe el RC que servicios tiene que cargar?** Los servicios a cargar se encuentran en el directorio /etc/rcX.d/, donde X es el runlevel a cargar. En realidad, en estos directorios no hay m√°s que enlaces simb√≥licos a /etc/init.d/

---

#### Cuando un sistema GNU/Linux arranca o se detiene se ejecutan scripts, indique c√≥mo determina qu√© script ejecutar ante cada acci√≥n. ¬øExiste un orden para llamarlos? Justifique.

`Orden para llamarlos:`

Los nombres en estos directorios tienen una sintaxis bastante concreta. Empiezan por una letra (S o K) seguidos de un n√∫mero y el nombre del servicio. La letra S significa iniciar (S de start). La letra K significa acabar (K de kill). El n√∫mero es de dos d√≠gitos, de 00 a 99 e indica el orden en el que se arrancar√° el servicio.

- `1)` Ejecuta, por orden de nombre, todos los scripts que comienzan por **K** en el directorio correspondiente al nivel, utilizando como argumento para dicho script la opci√≥n **stop**.
- `2)` Ejecuta, por orden de nombre, todos los scripts que comienzan por S en el directorio correspondiente al nivel, utilizando como argumento para dicho script la opci√≥n start.

---

### `(i)` ¬øQu√© es insserv? 

El comando **insserv** se usa para controlar el orden de inicio y detenci√≥n de los servicios que se encuentran en un sistema Linux. 

#### ¬øPara qu√© se utiliza?

Se utiliza para administrar el orden de los enlaces simb√≥licos del **`/etc/rcX.d`**, resolviendo las dependencias de forma autom√°tica

- Utiliza cabeceras en los scripts del **`/etc/init.d`** que permiten especificar la relaci√≥n con otros scripts rc -> LSBInit (Linux Standard Based Init)
- Es utilizado por update-rc.d para instalar / remover los links simb√≥licos

#### ¬øQu√© ventajas provee respecto de un arranque tradicional?

Mejora la performance del arranque en sistemas multiprocesadores. 

---

#### `(j)` ¬øC√≥mo maneja Upstart el proceso de arranque del sistema?

Upstart fue el primer reemplazo propuesto para SystemV (Ubuntu, Fedora, Debian, etc.). 

- Permite la ejecuci√≥n de trabajos en forma asincr√≥nica a trav√©s de eventos (event-based) como principal diferencia con sysVinit que es estrictamente sincr√≥nico (dependencybased).
- Estos trabajos se denominan **Jobs**.
- El principal objetivo de un job es definir servicios o tareas a ser ejecutadas por init
- Son scripts de texto plano que definen las acciones/tareas (unidad de trabajo) a ejecutar ante determinados eventos.
- Cada job es definido en el **/etc/init (.conf).**
- Suelen ser de dos tipos:
    - **Task**: ejecuci√≥n finita (task) -> not respawning -> exit 0 o uso de stop.
    - **Service**: ejecuci√≥n indeterminada ÔÉ† respawning
- Los jobs son ejecutados ante eventos (arranque del equipo, inserci√≥n de un dispositivo USB,etc)
    - Es posible crear eventos pero existen algunos de manera est√°ndar.
    - Definido por **start on y stop on.**
- Es compatible con SystemV ! **/etc/init/rc-sysinit.conf**, runlevels, scripts en /etc/init.d, objetivo start y stop. 
- Cada job posee un objetivo (goal start/stop) y un estado (state). 
    - En base a ellos se ejecuta un proceso espec√≠fico.
    - Al inicio, init emite el evento startup. 
- Un job puede tener uno o varias tareas ejecutables como parte de su ciclo de vida y siempre debe existir la tarea principal
- Las tareas de un job se definen mediante exec o script ... end script
- A trav√©s de **initctl** podemos administrar los jobs del demonio de Upstart: 
- **`start <job>`**: cambia el objetivo a start del job especificado
- **`stop <job>`**: cambia el objetivo a stop del job especificado
- **`emit <event>`**: event es emitido causando que otros Jobs cambien a objetivo start o stop 
- No m√°s **/etc/inittab**



---

#### `(k)` Cite las principales diferencias entre SystemV y Upstart.

Upstart se cre√≥ como reemplazo del modelo SysVinit. A diferencia de SysVinit, que se cre√≥ para operar en un entorno est√°tico Upstart se cre√≥ para operar en un entorno flexible.

Upstart proporciona beneficios principales sobre el SysVinit. Estos beneficios son: event-based (principal diferencia con SysVinit que es estrictamente sincr√≥nico - dependecy-based -) es la ejecucion de servicios en forma asincr√≥nica y otro beneficio es el reinicio autom√°tico de servicios que dejan de responder de la manera inesperada para el sistema.

Upstart en lugar de usar runlevels, usa jobs que cada uno de ellos posee un objetivo (start/stop y un estado state). Cuando ocurre una interrupci√≥n, upstart detecta ese interrupci√≥n y realiza los cambios necesarios. 


---

#### `(l)` Qu√© reemplaza a los scripts rc de SystemV en Upstart? ¬øEn que ubicaci√≥n del filesystem se encuentran?

- Los **`jobs`** reemplazan a los scripts de SystemV en Upstart.
- Cada job es definido en el **`/etc/init (.conf)`**

---

#### `(m)` Dado el siguiente job de upstart perteneciente al servicio de base de datos del mysql indique a qu√© hace referencia cada l√≠nea del mismo:

```powershell
# MySQL Servise
description "MySQL Server " {Descripcion}
autor "info autor" {Autor}
start on ( net ‚àí device ‚àí up {Iniciar base de datos}
        and local ‚àífilesystems   {}
        and runlevel [2345])
stop on runlevel [016]
[...]
exec / usr / sbin /mysqld
[...]
```

Este es un archivo de configuraci√≥n Upstart para el servicio de base de datos MySQL. Cada l√≠nea se explica a continuaci√≥n:

- MySQL Service: un comentario que describe el servicio que se va a iniciar.
- description "MySQL Server": una descripci√≥n del servicio, que aparecer√° en los registros del sistema. {Descripcion}
- author "info autor": informaci√≥n sobre el autor del archivo de configuraci√≥n. {Autor}
- start on (net-device-up and local-filesystems and runlevel [2345]): indica que el servicio debe iniciarse cuando la red y el sistema de archivos locales est√©n disponibles y el sistema se est√© ejecutando en el nivel de ejecuci√≥n 2, 3, 4 o 5. {Iniciar base de datos}
- stop on runlevel [016]: indica que el servicio debe detenerse cuando el sistema se est√© ejecutando en el nivel de ejecuci√≥n 0, 1 o 6.
- exec `/usr/sbin/mysqld`: la l√≠nea que indica al sistema qu√© comando ejecutar para iniciar el servicio MySQL. El comando `/usr/sbin/mysqld` es el comando para iniciar el servidor de base de datos MySQL.

---

#### `(n)` ¬øQu√© es sytemd?

- Es un sistema que centraliza la administraci√≥n de demonios y librerias del sistema.
- Puede ser controlado por `systemctl`
- Compatible con SysV -> si es llamado como `init`
- El demonio systemd reemplaza al proceso init -> este pasa a terner PID 1
- Los runlevels son reemplazados por `targets`
- Al igual que con Upstart el archivo `/etc/inittab` no existe m√°s. 

---

#### `(√±)` ¬øA qu√© hace referencia el concepto de activaci√≥n de socket en systemd?

Las unidades de trabajo son denominadas units de tipo:

Service: controla un servicio particular (.service)

- **`Socket`** encapsula IPC, un sockect del sistema o file system FIFO (.socket) -> sockect-based activation.
- **`Target`** agrupa units o establece puntos de sincronizaci√≥n durante el booteo (.target)
- **`dependencia`** de unidades
- **`Snapshot`** almacena el estado de un conjunto de unidades que puede ser establecido m√°s tarde (.snapshot) etc. 

Las **units** pueden tener dos estados -> **active** o **inactive** 


 ---

#### `(o)` ¬øA qu√© hace referencia el concepto de cgroup?

Permite organizar un grupo de procesos en forma jer√°rquica

Agrupa conjunto de procesos relacionados (por ejemplo, un servidor web Apache con sus dependientes).

Tareas que realiza:

- Tracking mediante subsistema cgroups ÔÉ† no se utiliza el PID ÔÉ† doble fork no funciona para escapar de systemd.
- Limitar el uso de recursos. 

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## `3)` Usuarios

#### `(a)` ¬øQu√© archivos son utilizados en un sistema GNU/Linux para guardar la informaci√≥n de los usuarios?

En un sistema GNU/Linux, la informaci√≥n de los usuarios se almacena principalmente en los siguientes archivos:

- **`/etc/passwd`** Este archivo contiene informaci√≥n b√°sica de los usuarios, como sus nombres de usuario, identificaci√≥n de usuario (UID), identificaci√≥n de grupo (GID), nombre completo, ruta del directorio de inicio y shell predeterminada.
- **`/etc/shadow`** Este archivo contiene informaci√≥n confidencial de los usuarios, como sus contrase√±as encriptadas, tiempo de √∫ltima modificaci√≥n de la contrase√±a, tiempo de expiraci√≥n, cuenta bloqueada, etc.
- **`/etc/group`** Este archivo contiene informaci√≥n de los grupos de usuarios, como el nombre del grupo, identificaci√≥n de grupo (GID) y una lista de nombres de usuario que pertenecen a ese grupo.
- **`/etc/gshadow`** Este archivo contiene informaci√≥n confidencial de los grupos de usuarios, como sus contrase√±as encriptadas, tiempo de √∫ltima modificaci√≥n de la contrase√±a, tiempo de expiraci√≥n, cuenta bloqueada, etc.

Es importante destacar que estos archivos son de lectura y escritura solo para el superusuario (root) y que modificarlos sin conocimiento puede comprometer la seguridad del sistema.

---

#### `(b)` ¬øA qu√© hacen referencia las siglas UID y GID? ¬øPueden coexistir UIDs iguales en un sistema GNU/Linux? Justifique.

Los sistemas operativos Linux y Unix utilizan el UID (User ID o ID de usuario) para identificar al usuario particular. El GID (Group ID o ID de grupo) se utiliza para identificar a un grupo. Supongo que no podrian existir dos iguales ya que no los podrias distinguir.

Puede haber un caso que seria el root en el que podemos tener varios usuarios root con el ID 0

---

#### `(c)` ¬øQu√© es el usuario root? ¬øPuede existir m√°s de un usuario con este perfil en GNU/Linux? ¬øCu√°l es la UID del root?.

En sistemas operativos del tipo Unix, el superusuario o root es el nombre
convencional de la cuenta de usuario que posee todos los derechos en todos los
modos (monousuario o multiusuario). Normalmente es la cuenta de administrador. 

- Su UID (User ID) y GID es 0 (cero).
- Es la √∫nica cuenta de usuario con privilegios sobre todo el sistema.
- Acceso total a todos los archivos y directorios con independencia de propietarios y permisos.
- Controla la administraci√≥n de cuentas de usuarios.
- Ejecuta tareas de mantenimiento del sistema.
- Puede detener el sistema.
- Instala software en el sistema.
- Puede modificar o reconfigurar el kernel, controladores, etc. 


---

#### `(d)` Agregue un nuevo usuario llamado iso2017 a su instalaci√≥n de GNU/Linux, especifique que su home sea creada en /home/iso_2017, y h√°galo miembro del grupo catedra (si no existe, deber√° crearlo). Luego, sin iniciar sesi√≥n como este usuario cree un archivo en su home personal que le pertenezca. Luego de todo esto, borre el usuario y verifique que no queden registros de √©l en los archivos de informaci√≥n de los usuarios y grupos.

- `sudo adduser iso2022` creo un usuario y en home le agrego /home/ (contra = nombre para pruebas)
- `sudo gropadd catedra` creo un grupo 
- `sudo usermod -a -G catedra iso2022`
- `id -nG iso2022` menciona los grupos a los que pertenece mi usuario
- `sudo login iso2022` entro como el usuario
- `cd ..` para ir a la home personal y crear un archivo (creo)
- `sudo userdel iso2022` lo elimina pero aun tenemos todos los archivos creados por este

---

#### `(e)` Investigue la funcionalidad y par√°metros de los siguientes comandos:
- **`useradd nombre √≥ adduser nombre`** Crea un nuevo usuario
- **`usermod nombre`** nos permite modificar todos los par√°metros de la cuenta de un usuario creado con anterioridad.
- **`userdel nombre`** Elimina un usuario
- **`su`** entrar al super usuario (tenes los permisos de TODO)
- **`groupadd nombre`** te deja crear un grupo
- **`who`** Verifiqua los usuarios conectado al sistema
- **`groupdel nombre`** elimina un grupo
- **`passwd`** de deja cambiar la constrase√±a del usuario actual

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## `4)` FileSystem:

#### `(a)` ¬øC√≥mo son definidos los permisos sobre archivos en un sistema GNU/Linux?

Este mecanismo permite que archivos y directorios ‚Äúpertenezcan‚Äù a un usuario en particular. Por ejemplo, como diego cre√≥ archivos en su directorio ‚Äúhome‚Äù, diego es el propietario de esos archivos y tiene acceso total a ellos. 

Unix tambi√©n permite que los archivos sean compartidos entre usuarios y grupos de usuarios. Si diego lo desea, podr√≠a restringir el acceso a sus archivos de forma que ning√∫n otro usuario pueda acceder a ellos. 

Los **permisos est√°n divididos en tres tipos: `lectura`, `escritura` y `ejecuci√≥n`**. Estos permisos pueden ser fijados para tres clases de usuarios: el propietario del archivo o directorio, los integrantes del grupo al que pertenece y todos los dem√°s usuarios. 

- **`lectura`** permite a un usuario leer el contenido del archivo o en el caso de un directorio, listar el contenido del mismo (usando ls).
- **`escritura`** permite a un usuario escribir y modificar el archivo (inclusive, eliminarlo). Para directorios, el permiso de escritura permite crear nuevos archivos o borrar archivos ya existentes en el mismo.
- **`ejecuci√≥n`** permite a un usuario ejecutar el archivo si es un programa. Para directorios, el permiso de ejecuci√≥n permite al usuario ingresar al mismo (por ejemplo, con el comando cd). 
- **`Interpretando los permisos de archivos`** Veamos un ejemplo del uso de permisos de archivos. Usando el comando ls con la opci√≥n **`-l`** se mostrara un listado **`largo`** de los archivos, el cual incluye los permisos. <br><br>
    ```
    fabrizio@debian: /$ ls -l
    -rwxr-xr-- 1 fabrizio users 505 May 5 19:05 prueba.exe
    ```

El primer campo representa los permisos del archivo. El tercer campo es el propietario del mismo (fabrizio), el cuarto es el grupo al cual pertenece el archivo (users) y el √∫ltimo campo es el nombre del archivo (prueba.exe). 

La cadena **`-rwxr-xr--`** nos informa, por orden, los permisos para el propietario, los usuarios del grupo y el resto de los usuarios.

El primer car√°cter de la cadena de permisos `(‚Äú-‚Äù)` representa el tipo de archivo. El `‚Äú-‚Äù` significa que es un archivo regular, `‚Äúd‚Äù` indicar√≠a que se trata de un directorio. Los siguientes tres caracteres `(‚Äúrwx‚Äù)` representan los permisos para el propietario del archivo, fabrizio. √âste tiene permisos para leer `(r)`, escribir `(w)` y ejecutar `(x)` el archivo prueba.exe.

Los siguientes tres caracteres, `‚Äúr-x‚Äù`, representan los permisos para los miembros del grupo al que pertenece el archivo (en este caso, users). Como s√≥lo aparece `‚Äúr-x‚Äù` cualquier usuario que pertenezca al grupo users puede leer este archivo, y ejecutarlo, pero no modificarlo.

Los √∫ltimos tres caracteres, `‚Äúr--‚Äù`, representan los permisos para cualquier otro usuario del sistema (que no sea fabrizio ni pertenezca al grupo users). Como s√≥lo est√° presente la `‚Äúr‚Äù`, los dem√°s usuarios pueden leer el archivo, pero no escribir en √©l o ejecutarlo

Aqu√≠ tenemos otros ejemplos de permisos de grupo

- **`-rw-------`**
- El propietario del archivo puede leer y escribir. Nadie m√°s puede acceder al archivo.
- **`rwxrwxrwx`**
- Todos los usuarios pueden leer, escribir y ejecutar el archivo. 
- **`drwxr-xr-x`**
- El propietario del directorio puede leer, escribir y entrar al mismo. Los usuarios pertenecientes al grupo del directorio y todos los dem√°s usuarios pueden leer e ingresar al directorio.

---

#### `(b)` Investigue la funcionalidad y par√°metros de los siguientes comandos relacionados con los permisos en GNU/Linux:
- **chmod:** nos permite gestionar permisos
- **chown:** permite cambiar el propietario de un archivo o directorio en sistemas
- **chgrp:** nos permite cambiar el grupo al que pertenece un archivo

#### `(c)` Al utilizar el comando chmod generalmente se utiliza una notaci√≥n octal asociada para definir permisos. ¬øQu√© significa esto? ¬øA qu√© hace referencia cada valor?

Existen 3 tipos de permisos y se basan en una notacion octal para referenciar a cada uno:

| Permiso  | Valor | Octal |
| ------------- | ------------- | ------------- |
| Lectura  | R  | 4 |
| Escritura  | W  | 2 |
| Ejecucion  | X  | 1 |

Se aplican sobre los usuarios:

- Usuarios: permisos del due√±o -> `U`
- Usuarios: permisos del grupo -> `G`
- Usuarios: permisos de otro usuario -> `O`


La notaci√≥n octal se refiere a ver estos valores en 3 bits , 010 equivale a 2 , por lo tanto si un archivo tendr√° solo permisos de escritura, figura de esa manera. Si los valores fueran 110= serian permisos de lectura y escritura, y si fueran 111 el archivo tendr√≠a todos los permisos (lectura escritura y ejecuci√≥n). 

- En general cuando se le da un permiso a un archivo requiere 3 n√∫meros (ejemplo **`chmod 755`**) cada uno de esos n√∫meros representa los permisos para diferentes cosas.
- El primer n√∫mero es para indicar los permisos para el due√±o del archivo (**`U`**).
- El segundo n√∫mero es para indicar los permisos para los usuarios del grupo de un archivo (**`G`**)
- El tercer n√∫mero es para indicar los permisos para todo el resto de los usuarios (**`O`**). 

Por lo tanto, en el ejemplo **`chmod 755`**, indica que el **`due√±o (U)`** tiene permiso para lectura, escritura y ejecuci√≥n ( 4 + 2 + 1 = 7). Los **`usuarios del grupo (G)`** y para el **`resto de los usuarios (O)`** tienen permiso para lectura y ejecuci√≥n (4 + 1= 5). Ver tabla.

---

#### `(d)` ¬øExiste la posibilidad de que alg√∫n usuario del sistema pueda acceder a determinado archivo para el cual no posee permisos? Nombrelo, y realice las pruebas correspondientes.


Existe la posibilidad, si es que el usuario puede utilizar el comando su, o sudo. Sino, sin poseer los permisos necesarios no puede acceder al archivo. S√≥lo root.

---

#### `(e)` Explique los conceptos de ‚Äúfull path name‚Äù y ‚Äúrelative path name‚Äù. De ejemplos claros de cada uno de ellos.

- **`Full path name`** es la ruta completa a ese archivo o carpeta desde el directorio / del sistema de archivos. ejemplo `/home/your_username/my_script`
- **`Relative path name`** Rastrea la ruta desde el directorio actual a trav√©s de su padre o sus subdirectorios y archivos. ..\Documents

---

#### `(f)` ¬øCon qu√© comando puede determinar en qu√© directorio se encuentra actualmente? ¬øExiste alguna forma de ingresar a su directorio personal sin necesidad de escribir todo el path completo? ¬øPodr√≠a utilizar la misma idea para acceder a otros directorios? ¬øC√≥mo? Explique con un ejemplo.

- Con el comando pwd podemos saber el directorio actual.
- Con `cd`o `cd ~` vamos al directorio personal.
- Se puede usar este mismo comando para acceder a directorios a partir de la ruta en donde estemos parados

Se podr√≠a acceder a diferentes directorios gracias la ubicaci√≥n relativa o atajos ya prestablecidos como `cd ..` para volver al directorio anterior sin necesidad de poner ning√∫n atajo

---

#### `(g)` Investigue la funcionalidad y par√°metros de los siguientes comandos relacionados con el uso del FileSystem:

- **`cd`** Nos permite meternos en un directorio interno
- **`umount`** permite eliminar un sistema de archivos remoto que est√© montando en la actualidad (no usar xd)
- **`mkdir`** Cree una carpeta
- **`du`** Para ver el tama√±o de ficheros y carpetas
- **`rmdir`** Borrar directorios
- **`df`** Informa la cantidad de espacio libre en disco
- **`mount`** Se utiliza para montar dispositivos y particiones para su uso por el sistema operativo (se instala con **sudo apt install nfs-common**)
- **`ln`** crear un enlace simb√≥lico al fichero o directorio (como un acceso directo)
- **`ls`** Lista el contenido del directorio actual
- **`pwd`** Visualiza la ruta donde estoy situado
- **`cp`** sirve para copiar archivos y directorios dentro del sistema de archivos
- **`mv`** se utiliza para mover o renombrar los archivos y directorios

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## `5)` Procesos

#### `(a)` ¬øQu√© es un proceso? ¬øA que hacen referencia las siglas PID y PPID? ¬øTodos los procesos tienen estos atributos en GNU/Linux? Justifique. Indique qu√© otros atributos tiene un proceso.

Un proceso es un programa en ejecuci√≥n. Para nosotros ser√°n sin√≥nimos de tarea, job y proceso.
- Es din√°mico
- Tiene program counter.
- Su ciclo de vida comprende desde que se lo **`dispara`** hasta que termina.

La sigla `PID` hace referencia al `ID` del Proceso y la sigla `PPID` hace referencia al `ID` del Proceso Padre del proceso.

Todos los procesos tienen estos atributos, adem√°s de estos (que son los m√°s importantes pero no todos): Usuario (`UID`), Grupo (`GID`), Prioridad, etc. Con ps ‚ÄìejH

PUEDO VER EL PPID.

----

#### `(b)` Indique qu√© comandos se podr√≠an utilizar para ver qu√© procesos est√°n en ejecuci√≥n en un sistema GNU/Linux.

- **`pstree`** que nos muestra los procesos en una estructura de √°rbol top El comando top te permite ver las tareas del sistema que se ejecutan en tiempo real.
- **`top`** El comando top te permite ver las tareas del sistema que se ejecutan en tiempo real.Proporciona un buen resumen de tu sistema para verificar r√°pidamente si algo se destaca que pueda estar causando problemas con tu sitio web o servidor
- **`ps`** muestra por pantalla un listado de los procesos que est√°n ejecut√°ndose en el sistema.

Las opciones (par√°metros) m√°s importantes y utilizadas de este comando son:
- **`a`** para mostrar los procesos de todos los teminales.
- **`u`** para mostrar el usuario al que pertenece el proceso y la hora de inicio.
- **`x`** para mostrar procesos que no estan controlados por ning√∫n terminal.

Suelen usarse combiandas para tener una visi√≥n global de los procesos que est√°n en ejecutan.

---

#### `(c)` ¬øQu√© significa que un proceso se est√° ejecutando en Background? ¬øY en Foreground?

- **`Proceso ejecut√°ndose en Background`** significa que el proceso contin√∫a la ejecuci√≥n mientras que el shell se libera para otras actividades. **`Proceso en segundo plano`**.
- **`Proceso ejecut√°ndose en Foreground`** Es exactamente lo contrario, quiere decir que no se admitir√° ning√∫n otro comando hasta que se complete el proceso. **`Proceso en primer plano`**.

---

#### `(d)` ¬øC√≥mo puedo hacer para ejecutar un proceso en Background? ¬øComo puedo hacer para pasar un proceso de background a foreground y viceversa?

Para ejecutar un proceso en background en Linux, se puede agregar el s√≠mbolo "&" al final del comando en la l√≠nea de comandos. Por ejemplo, para ejecutar un proceso llamado "mi_proceso" en background, se puede escribir:

```bash
mi_proceso &
```

Esto permitir√° que el proceso se ejecute en segundo plano mientras se sigue usando la terminal para ejecutar otros comandos.

Para pasar un proceso de background a foreground y viceversa, se pueden usar los siguientes comandos:

- **`fg`** mueve un proceso en background a foreground. Se debe proporcionar el n√∫mero de trabajo (job number) del proceso como argumento. El n√∫mero de trabajo se puede obtener con el comando "jobs". Por ejemplo: <br><br>
    ```bash
    fg %1
    ```
    Esto mueve el proceso n√∫mero 1 en background al foreground.
- **`bg`** mueve un proceso en foreground a background. Tambi√©n se debe proporcionar el n√∫mero de trabajo del proceso como argumento. Por ejemplo:
    ```bash
    bg %1
    ```
    Esto mueve el proceso n√∫mero 1 en foreground a background.

Tambi√©n se puede suspender un proceso en foreground con la combinaci√≥n de teclas `Ctrl + Z`. Esto detendr√° el proceso y lo mover√° a background. Para reanudar el proceso en background, se puede usar el comando `bg`

---

#### `(e)` Pipe ( | ). ¬øCu√°l es su finalidad? Cite ejemplos de su utilizaci√≥n.

 El **`|`** nos permite comunicar dos procesos por medio de un pipe o tuber√≠a desde la shell

El pipe conecta stdout (salida est√°ndar) del primer comando con la stdin (entrada est√°ndar) del segundo.

Por ejemplo:

```
ls | more
```

- Se ejecuta el comando ls y la salida del mismo, es enviada como entrada del comanda **`more`**. 
- Se pueden anidar tantos pipes como se deseen

¬øC√≥mo har√≠amos si quisi√©ramos contar la cantidad de usuarios del sistema que en su
nombre de usuario aparece una letra ‚Äúa"?

```shell
cat /etc/passwd | cut -d: -f1 | grep a | wc ‚Äìl
```

---

#### `(f)` Redirecci√≥n. ¬øQu√© tipo de redirecciones existen? ¬øCu√°l es su finalidad? Cite ejemplos de utilizaci√≥n.

En Linux, al final todo es tratado como si fuera un fichero y como tal, tenemos descriptores de fichero para aquellos puntos donde queramos acceder.

Hay unos descriptores de fichero por defecto:
- **`0`** Entrada est√°ndar (normalmente el teclado).
- **`1`** Salida est√°ndar (normalmente la consola).
- **`2`** Salida de error. 

Para redirigir las salidas utilizaremos el descriptor de fichero seguido del s√≠mbolo > o < si redirigimos la entrada hacia un comando. Veamos unos ejemplos

- **`ls -l > fichero`** Guarda la salida de ls -l en fichero. Si no existe lo crea, y si existe lo sobreescribe.
- **`ls -l >> fichero`** A√±ade la salida del comando a fichero. Si no existe lo crea, y si existe, lo a√±ade al final.
- **`ls -l 2 > fichero`** Si hay alg√∫n error, lo guarda en fichero (podr√≠a salir un error si no tuvi√©ramos permiso de lectura en el directorio). 


Las¬†**redirecciones** consisten en trasladar informaci√≥n de un tipo a otro

Hay 2 tipos de redirecciones 

- Al utilizar redirecciones mediante > (destructiva):
    - Si el archivo de destino no existe, se lo crea
    - Si el archivo existe, se lo trunca y se escribe el nuevo contenido
- Al utilizar redirecciones mediante >> (no destructiva):
    - Si el archivo de destino no existe, se lo crea
    - Si el archivo existe, se agrega la informaci√≥n al final

EJEMPLOS

>  Redirecciona **stdout** hac√≠a un archivo. Lo crea si no existe, si existe lo sobreescribe.
```
ls -l > lista.txt
```

>> (La salida del comando se env√≠a a un archivo en vez de la terminal.)

Redirecciona **stdout** hac√≠a un archivo. Lo crea si no existe, si existe concatena la salida al final de este.

```
ps -ef >> processos.txt
```
(Concatena al archivo procesos.txt la salida del comando.)

Es importante ver que si no se especifica el descriptor de fichero se asume que se redirige la salida est√°ndar. En el caso del operador `<` se redirige la entrada est√°ndar, es decir, el contenido del fichero que especific√°ramos, se pasar√≠a como par√°metro al comando.

Si quisi√©ramos redirigir todas las salidas a la vez hacia un mismo fichero, podr√≠amos utilizar **`>&`**.

Adem√°s, con el car√°cter `&` podemos redirigir salidas de un tipo hacia otras, por ejemplo, si quisi√©ramos redirigir la salida de error hacia la salida est√°ndar podr√≠amos indicarlo con: **`2>&1`**. Es importante tener en cuenta que el orden de las redirecciones es significativo: se ejecutar√°n de izquierda a derecha.

---

#### `(g)` Comando kill. ¬øCu√°l es su funcionalidad? Cite ejemplos.

El comando **`kill`** en Linux (ubicado en / bin / kill), es un comando incorporado que se usa para terminar los procesos manualmente. El comando kill env√≠a una se√±al a un proceso que termina el proceso. Si el usuario no especifica ninguna se√±al que se enviar√° junto con el comando kill, se env√≠a la se√±al TERM predeterminada que finaliza el proceso.

- **`kill -l`** Para mostrar todas las se√±ales disponibles, puede usar la siguiente opci√≥n de comando.
- **`kill pid`** Para mostrar c√≥mo usar un PID con el comando kill.
- **`kill -s`** Para mostrar c√≥mo enviar se√±ales a los procesos.
- **`kill -L`** este comando se usa para listar las se√±ales disponibles en un formato de tabla. 

---

#### `(h)` Investigue la funcionalidad y par√°metros de los siguientes comandos relacionados con el manejo de procesos en GNU/Linux. Adem√°s, comp√°relos entre ellos:

- **ps:** Muestra informaci√≥n de los procesos activos.
- **kill:** Usa el PID para matar el proceso. Permite interactuar con cualquier proceso mandando se√±ales. Kill `<pid>` termina un proceso y Kill -9 `<pid>` fuerza a terminar un proceso en caso de que la anterior opci√≥n falle. 
- **pstree:** muestra un √°rbol de procesos.
- **killall:** nos permite matar un proceso escribiendo su nombre
- **top:** Sirve para ver los procesos de ejecuci√≥n del sistema (y m√°s cosas) en tiempo real
- **nice:** Ejecuta un comando con una prioridad determinada, o modifica la prioridad a de un proceso. `nice -10 named` Esto bajar√≠a la prioridad de named en 10 unidades(Si estaba en -10, pasar√° a - 20) `MENOS GENTIL = MAS PRIORIDAD`

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## `6)` Otros comandos de Linux (Indique funcionalidad y par√°metros)

#### `(a)` ¬øA qu√© hace referencia el concepto de empaquetar archivos en GNU/Linux?

Los archivos `TAR` no son archivos comprimidos sino empaquetados. `TAR` es un empaquetador, es algo m√°s parecido a un compresor como `arj` √≥ `zip` pero sin compresi√≥n. Su funci√≥n es la de incluir todos los ficheros juntos en el mismo archivo, conservando las estructuras de directorios y permisos de los mismos. 

- **``crear``** un archivo .tar <br><br> 
    ```shell
    tar ‚Äìcvf mi_archivo.tar /directorio/a/empaquetar 
    ```
- **``extraer``** el contenido de un archivo .tar ya creado <br><br> 
    ```shell
    tar ‚Äìxvf mi_archivo.tar
    ```
- **`actualizar`** el contenido de un archivo .tar ya existente <br><br> 
    ```shell
    tar ‚Äìuvf mi_archivo.tar
    ```
- **`agregar`** un directorio a un archivo .tar ya existente <br> <br> 
    ```shell
    tar ‚Äìrvf archivo. tar  directorio/a/agregar
    ```
- **`empaquetar`** y comprimir el archivo .tar <br><br> 
    ```shell
    tar ‚Äìcvzf archivo.tgz /directorio/a/empaquetar/y/comprimir
    ```
- **`desempaquetar`** el archivo .tgz <br><br>
    ```shell
    tar ‚Äìxvzf archivo.tgz
    ```
- Ojo : Observa la extensi√≥n ".tgz" para el tar comprimido. Aunque tambi√©n podemos ponerle como extensi√≥n ".tar.gz"

---

#### `(b)` Seleccione 4 archivos dentro de alg√∫n directorio al que tenga permiso y sume el tama√±o de cada uno de estos archivos. Cree un archivo empaquetado conteniendo estos 4 archivos y compare los tama√±os de los mismos. ¬øQu√© caracter√≠stica nota?

Claro, para sumar el tama√±o de cuatro archivos en Linux y crear un archivo empaquetado que los contenga, puede seguir los siguientes pasos:

- Abrir una terminal y navegar hasta el directorio que contiene los cuatro archivos usando el comando `cd`.
- Para sumar el tama√±o de los cuatro archivos, use el comando <br> <br>
    ```shell
    du -sh file1 file2 file3 file4
    ```
    Esto le dar√° la suma total de los tama√±os de los cuatro archivos.
- Para crear un archivo empaquetado que contenga los cuatro archivos, puede utilizar el comando 
    ```shell
    tar -cvzf archivo_empaquetado.tar.gz file1 file2 file3 file4
    ```
    Esto crear√° un archivo empaquetado llamado `archivo_empaquetado.tar.gz` que contiene los cuatro archivos.
- Para comparar los tama√±os de los cuatro archivos individuales y el archivo empaquetado, use el comando `ls -lh`. Esto mostrar√° el tama√±o de cada archivo en una lista. Compare el tama√±o total de los cuatro archivos individuales con el tama√±o del archivo empaquetado para notar la diferencia en el tama√±o.


Es importante tener en cuenta que el comando `tar` utiliza la compresi√≥n para reducir el tama√±o del archivo empaquetado, por lo que es posible que el tama√±o del archivo empaquetado sea menor que la suma total de los tama√±os de los cuatro archivos individuales.

---

#### `(c)` ¬øQu√© acciones debe llevar a cabo para comprimir 4 archivos en uno solo? Indique la secuencia de comandos ejecutados.

Teniendo en cuenta que tenemos 4 archivos en el directorio Descargas/ejercicio6 y nos situamos en Descargas ejecutamos lo siguiente

```shell
tar cvfz archivo.tar.gz ejercicio6
```
Esto nos dejaria un archivo empaquetado de archivos comprimidos en un solo archivo archivo.tar.gz y para acceder a dicha informacion haremos

```powershell
tar xvfz archivo.tar.gz
```

---

#### `(d)` ¬øPueden comprimirse un conjunto de archivos utilizando un √∫nico comando?

Si los archivos est√°n en el mismo directorio utilizamos el comando visto anteriormente


----

#### `(e)` Investigue la funcionalidad de los siguientes comandos:

- **`tar`** Empaqueta/desempaqueta varios archivos en uno solo, puede realizar compresi√≥n sin perdida
- **`grep`** El comando grep nos permite buscar cadenas de texto y palabras dentro de un fichero de texto o de la entrada est√°ndar de la terminal. Una vez encontrado el contenido que estamos buscando: 
    grep mostrar√° en pantalla la totalidad de la l√≠nea/s que contiene/n la cadena de texto o palabra que estamos buscando
- **`gzip`** Comprime solo archivos utilizando la extensi√≥n .gz que se utiliza para truncar el tama√±o de un archivo.
- **`zgrep`** Se usa para buscar expresiones de un archivo dado, incluso si est√° comprimido
- **`wc`** Cuenta los caracteres, palabras y l√≠neas del archivo de texto.

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## `7)` Ejercicio

Enunciado: Indique qu√© acci√≥n realiza cada uno de los comandos indicados a continuaci√≥n considerando su orden. Suponga que se ejecutan desde un usuario que no es root ni pertenece al grupo de root. (Asuma que se encuentra posicionado en el directorio de trabajo del usuario con el que se logue√≥). En caso de no poder ejecutarse el comando, indique la raz√≥n

```shell
l s ‚àíl > prueba {No se puede acceder a pruebas pq no existe el fichero}                         
ps > PRUEBA 
chmod 710 prueba
chown root : root PRUEBA
chmod 777 PRUEBA 
chmod 700 / etc / passwd 
passwd root 
rm PRUEBA 
man / etc / shadow 
find / ‚àíname ‚àó .conf 
usermod root ‚àíd /home/ newroot ‚àíL 
cd / root 
rm ‚àó 
cd / etc 
cp ‚àó /home ‚àíR 
shutdown 
```

- `ls -l > prueba` Genera un archivo de nombre prueba que contiene un listado detallado con los contenidos del directorio home del usuario. Se redirige la salida est√°ndar de ls mediante el car√°cter > hacia el archivo prueba.
- `ps > PRUEBA` Genera un archivo de nombre PRUEBA que contiene un listado de los procesos en ejecuci√≥n en el directorio home del usuario. AL igual que en el ejemplo anterior, se redirige la salida est√°ndar mediante >.
- `chmod 710 prueba` Cambia los permisos del archivo prueba a 710 para UGO (usuario, Grupo, Otros).
- `chown root:root PRUEBA` Se intenta cambiar el propietario del archivo prueba pero la operaci√≥n no est√° permitida.
- `chmod 777 PRUEBA` Cambia los permisos del archivo PRUEBA a 777. Es decir, todos los usuarios pueden leer, escribir y ejecutar el archivo.
- `chmod 700 /etc/passwd` Intenta cambiar los permisos a 700, pero la operaci√≥n no est√° permitida para un usuario que no es root, esto por el archivo que est√° intentando cambiar.
- `passwd root` passwd: No debe ver o cambiar la informaci√≥n de la contrase√±a para root.
- `rm PRUEBA` Se elimina el archivo PRUEBA.
- `man /etc/shadow` Permiso denegad, porque ‚Äúman‚Äù no debe recibir una ruta, si hago ‚Äúman shadow‚Äù si anda.
- `find / -name *.conf` Lista todos los archivos cuyo nombres terminan con .conf, empezando la b√∫squeda en el directorio ra√≠z /.
- `usermod root ‚Äìd /home/newroot ‚ÄìL`
- `cd /root` Se intenta acceder a la carpeta root, pero la operaci√≥n falla porque el usuario no tiene los permisos.
- `rm *` Borra todos los archivos del directorio donde est√° posicionado el usuario.
- `cd /etc` Cambia el directorio a /etc, osea ‚Äúse mueve‚Äù a /etc
- `cp * /home ‚ÄìR` Intenta copiar el contenido de /etc a home, pero el usuario no tiene los permisos necesarios para crear archivos en el directorio /home.
- `shutdown` Apaga el equipo

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## `8)` Indique qu√© comando ser√≠a necesario ejecutar para realizar cada una de las siguientes acciones:

#### `(a)` Terminar el proceso con PID 23.

- Todos los procesos tienen un pid (id de proceso) para terminar un proceso se usa el comando:
    ```
    kill -9 23 (kill menos 9 n√∫mero de id del proceso).
    ```
- `ps ‚Äìaux` Para ver los procesos del sistema que corren en el momento comando:

---

#### `(b)` Terminar el proceso llamado init. ¬øQu√© resultados obtuvo?

- `1)` Primero buscamos el PID de init con el comando `ps ‚Äìaux`
- `2)` Ingresamos como superusuario: su ‚Äì e ingresamos contrase√±a
- `3)` Utilizamos el comando kill ‚Äì9 1
- `4)` Y vamos a ver que no va a suceder nada, porque el proceso init, no puede terminarse, as√≠ que ni responde al comando. 


---

#### `(c)` Buscar todos los archivos de usuarios en los que su nombre contiene la cadena ‚Äú.conf‚Äù

Para buscar un `archivo` se utiliza el comando:
```
 find / -type f -name NombreDelArchivoABuscar
```
B√∫squeda por tipo

Linux permite a los usuarios listar toda la informaci√≥n basada en sus tipos. Hay varios filtros que puedes usar:
- **`d`** directorio o carpeta
- **`f`** archivo normal
- **`l`** enlace simb√≥lico
- **`c`** dispositivos de caracteres
- **`b`** dispositivos de bloque

Si deseamos buscar la palabra ‚Äúconf‚Äù en todo el sistema se utiliza el comando:
```
find / -name NombreABuscar 
```

---

#### `(d)` Guardar una lista de procesos en ejecuci√≥n el archivo /home/\<su nombre de usuario>/procesos

```
ps > /home/user/procesos
```

- `cat Procesos` Para poder comprobar el contenido que tiene el directorio Procesos
- `rm ‚Äìr Procesos` Para eliminar dicho directorio

---

#### `(e)` Cambiar los permisos del archivo /home/\<su nombre de usuario>/xxxx a:

- **Usuario:** Lectura, escritura, ejecuci√≥n
- **Grupo:** Lectura, ejecuci√≥n
- **Otros:** ejecuci√≥n

- `mkdir xxxx` Primero creamos el directorio ‚Äúxxxx‚Äù 
- `ls ‚Äìl` Para ver los permisos que tiene dicho directorio
- `chmod 751 xxxx` Para cambiar sus permisos donde Usuario tenga los permisos de lectura, escritura, ejecuci√≥n, Grupo los permisos de lectura y ejecuci√≥n y Otros el permiso
- `7` = 4(Lectura) + 2(Escritura) + 1(Ejecuci√≥n) --> `Usuario`
- `5` = 4(Lectura) + 1(Ejecuci√≥n) --> `Grupo`
- `1` = 1(Ejecuci√≥n) --> `Otros`
- `ls -l` Para chequear si los permisos fueron modificados

Para lograr visualizar los permisos se lee de la siguiente forma: 

![image](https://user-images.githubusercontent.com/55964635/227809799-8f8fb1d2-8ea0-4a2e-8a26-33bc6d1f83f0.png)
- No ver la primera d!
- Los primeros `rwx`(Lectura, Escritura, Ejecuci√≥n) pertenecen a Usuario
- Luego rx (LecturaEjecuci√≥n) pertenece a Grupo
- Y x (Ejecuci√≥n) pertenece a Otros

---

#### `(f)` Cambiar los permisos del archivo /home/<su nombre de usuario>/yyyy a:
- **Usuario:** Lectura, escritura.
- **Grupo:** Lectura, ejecuci√≥n
- **Otros:** Ninguno

- `mkdir yyyy` Primero creamos el directorio `‚Äúyyyy‚Äù`
- `ls ‚Äìl` Para ver los permisos que tiene dicho directorio 
- `chmod 650 yyyy` Para cambiar sus permisos donde Usuario tenga los permisos de lectura, escritura, ejecuci√≥n, Grupo los permisos de lectura y ejecuci√≥n y Otros el permiso de ejecuci√≥n.

---

#### `(g)` Borrar todos los archivos del directorio /tmp

```shell
cd /tmp
rm *
```

---

#### `(h)` Cambiar el propietario del archivo /opt/isodata al usuario iso2010

```shell
chown iso2010 /opt/isodata
```

#### `(i)` Guardar en el archivo /home/\<su nombre de usuario>/donde el directorio donde me encuentro en este momento, en caso de que el archivo exista no se debe eliminar su contenido anterior.

```
pwd >> /home/user/donde
```

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## `9)` Indique qu√© comando ser√≠a necesario ejecutar para realizar cada una de las siguientes acciones

#### `(a)` Ingrese al sistema como usuario ‚Äúroot‚Äù

```shell
su
```

---

#### `(b)` Cree un usuario. Elija como nombre, por convenci√≥n, la primer letra de su nombre seguida de su apellido. As√≠gnele una contrase√±a de acceso.

```powershell
sudo adduser il {crear}
passwd il {nueva contra}
```

---

#### `(c)` ¬øQu√© archivos fueron modificados luego de crear el usuario y qu√© directorios se crearon?

se modificaron los archivos `/etc/passwd` y se creo el directorio personal del perfil en /home/nombrelegido

---

#### `(d)` Crear un directorio en `/tmp` llamado cursada2017

```shell
cd /tmp
mkdir cursada2017
```

---

#### `(e)` Copiar todos los archivos de `/var/log` al directorio antes creado.

En modo superusuario/root

```shell
cp /var/log/* /tmp/cursada2017
```

---

#### `(f)` Para el directorio antes creado (y los archivos y subdirectorios contenidos en √©l) cambiar el propietario y grupo al usuario creado y grupo users.

```shell
chown nombreUsuario:nombreUsuario /tmp/cursada2017
```

---

#### `(g)` Agregue permiso total al due√±o, de escritura al grupo y escritura y ejecuci√≥n a todos los dem√°s usuarios para todos los archivos dentro de un directorio en forma recursiva.

```shell
chmod -R 745 /tmp/cursada2017
```

---

#### `(h)` Acceda a otra terminal virtual para loguearse con el usuario antes creado.

```
sudo login user
```

---

#### `(i)` Una vez logueado con el usuario antes creado, averig√ºe cu√°l es el nombre de su terminal.

```shell
ps -p 544
```

---

#### `(j)` Verifique la cantidad de procesos activos que hay en el sistema.

```shell
ps aux | wc -l
```

---

#### `(k)` Verifiqu√© la cantidad de usuarios conectados al sistema.

```shell
who
```

---

#### `(l)` Vuelva a la terminal del usuario root, y env√≠ele un mensaje al usuario anteriormente creado, avis√°ndole que el sistema va a ser apagado.

```shell
sudo shutdown 1 'El sistema se va a apagar'
tmb sin apagar
wall "En un minuto apagaremos el sistema."
```

---

#### `(m)` Apague el sistema

```shell
sudo shutdown now
```

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## `10)` Indique qu√© comando ser√≠a necesario ejecutar para realizar cada una de las siguientes acciones

#### `(a)` Cree un directorio cuyo nombre sea su n√∫mero de legajo e ingrese a √©l.

```shell
mkdir 19508/3 {No se puede dado q confunde / con un desplazamiento de directorio}
```

---

#### `(b)` Cree un archivo utilizando el editor de textos vi, e introduzca su informaci√≥n personal:

Nombre, Apellido, N√∫mero de alumno y direcci√≥n de correo electr√≥nico. El archivo debe llamarse "LEAME".

```
cd legajo
vi LEAME
```

---

#### `(c)` Cambie los permisos del archivo LEAME, de manera que se puedan ver reflejados los siguientes permisos:

- **Due√±o:** ning√∫n permiso
- **Grupo:** permiso de ejecuci√≥n
- **Otros:** todos los permisos

```shell
chmod 017 LEAME
```

---

#### `(d)` Vaya al directorio /etc y verifique su contenido. Cree un archivo dentro de su directorio personal cuyo nombre sea leame donde el contenido del mismo sea el listado de todos los archivos y directorios contenidos en /etc. ¬øCu√°l es la raz√≥n por la cu√°l puede crear este archivo si ya existe un archivo llamado "LEAME.en este directorio?.

Se puede porque unix es case sensitive y distingue entre may√∫sculas y min√∫sculas.

---

#### `(e)` ¬øQu√© comando utilizar√≠a y de qu√© manera si tuviera que localizar un archivo dentro del filesystem? ¬øY si tuviera que localizar varios archivos con caracter√≠sticas similares? Explique el concepto te√≥rico y ejemplifique.

```shell
find / -name "[0-9]*"
```

---

#### `(f)` Utilizando los conceptos aprendidos en el punto e), busque todos los archivos cuya extensi√≥n sea .so y almacene el resultado de esta b√∫squeda en un archivo dentro del directorio creado en a). El archivo deber√° llamarse .ejercicio_f".

```shell
find / -name "*.os" > /home/user/legajo/ejerciciof
```

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## `11)` Ejercicio

Indique qu√© acci√≥n realiza cada uno de los comandos indicados a continuaci√≥n considerando su orden. Suponga que se ejecutan desde un usuario que no es root ni pertenece al grupo de root. (Asuma que se encuentra posicionado en el directorio de trabajo del usuario con el que se logue√≥). En caso de no poder ejecutarse el comando indique la raz√≥n:


- `mkdir iso` Crea el directorio iso
- `cd . / iso; ps > f0` Me situo en iso y creo el archivo f0 con los procesos en ejecucion
- `ls > f1` Guardo en F1 la lista de archivos en el directorio iso
- `cd /` Me posiciono en la raiz 
- `echo $HOME` muestra en pantalla la direccion del directorio personal del usuario
- `ls ‚àíl $> $HOME/iso/ls` No se puede acceder a $ no existe el fichero o directorio
- `cd $HOME; mkdir f2` Nos situamos en el directorio personal y creamos el directorio f2
- `ls ‚àíld f2` Se da un listado detallado de f2
- `chmod 341 f2` Se modifican los permisos de f2;Es,Ej para usuario,L para Grupo, y Ej para otros
- `touch dir` se crea el archivo dir
- `cd f2` accedemos al directoriio f2
- `cd ~/ iso` accedemos a la carpeta iso
- `pwd > f3` se guarda en el archivo f3 la direccion de la carpeta iso
- `ps | grep ' ps ' | wc ‚àíl >> ../f2/f3` se obtienen los procesos, se usa de entrada para grep el cual filtra todos los que posean ps,pra luego almacenar la cantidad de lineas obtenidas luegro de dicho filtro y a√±adirlas al archivo f3
- `chmod 700 .. / f2 ; cd ..` Se modifica el acceso de f2 dando al usuario todos los permisos y a los demas nada, volviendo despues al directorio personal
- `find . ‚àíname etc / passwd` Lanza un warning por mal uso del comando
- `find / ‚àíname etc / passwd` filtra todos los archivos de passwd por nombre en orden
- `mkdir ejercicio5` crea el directorio ejercicio5


#### `(a)` Inicie 2 sesiones utilizando su nombre de usuario y contrase√±a. En una sesi√≥n vaya siguiendo paso a paso las √≥rdenes que se encuentran escritas en el cuadro superior. En la otra sesi√≥n, cree utilizando alg√∫n editor de textos un archivo que se llame. ejercicio10_explicacion"dentro del directorio creado en el ejercicio 9.a) y, para cada una de las √≥rdenes que ejecute en la otra sesi√≥n, realice una breve explicaci√≥n de los resultados obtenidos. (ARRIBA)

---

#### `(b)` Complete en el cuadro superior los comandos 19 y 20, de manera tal que realicen la siguiente acci√≥n:
- `19:` Copiar el directorio iso y todo su contenido al directorio creado en el inciso 9.a).
- `20:` Copiar el resto de los archivos y directorios que se crearon en este ejercicio al directorio creado en el ejercicio 9.a).

#### `(c)` Ejecute las √≥rdenes 19 y 20 y comentelas en el archivo creado en el inciso a).

![image](https://user-images.githubusercontent.com/55964635/189272687-459c381d-b44c-4a8d-b3d0-aa3acc44e1ae.png)

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## `12)` Ejercicio

**Enunciado:** Cree una estructura desde el directorio /home que incluya varios directorios, subdirectorios y archivos, seg√∫n el esquema siguiente. Asuma que ‚Äúusuario‚Äù indica cu√°l es su nombre de usuario. Adem√°s deber√° tener en cuenta que dirX hace referencia a directorios y fX hace
referencia a archivos:

#### `(a)` Utilizando la estructura de directorios anteriormente creada, indique que comandos son necesarios para realizar las siguientes acciones:

#### Mueva el archivo "f3.al directorio de trabajo /home/usuario.

```shell
mv f3 $HOME
```

---

#### Copie el archivo "f4.en el directorio "dir11".

```shell
cp f4 $HOME/dir11
```

---

#### Haga los mismo que en el inciso anterior pero el archivo de destino, se debe llamar "f7".

```shell
cp f4 $HOME/dir11/f7
```

---

#### Cree el directorio copia dentro del directorio usuario y copie en √©l, el contenido de "dir1".

```shell
mkdir copia; cp -a dir11 copia
```

---

#### Renombre el archivo "f1"por el nombre archivo y vea los permisos del mismo.

```shell
cd iso;mv f0 archivo; ls  -ld archivo
```

---

#### Cambie los permisos del archivo llamado archivo de manera de reflejar lo siguiente:

- **``Usuario``** Permisos de lectura y escritura
- **``Grupo``** Permisos de ejecuci√≥n
- **``Otros``** Todos los permisos

```shell
chmod 617 archivo
```

---

#### Renombre los archivos "f3 2 "f4"de manera que se llamen "f3.exe 2 "f4.exerespectivamente.

```shell
mv f3 f3.exe; cd $HOME/dir11 ; mov f4 f4.exe
```

---

#### Utilizando un √∫nico comando cambie los permisos de los dos archivos renombrados en el inciso anterior, de manera de reflejar lo siguiente:

- **`Usuario`** Ning√∫n permiso
- **`Grupo`** Permisos de escritura
- **`Otros`** Permisos de escritura y ejecuci√≥n

```shell
chmod 023 f3.exe f4.exe
```

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## `13)` Indique qu√© comando/s es necesario para realizar cada una de las acciones de la siguiente secuencia de pasos (considerando su orden de aparici√≥n):

#### `(a)` Cree un directorio llamado logs en el directorio /tmp.

```shell
cd /tmp; mkdir logs
```

---

#### `(b)` Copie todo el contenido del directorio /var/log en el directorio creado en el punto anterior.

```shell
cp -a /var/log/. /tmp/logs
```

---

#### `(c)` Empaquete el directorio creado en 1, el archivo resultante se debe llamar "misLogs.tar".

```shell
tar cvf misLogs.tar logs
```

---

#### `(d)` Empaquete y comprima el directorio creado en 1, el archivo resultante se debe llamar "misLogs.tar.gz".

```shell
tar cvfz misLogs.tar.gz logs
```

---

#### `(e)` Copie los archivos creados en 3 y 4 al directorio de trabajo de su usuario.

```shell
cp misLoggs.tar $HOME
cp misLogs.tar.gz $HOME
```

---

#### `(f)` Elimine el directorio creado en 1, logs

```shell
rm -r logs
```

---

#### `(g)` Desempaquete los archivos creados en 3 y 4 en do directorios diferentes.

```shell
tar xvf misLogs.tar -C 1 
tar xvfz misLogs.tar.gz -C 2
```

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

#### Fecha

Con el comando `Date`

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">


<div align="center"> 

# üìö Practica 3</div>


<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## 1) Ejercicio
¬øQu√© es el Shell Scripting? ¬øA qu√© tipos de tareas est√°n orientados los script?  ¬øLos scripts deben compilarse? ¬øPor qu√©?

La Shell provee estructuras de control que permiten programar shell scripts. 

El Shell Scripting es la t√©cnica (habilidad / destreza) de dise√±ar y crear Script (archivo de automatizaci√≥n de tareas) mediante un Shell (preferiblemente) de un Sistema Operativo, o un

Editor de Texto (Gr√°fico o Terminal). Este es un tipo de lenguaje de programaci√≥n que generalmente es interpretado.

Est√° orientado a diferentes tareas:
- Automatizaci√≥n de tareas
- Aplicaciones interactivas
- Aplicaciones con interfaz gr√°fica (con el comando zenity, por ejemplo). 

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## 2) Ejercicio

Investigar la funcionalidad de los comandos echo y read

- `Echo:` Es un comando para la impresi√≥n de un texto en pantalla. El comando para imprimir el contenido de la variable es:
- `echo $nombreVar `
- `Read:` El comando read lee su entrada est√°ndar y asigna las palabras le√≠das en la(s) variable(s) cuyo nombre se pasa como argumento. Se trata del input desde teclado. 

![](/Practicas/Practica3/Imagenes/1.png)

---

#### (a) ¬øComo se indican los comentarios dentro de un script? 

Los comentarios tienen que comenzar con el s√≠mbolo \#

---

#### (b) ¬øC√≥mo se declaran y se hace referencia a variables dentro de un script?

No necesita declarar una variable. Se crear√° s√≥lo con asignarle un valor a su referencia. Luego se referencia con el s√≠mbolo $ Ejemplo



Para hacer un script:
- `Paso 1` en la consola usar el comando: `touch script.sh` para crear el directorio.
- `Paso 2` Ver si se creo el directorio con el comando `ls`
- `Paso 3` Ingresar al archivo `script.sh` con el editor de texto vi de la siguiente manera 
   - `vim script.sh `
   - DENTRO DEL EDITOR VIM:
   - Ingresar la letra i para estar en modo insertar y Escribir
   ```bash
   #!/bin/bash 
   CAD="¬°Hola Mundo!"
   echo $CAD
   ```
   - `ESC` (para salir del modo editor)
   - `:wq` (para guardar los cambios)
   - Salimos del editor vi e ingresamos a la consola
- `Paso 4:` Damos permiso de ejecuci√≥n con el comando:
   - `chmod u+x script.sh`
   - Si ponemos el comando ls vamos a ver que el directorio .sh cambio de color.
- `Paso 5:` Con el comando `./script.sh` vamos a ver el contenido de ese script en cosola.
- `Paso 6:` Si queremos borrar ese directorio con script solo es necesario poner en consola el comando `rm script.sh`

Tambien podes ejecutar el script con el comando `bash script.sh`



<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## 3) Ejercicio

Crear dentro del directorio personal del usuario logueado un directorio llamado practicashell-script y dentro de √©l un archivo llamado mostrar.sh cuyo contenido sea el siguiente:

<table>
<td>

```sh
#!/bin/bash
# Comentarios acerca de lo que hace el script
# Siempre comento mis scripts, si no hoy lo hago
# y ma√±ana ya no me acuerdo de lo que quise hacer
echo "Introduzca su nombre y apellido:"
read nombre apellido
echo "Fecha y hora actual:"
date
echo "Su apellido y nombre es:"
echo "$apellido $nombre"
echo "Su usuario es: `whoami`"
echo "Su directorio actual es:"
```

</td>
<td>

![image](https://user-images.githubusercontent.com/55964635/232369884-42f534c8-975e-4053-997a-ad86ffdada50.png)

</td>
</table>





#### **(a)** Asignar al archivo creado los permisos necesarios de manera que pueda ejecutarlo
#### **(b)** Ejecutar el archivo creado de la siguiente manera: ./mostrar
#### **(c)** ¬øQu√© resultado visualiza?
![image](https://user-images.githubusercontent.com/55964635/232370167-cc259f97-9771-4169-958f-31ce04e94529.png)

#### **(d)** Las backquotes (`) entre el comando whoami ilustran el uso de la sustituci√≥n de comandos. ¬øQu√© significa esto?
Son para poder ejecutar comando cuando se encuentran dentro de un string 

#### **(e)** Realizar modificaciones al script anteriormente creado de manera de poder mostrar distintos resultados (cu√°l es su directorio personal, el contenido de un directorio en particular, el espacio libre en disco, etc.). Pida que se introduzcan por teclado (entrada est√°ndar) otros datos.



<table>
<td>

```sh
#!/bin/bash

echo "Nombre y apellido"
read nombre apellido
echo "Fecha y hora actual: `date`"
echo $nombre $apellido
echo "Su usuario es: `whoami`"
echo "su directorio actual es :`pwd`"
echo "su directorio personal es : `$HOME`"
echo "Nombre de un directorio:"
echo contenido
echo "Contenido de $contenido es `ls $contenido`"
echo "Espacio libre en el disco `df`"
```

</td><td>

![](/Documentos/2023-04-17-00-40-25.png) 

</td></table>

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## 4) Ejercicio

Parametrizaci√≥n: ¬øC√≥mo se acceden a los par√°metros enviados al script al momento de su invocaci√≥n? ¬øQu√© informaci√≥n contienen las variables `$#, $*, $?` y `$HOME` dentro de un script?

- Los scripts pueden recibir argumentos en su invocaci√≥n. Para accederlos, se utilizan variables especiales:
- `$0` contiene la invocaci√≥n al script. (nombre del script)
- `$1, $2, $3,...` contienen cada uno de los argumentos.
- `$#` contiene la cantidad de argumentos recibidos.
- `$*` contiene la lista de todos los argumentos separados por espacios.
- `$?` contiene en todo momento el valor de retorno del ultimo comando ejecutado.(si el valor es 0 se ejecuto correctamente, en caso de que haya habido alg√∫n error dar√° un valor entre 1 y 255).


<table><td>

```sh
#!/bin/bash

echo "$0"
echo "$1 $3"
echo "$#"
echo "$*"
echo "$HOME"
```

</td><td>

![](/Documentos/2023-04-17-01-05-38.png)

</td></table>

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## 5) Ejercicio

¬øCual es la funcionalidad de comando exit? ¬øQu√© valores recibe como par√°metro y cual es su significado?

El comando exit finaliza un script. Incluso, puede arrojar un valor de terminaci√≥n, el cual estar√° disponible para su proceso padre.

Todo comando posee un estado de terminaci√≥n (exit status). Un comando que se ejecut√≥ satisfactoriamente arrojar√° un valor de 0, mientras que un comando que no se proces√≥ de manera correcta, finalizar√° con un n√∫mero diferente de 0.

Al igual que un comando, un script posee su propio estado de terminaci√≥n, el cual ser√° determinado por la √∫ltima instrucci√≥n ejecutada por el script.

Dentro de un script, el comando exit puede arrojar un n√∫mero dentro de un rango de 0 a 255.

Se puede consultar el exit status imprimiendo la variable `$?` de la siguiente manera:
- Ingresamos al editor VIM con el archivo mostrar.sh
- Una vez hecho el bin bash, como √∫ltima l√≠nea y dentro de insertar ingresamos el siguiente comando: echo $?
- ESC
- :exit

En la consola se mostrara un n√∫mero de 0 a 255. 

![](/Documentos/2023-04-17-01-20-45.png)

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## 6) Ejercicio

El comando **expr** permite la evaluaci√≥n de expresiones. Su sintaxis es: **expr arg1 op arg2**, donde **arg1 y arg2** representan argumentos y op la operaci√≥n de la expresi√≥n. Investigar que tipo de operaciones se pueden utilizar

- Se puede utilizar 
   - suma
   - resta
   - multiplicaci√≥n (/*)
   - divisi√≥n (/). 
- Y devuelve solo la parte entera.:
- expr 10 + 10 -> 20, expr 14 % 9 -> 5.

Tambi√©n se puede utilizar para:

- C√°lculo de la longitud de la cadena: 
   - expr length ‚Äúesto es un test‚Äù > 
   - devuelve la cantidad de caracteres: 15
- Cadena de rastreo:
   - expr substr ‚Äúesto es un test‚Äù 3 5 > 
   - te devuelve el texto desde la pos 3 y 5 lugares: to es
- La cadena num√©rica primera posici√≥n de rastreo personaje que aparece: 
   - expr index ‚Äúesto es un test‚Äù s 
   - te devuelve el √≠ndice de la letra pasado por par√°metro en la cadena (la primera aparici√≥n).

<table><td>

```sh
#!/bin/bash/

SUMA=`expr 10 + 5`
RESTA=$(expr 10 - 5)
MULTIPLICACION=$(expr 10 \* 5)
DIVISION=$(expr 10 / 5)
MODULO=$(expr 10 % 5)
LONGITUD="Fabian "$(expr length "Fabian")
SUBSTR="Fabian 1 6: "$(expr substr "Fabian" 1 6)
INDICE="Fabian b: "$(expr index "Fabian" b)

echo "var1 = 10, var2 = 5"
echo "SUMA $SUMA"
echo "RESTA $RESTA"
echo "MULTIPLICACION $MULTIPLICACION"
echo "DIVISION $DIVISION"
echo "MODULO $MODULO"
echo "LONGITUD $LONGITUD"
echo "SUBSTR $SUBSTR"
echo "INDICE $INDICE"
```

</td><td>

![](/Documentos/2023-04-17-02-25-09.png)

</td></table>


<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## 7) Ejercicio

El comando **‚Äútest expresi√≥n‚Äù** permite evaluar expresiones y generar un valor de retorno, true o false. Este comando puede ser reemplazado por el uso de corchetes de la siguiente manera **[ expresi√≥n ]**. Investigar que tipo de expresiones pueden ser usadas con el comando test. Tenga en cuenta operaciones para: evaluaci√≥n de archivos, evaluaci√≥n de cadenas de caracteres y evaluaciones num√©ricas.

Este comando tiene un c√≥digo de retorno igual a 0 cuando el test es positivo, y diferente de cero en caso contrario

El comando test posee dos sintaxis: **test expresi√≥n** y **[ expresi√≥n ]**, donde **expresi√≥n** representa el test que se debe efectuar

<table><td>

```sh
#!/bin/bash

var1=10
var2=5

if [ -e 7.sh ]; then echo "existe"; else echo "no existe"; fi

if (( $var1 % $var2 == 0 )); then echo "Es Par"; else echo "Es Impar"; fi

if (( $var1 > $var2 )); then echo "Es Mayor"; else echo "Es Menor"; fi

if [ -r 7.sh -a -w 7.sh -a -x 7.sh ]; then echo "Todos los permisos"
else echo "no tiene todos los permisos"; fi

if [ -r 7.sh -o -w 7.sh -o -x 7.sh ]; then echo "algun permiso"
else echo "no tiene todos los permisos"; fi
```

</td><td> 

![](/Documentos/2023-04-17-03-25-59.png)

</td></table>

### Valores a tener en cuenta

<table>

<td>

| Parametro | Valor |
| --- | --- |
| -r | Si es de Lectura |
| -w | Si es de escritura |
| -x | Si es de ejecuci√≥n |
| -a | and |
| -o | or |
| -e | Si existe |
| -d | Si es un directorio |
| -f | Si es un archivo |
| -n | No es cadena vacia |

</td>

<td>

| Operador | Con Strings | Con n√∫meros | Operaciones |
| --- | --- | --- | --- |
| Igualdad | [ $nombre = "Maria" ] | [ $edad -eq 20 ] | $(( 2 == 2 )) |
| Desigualdad | [ $nombre != "Maria" ] | [ $edad -ne 20 ] | $(( 3 != 4 )) |
| Mayor | [ A > Z ] | [ 5 -gt 20 ] | $(( 3 > 1 )) |
| Mayor o Igual | [ A >= Z ] | [ 5 -ge 20 ] | $( 2 >= 1 )) |
| Menor | [ A < Z ] | [ 5 -lt 20 ] | $(( 1 < 10 )) |
| Menor o Igual | [ A <= Z ] | [ 5 -le 20 ] | $(( 3 <= 5 )) |

</td>
</table>


<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## 8) Ejercicio

Estructuras de control. Investigue la sintaxis de las siguientes estructuras de control incluidas en shell scripting:

<table>

<tr>
<td>

```sh
#!/bin/bash
if [ 3 -eq 3 ]; then
  echo "Son iguales"
else
  echo "Son distintos"
fi
```
</td>
<td>

![](/Documentos/2023-04-17-04-59-47.png) 
</td>
</tr>

<tr>
<td>

```sh
#!/bin/bash
echo "Ingrese un caracter"
read letra
case $letra in
  [a-z]) echo "Es una minuscula";;
  [A-Z]) echo "Es una mayuscula";;
  [0-9]) echo "Es un nro";;
  *) echo "Ingreso un caracter invalida";;
esac
```
</td>
<td>

![](/Documentos/2023-04-17-04-32-55.png)
</td>
</tr>

<tr>
<td>

```sh
#!/bin/bash
var1=0
while [ $var1 -le 5 ]
do
  echo "Hola mundo"
  var1=$((var1+1))
done
```
</td>
<td>

![](/Documentos/2023-04-17-04-15-06.png)
</td>
</tr>

<tr>
<td>

```sh
#!/bin/bash
for var in 1 2 3 4 5
do
  echo $var
done
echo "--------"
for var2 in {1..5}
do
  echo $var2
done
echo "--------"
for ((i=1; i<=5; i++))
do
  echo $i
done
```
</td>
<td>

![](/Documentos/2023-04-17-04-47-29.png)
</td>
</tr>

<tr>
<td>

```sh
#!/bin/bash
select opcion in opcion1 opcion2
do
  case $opcion in
    opcion1) echo "Opcion1" ;;
    opcion2) echo "Opcion2";;
    *) exit;;
  esac
done
```
</td>
<td>

![](/Documentos/2023-04-17-12-08-38.png)

</td>
</tr>
</table>


<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## 9) Ejercicio

¬øQu√© acciones realizan las sentencias break y continue dentro de un bucle? ¬øQu√© par√°metros reciben?

- **`break [n]`** Corta la ejecuci√≥n de `n` niveles de loops.
- **`continue [n]`** salta a la siguiente iteraci√≥n del en√©simo loop que contiene esta instrucci√≥n

<table><td>

```sh
#!/bin/bash/
contador=0
while true
do
  let contador++
  if [ $contador -eq 10 ]; then
    break
  elif [ $contador -eq 5 ]; then
    continue
  fi
  echo $contador
done
```
</td><td>

![](/Documentos/2023-04-17-12-31-44.png)

</td></table>

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## 10) Ejercicio
¬øQu√© tipo de variables existen? ¬øEs shell script fuertemente tipado? ¬øSe pueden definir arreglos? ¬øC√≥mo?

bash soporta `strings` y `arrays`
- Los nombres son case sensitive
- Para crear una variable:
   - NOMBRE="pepe" # SIN espacios alrededor del =
- Para accederla se usa $:
   - echo $NOMBRE

Para evitar ambig√ºedades se pueden usar llaves:

- Esto no accede a $NOMBRE
- echo $NOMBREesto_no_es_parte_de_la_variable
- Esto s√≠
- echo ${NOMBRE}esto_no_es_parte_de_la_variable
Los nombres de las variables pueden contener may√∫sculas, min√∫sculas, n√∫meros y el s√≠mbolo (underscore), pero no pueden empezar con un n√∫mero.

No es fuertemente tipado, y no requiere una declaraci√≥n expl√≠cita de tipo variables.

### Todo sobre los arreglos

| Bash | Resultado |
| --- | --- |
| arreglo=() | Definir Arreglo vacio |
| arreglo[0]="valor1" | Asignaci√≥n |
| arreglo=("valor1", "valor2") | Definir con valores |
| read -a arreglo | leer desde teclado <br> tiene que estar definido arriba |
| ${arreglo[0]} | retorna "valor1" |
| ${arreglo[*]} | Retorna todos los elementos del array |
| ${arreglo[@]} | Retorna todos los elementos del array |
| ${#arreglo[@]} | Retorna 2, si contiene valor1 y valor2 |

#### Codigo de ejemplo

<table><td>

```sh
#!/bin/bash
array=()

read -a array
echo "Array pelado" $array
echo "index 3" ${array[3]}
echo "Todos los elementos" ${array[*]}
echo "Cantidad de elementos" ${#array[*]}
```
</td><td>

![](/Documentos/2023-04-17-13-17-14.png)
</td>
</table>

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## 11) Ejercicio

¬øPueden definirse funciones dentro de un script? ¬øC√≥mo? ¬øC√≥mo se maneja el pasaje de par√°metros de una funci√≥n a la otra?

Si, se pueden definir funciones dentro de un script.
- Las funciones permiten modularizar el comportamiento de los scripts. 
- Se pueden declarar de 2 formas:
   ```
   function nombre { block }
   nombre() { block }
   ```
- Con la sentencia return se retorna un valor entre 0 y 255
- El valor de retorno se puede evaluar mediante la variable $?
- Reciben argumentos en las variables $1, $2, etc

Para definir variables locales podemos usar la palabra clave `local var1`

<table><td>

```sh
#!/bin/bash
sumar(){
  return $(( $1 + $2 ))
}
cadena(){
  echo "Hola $1, como estas"
}

sumar 2 3
echo $?
mensaje=$(cadena "Juan")
echo $mensaje
```
</td><td>

![](/Documentos/2023-04-17-13-30-12.png)
</td></table>

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## 12) Ejercicio

Evaluaci√≥n de expresione

#### **(a)** Realizar un script que le solicite al usuario 2 n√∫meros, los lea de la entrada Standard e imprima la multiplicaci√≥n, suma, resta y cual es el mayor de los n√∫meros le√≠dos.


<table><td>

```sh
#!/bin/bash

echo "Ingrese dos nros"
read nro1 nro2
echo "MULTIPLICACION: $(( $nro1 * $nro2 ))"
echo "SUMA: $(( $nro1 + $nro2 ))"
echo "RESTA: $(( $nro1 - $nro2 ))"

if [ $nro1 -gt $nro2 ]; then
  echo "es mayor el $nro1"
else 
  echo "es mayor el $nro2"
fi
```
</td><td>

![](/Documentos/2023-04-17-13-48-29.png)
</td></table>

#### **(b)** Modificar el script creado en el inciso anterior para que los n√∫meros sean recibidos como par√°metros. El script debe controlar que los dos par√°metros sean enviados.

<table><td>

```sh
#!/bin/bash

if (( $# != 2 )); then exit 0; fi

echo "MULTIPLICACION: $(( $1 * $2 ))"
echo "SUMA: $(( $1 + $2 ))"
echo "RESTA: $(( $1 - $2 ))"

if [ $1 -gt $2 ]; then
  echo "es mayor el $1"
else 
  echo "es mayor el $2"
fi
```
</td><td>

![](/Documentos/2023-04-17-15-26-52.png)
</td></table>

#### **(c)** Realizar una calculadora que ejecute las 4 operaciones b√°sicas: +, - ,*, %. Esta calculadora debe funcionar recibiendo la operaci√≥n y los n√∫meros como par√°metros

<table><td>

```sh
#!/bin/bash
select operacion in Multiplicacion Suma Resta CualEsMayor Cerrar
do
   case $operacion in
      Multiplicacion) echo "MULTIPLICACION: $(( $1 * $2 ))" ;;
      Suma) echo "SUMA: $(( $1 + $2 ))" ;;
      Resta) echo "RESTA: $(( $1 - $2 ))" ;;
      CualEsMayor) 
         if [ $1 -gt $2 ]; then echo "es mayor el $1";
         else echo "es mayor el $2" ;fi
         ;;
      Cerrar|*) exit ;;
   esac  
done
```
</td><td>

![](/Documentos/2023-04-17-15-45-51.png)
</td></table>

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## 13) Ejercicio

Uso de las estructuras de control

#### **(a)** Realizar un script que visualice por pantalla los n√∫meros del 1 al 100 as√≠ como sus cuadrados.


<table><td>

```sh
#!/bin/bash
for i in {1..100}
do
  echo "$i La potencia es: $(($i * $i))"
done
```
</td><td>

![](/Documentos/2023-04-17-15-58-03.png)
</td></table>

#### (b) Crear un script que muestre 3 opciones al usuario: Listar, DondeEstoy y QuienEsta. Seg√∫n la opci√≥n elegida se le debe mostrar:
- Listar: lista el contenido del directoria actual.
- DondeEstoy: muestra el directorio donde me encuentro ubicado.
- QuienEsta: muestra los usuarios conectados al sistema.

<table><td>

```sh
#!/bin/bash
select opcion in Listar DondeEstoy QuienEsta
do
  case $opcion in
    Listar) echo $(ls) ;;
    DondeEstoy) echo $(pwd);;
    QuienEsta) echo $(who);;
    *) exit;;
  esac
done
```
</td><td>

![](/Documentos/2023-04-17-16-22-17.png)
</td></table>

#### (c) Crear un script que reciba como par√°metro el nombre de un archivo e informe si el mismo existe o no, y en caso afirmativo indique si es un directorio o un archivo. En caso de que no exista el archivo/directorio cree un directorio con el nombre recibido como par√°metro

<table><tr><td>

```sh
#!/bin/bash
if (( $# != 1 )); then exit; fi

fi [ -e $1 ]; then
   echo "El archivo $1 existe"
   fi [ -f $1 ]; then echo "Y es un archivo"; fi
   fi [ -d $1 ]; then echo "Y es un directorio"; fi
   exit
fi
mkdir $1
```
</td></tr><tr><td>

![](/Documentos/2023-04-17-16-38-34.png)
</td></tr></table>

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

# 14) Ejercicio

Renombrando Archivos: haga un script que renombre solo archivos de un directorio pasado como parametro agregandole una CADENA, contemplando las opciones:
- **‚Äú-a CADENA‚Äù:** renombra el fichero concatenando CADENA al final del nombre del archivo
- **‚Äú-b CADENA‚Äù:** renombra el fichero concantenado CADENA al principio del nombre
del archivo


Ejemplo:

- Si tengo los siguientes archivos: /tmp/a /tmp/b
- Al ejecutar: ./renombra /tmp/ -a EJ
- Obtendr√© como resultado: /tmp/aEJ /tmp/bEJ
- Y si ejecuto: ./renombra /tmp/ -b EJ
- El resultado ser√°: /tmp/EJa /tmp/EJb

Comandos ejecutados
- bash 14.sh prueba -a Ej 
- Despues 
- bash 14.sh prueba -b Ej 


<table>
<td>

```sh
#!/bin/bash
if [ $# -ne 3 ]; then 
  echo  -e "
  Parametros: \n
  Path \n
  -a/-b \n
  sufijo/prefijo
"; exit;fi

if ! [ -e $1 ]; then 
  echo "El path ingresado no existe"
  exit
fi
cd $1
archivos="$(ls)"
ls -1
if [ $2 = "-a" ];then
  for i in ${archivos[*]};do mv $i $i$3;done
elif [ $2 = "-b" ];then
  for i in ${archivos[*]};do mv $i $3$i;done
else
  echo "Tiene que ingresar -a o -b"
fi
echo "Despues de todo:"
ls -1
```

</td>
<td>

![](/Documentos/2023-04-18-10-12-13.png)

</td>
</table>



<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## 15) Ejercicio

**Comando cut**. El comando cut nos permite procesar la l√≠neas de la entrada que reciba (archivo, entrada est√°ndar, resultado de otro comando, etc) y cortar columnas o campos, siendo posible indicar cual es el delimitador de las mismas. Investigue los par√°metros que puede recibir este comando y cite ejemplos de uso.

Comando cut : Su principal utilidad es la de borrar secciones, campos o caracteres de la salida de un comando o de cada una de las l√≠neas de un fichero de texto.

Ejemplos de uso:
- Mostrar los caracteres que nos interesen en una l√≠nea de texto o en un conjunto de l√≠neas
- Imaginemos que tenemos un fichero de texto con el nombre `geekland.txt` que tiene el siguiente contenido:
   ``` 
   la utilidad
   es f√°cil de usar y es √∫til
   ```
- Si √∫nicamente queremos mostrar el cuarto car√°cter de cada una de las l√≠neas lo haremos con la opci√≥n `-c 4`
- `cut -c 4 geekland.txt`
   ```
   u
   f
   ```
- Si ahora queremos mostrar los caracteres del 2 al 6:
- `cut -c 2-6 geekland.txt`
   ```
   a uti
   s f√°
   ```
- Si finalmente queremos mostrar los caracteres 1,2,3 y 5,6,7 y 8 de cada una de las l√≠neas de un fichero de texto:
- `cut -c 1-3,5-8 geekland.txt`
   ```
   la tili
   es √°ci
   ```

Cut tambi√©n ofrece la posibilidad de seleccionar un car√°cter inicial y seleccionar el resto de caracteres hasta el final. Por ejemplo para seleccionar el texto a partir del car√°cter 5 hasta el final usaremos la opci√≥n `-c 5-` del siguiente modo:
- `cut -c 5- geekland.txt`
   ```
   tilidad cut
   √°cil de usar y es √∫til
   ```

O tambi√©n permite seleccionar un car√°cter final y seleccionar el resto de caracteres hasta el inicio de la frase o fichero. Por lo tanto para mostrar desde el car√°cter 4 hasta el inicio de la frase lo haremos del siguiente modo:
- `cut -c -4 geekland.txt`
   ```
   la u
   es f
   ```
- Capturar texto a partir de un delimitador y fijando el campo que queremos mostrar
- Si √∫nicamente queremos mostrar la tercera palabra:
- `a)` Cada palabra esta separada por un espacio. Por lo tanto tendremos que fijar el espacio como delimitador. Para fijar el espacio como delimitador lo har√© con la opci√≥n
- `-d ' '`
- `b)` A continuaci√≥n hay que definir la palabra que queremos mostrar. si queremos
mostrar la tercera palabra lo haremos con la opci√≥n ‚Äìf2. La opci√≥n ‚Äìf2 hace que se
muestre la palabra que hay entre el segundo y tercer delimitador.
- `cut -d ' ' ‚Äìf2`
   ```
   utilidad
   f√°cil
   ```
- Ahora imaginemos que la salida del comando cat /etc/passwd es la siguiente:
- `cat /etc/passwd`
   ```
   root:x:0:0:root:/root:/bin/bash
   daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
   bin:x:2:2:bin:/bin:/usr/sbin/nologin
   sys:x:3:3:sys:/dev:/usr/sbin/nologin
   ...
   ```

Si √∫nicamente queremos mostrar los usuarios podemos fijar que el delimitador sea : y a posteriori definir que se muestre el primer campo. Para hacer lo que acabo de mencionar podemos usar el siguiente comando:
- `cut -d ':' -f1 /etc/passwd`
```
root
daemon
bin
sys
... 
```

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## 16) Ejercicio

Realizar un script que reciba como par√°metro una extensi√≥n y haga un reporte con 2
columnas, el nombre de usuario y la cantidad de archivos que posee con esa extensi√≥n. Se debe guardar el resultado en un archivo llamado **reporte.txt**


Funciona un toque raro el find
```sh
#!/bin/bash

if [ $# -ne 1 ]; then echo "error"; exit 1; fi

cadena=""
for i in $(cat /etc/passwd) 
do
  usuario=$(echo $i | cut -d: -f1)
  path=$(echo $i | cut -d: -f6)  
  cadena+="$usuario $(find $path -name "*$1" | wc -l) \n"
done
echo -e "$cadena" > reporte.txt
```

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## 17) Ejercicio

Escribir un script que al ejecutarse imprima en pantalla los nombre de los archivos que se encuentran en el directorio actual, intercambiando min√∫sculas por may√∫sculas, adem√°s de eliminar la letra a (may√∫scula o min√∫scula). Ejemplo, directorio actual:

```bash
IsO
pepE
Maria
Si ejecuto: ./ejercicio17
```
Obtendr√© como resultado

```
iSo
PEPe
mRI
```

**Ayuda**: Investigar el comando **tr**

```sh
#!/bin/bash

archivos=$(ls)
for i in $archivos
do
  nuevo=$(echo $i | tr '[:lower:][:upper:]' '[:upper:][:lower:]' | tr -d 'aA')
  echo $nuevo
done
```

Tambien podemos eliminar de la siguiente manera
- `nuevo_nombre=${archivo//a}`
- `nuevo_nombre=${archivo^^}` Todo a mayuscula
- `nuevo_nombre=${archivo,,}` Todo a minuscula
- echo $i | tr [a-zA-Z] [A-Za-z] | tr -d 'aA'

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## 18) Ejercicio

Crear un script que verifique cada 10 segundos si un usuario se ha loqueado en el sistema (el nombre del usuario ser√° pasado por par√°metro). Cuando el usuario finalmente se loguee, el programa deber√° mostrar el mensaje ‚ÄùUsuario XXX logueado en el sistema‚Äù y salir.

```sh
#!/bin/bash

if [ $# -ne 1 ]; then 
  echo "Parametros incorrectos"; exit 1; 
fi

usuarios=$(cat /etc/passwd | cut -d: -f1 | grep -w $1 | wc -l)
if [ $usuarios -eq 0 ]; then
  echo "El usuario pasado no existe"; exit 2;
fi

while true
do
  if [ $(users | grep -w $1 | wc -l) -eq 1 ]; then
    echo "usuario $1 logueado en el sistema"
    exit
  fi  
  sleep 10
done
```

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## 19) Ejercicio

Escribir un Programa de ‚ÄúMenu de Comandos Amigable con el Usuario‚Äù llamado menu, el cual, al ser invocado, mostrar√° un men√∫ con la selecci√≥n para cada uno de los scripts creados en esta pr√°ctica. Las instrucciones de como proceder deben mostrarse junto con el men√∫. El men√∫ deber√° iniciarse y permanecer activo hasta que se seleccione Salir. Por ejemplo:

```
MENU DE COMANDOS
03. Ejercicio 3
12. Evaluar Expresiones
13. Probar estructuras de control
...
Ingrese la opci√≥n a ejecutar: 03
```

```sh
#!/bin/bash

scripts=$(ls | grep "\.sh")
select opcion in Salir $scripts
do
  case $opcion in
    Salir) exit;;
    *) source $opcion;;
  esac
done
```

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## 20) Ejercicio

Realice un scrip que simule el comportamiento de una estructura de PILA e implemente las siguientes funciones aplicables sobre una estructura global definida en el script:

- **push:** Recibe un par√°metro y lo agrega en la pila 
- **pop:** Saca un elemento de la pila
- **lenght:** Devuelve la longitud de la pila
- **print:** Imprime todos elementos de la pila

```sh
#!/bin/bash
pila=()

push (){
  pila+=($1)
}
pop (){
  unset pila[${#pila[@]}-1]
}
lenght (){
  echo ${#pila[*]}
}
print(){
  echo ${pila[*]}
}
```

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## 21) Ejercicio

- Agregue 10 elementos a la pila.
- Saque 3 de ellos.
- Imprima la longitud de la cola.
- Luego imprima la totalidad de los elementos que en ella se encuentan.

```sh
#!/bin/bash

pila=()
push (){ pila+=($1); }
pop (){ unset pila[${#pila[@]}-1]; }
lenght (){ echo ${#pila[*]}; }
print(){ echo ${pila[*]}; }

push 2
push 4
echo "$(lenght)"
print
pop
print
```

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## 22) Ejercicio

Dada la siguiente declaraci√≥n al comienzo de un script: num=(10 3 5 7 9 3 5 4) (la cantidad de elementos del arreglo puede variar). Implemente la funci√≥n productoria dentro de este script, cuya tarea sea multiplicar todos los n√∫meros del arreglo

```sh
#!/bin/bash

num=(10 3 5 7 9 3 5 4)
productora(){
  let resultado=1
  for i in ${num[*]}
  do
    resultado=$(($i * $resultado))
  done
  echo $resultado
}

productora
```

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## 23) Ejercicio

Implemente un script que recorra un arreglo compuesto por n√∫meros e imprima en pantalla s√≥lo los n√∫meros pares y que cuente s√≥lo los n√∫meros impares y los informe en pantalla al finalizar el recorrido

```sh
#!/bin/bash
nros=(10 3 5 7 9 3 5 4)

imprimir(){
  let nro
  for i in ${nros[*]}
  do
    echo $i
    if (( $i % 2 == 0 )); then
      echo "Par: "$i
    else
      let impares++
    fi
  done
  echo "Nros Impares: "$impares
}

imprimir
```

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## 24) Ejercicio

Dada la definici√≥n de 2 vectores del mismo tama√±o y cuyas longitudes no se conocen

```bash
vector1=( 1 .. N)
vector2=( 7 .. N)
Por ejemplo:
vector1=( 1 80 65 35 2 )
y
vector2=( 5 98 3 41 8 ).
```

Complete este script de manera tal de implementar la suma elemento a elemento entre
ambos vectores y que la misma sea impresa en pantalla de la siguiente manera:

```
La suma de los elementos de la posici√≥n 0 de los vectores es 6
La suma de los elementos de la posici√≥n 1 de los vectores es 178
...
La suma de los elementos de la posici√≥n 4 de los vectores es 10
```
```sh
#!/bin/bash
vector1=(1 80 65 35 2 )
vector2=(5 98 3 41 8 )
long=`expr ${#vector1[*]} - 1`

for i in $(seq 0 $long)
do
  resultado=`expr ${vector1[$i]} + ${vector2[$i]}`
  echo "La suma de los elementos de la posicion $i de los vectores es $resultado"
done
```

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## 25) Ejercicio

Realice un script que agregue en un arreglo todos los nombres de los usuarios del sistema
pertenecientes al grupo ‚Äúusers‚Äù. Adicionalmente el script puede recibir como parametro:

- **‚Äú-b n‚Äù**: Retorna el elemento de la posici√≥n n del arreglo si el mismo existe. Caso contrario, un mensaje de error.
- **‚Äú-l‚Äù:** Devuelve la longitud del arreglo
- **‚Äú-i‚Äù:** Imprime todos los elementos del arreglo en pantalla

```sh
#!/bin/bash

# En grupo, me quedo con la columna 4 que tiene
# Los usuarios del grupo
# Uso el grep para filtrar por grupo aunque puede haber un usuario con nombre
# users pero bueno
# Cambiamos el separador de , por un espacio para agregarlo al array

if [ $# -ne 1 ] && [ $# -ne 2 ]; then echo "Parametros Invalidos"; exit 1; fi 
grupo=$(cat /etc/group | grep -w "users" |cut -d: -f4 | tr "," " ")
usuarios=($grupo)

case $1 in
  -b)
    if [ $2 -lt ${#usuarios[*]} ]; then
      echo ${usuarios[$2]}
    else
      echo "Parametro fuera de rango"
      exit 1
    fi;;
  -l) echo "Longitud: ${#usuarios}";;
  -i) echo "Todos: ${usuarios[*]}";;
esac
```

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## 26) Ejercicio

Escriba un script que reciba una cantidad desconocida de par√°metros al momento de su invocaci√≥n (debe validar que al menos se reciba uno). Cada par√°metro representa la ruta absoluta de un archivo o directorio en el sistema. El script deber√° iterar por todos los par√°metros recibidos, y solo para aquellos par√°metros que se encuentren en posiciones impares (el primero, el tercero, el qverificar si el archivo o directorio existen en el sistema, imprimiendo en pantalla que tipo de objeto es (archivo o directorio). Adem√°s, deber√° informar la cantidad de archivos o directorios inexistentes en el sistema.

```bash
#!/bin/bash
if [ $# -le  0 ]; then exit 1;fi

let existen
for ((i=0 ; i<=$cantidad ; i+=2));
do
  actual=${elementos[$i]}
  if [ -d $actual ]; then echo "es un directorio";
  elif [ -f $actual ]; then echo "es un archivo";
  else let existen++;fi
done
echo "La cantidad de archivos que no existen es" $existen
```

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## 27) Ejercicio

Realice un script que implemente a trav√©s de la utilizaci√≥n de funciones las operaciones
b√°sicas sobre arreglos:

- **inicializar:** Crea un arreglo llamado array vac√≠o
- **agregar_elem \<parametro1>:** Agrega al final del arreglo el par√°metro recibido
- **eliminar_elem \<parametro1>:** Elimina del arreglo el elemento que se encuentra en la
posici√≥n recibida como par√°metro. Debe validar que se reciba una posici√≥n v√°lida
- **longitud:** Imprime la longitud del arreglo en pantalla
- **imprimir:** Imprime todos los elementos del arreglo en pantalla
- **inicializar_Con_Valores \<parametro1>\<parametro2>:** Crea un arreglo con longitud
\<parametro1>y en todas las posiciones asigna el valor \<parametro2>


```shell
#!/bin/bash

inicializar(){
  array=()
  echo "vecto pa"
}
agregar_elem(){
  array+=($1)
}
eliminar_elem(){
  unset array[$1]
}
imprimir(){
  echo ${array[*]}
}
longitud(){
  echo ${#array[*]}
}
inicializar_Con_Valores(){
  for ((i=0; i<$1; i++));
  do
    array+=($2)
  done
}

select opcion in  inicializar agregar_elem eliminar_elem longitud imprimir inicializar_Con_Valores
do  
  case $opcion in
    inicializar) inicializar;;
    agregar_elem) agregar_elem 9;;
    eliminar_elem) eliminar_elem 0;;
    longitud) longitud ;;
    inicializar_Con_Valores) inicializar_Con_Valores 10 4 ;;
    imprimir) imprimir;;
  esac
done
```

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## 28) Ejercicio
Realice un script que reciba como par√°metro el nombre de un directorio. Deber√° validar que el mismo exista y de no existir causar la terminaci√≥n del script con c√≥digo de error 4. Si el directorio existe deber√° contar por separado la cantidad de archivos que en √©l se encuentran para los cuales el usuario que ejecuta el script tiene permiso de lectura y escritura, e informar dichos valores en pantalla. En caso de encontrar subdirectorios, no deber√°n procesarse, y tampoco deber√°n ser tenidos en cuenta para la suma a informar.

```sh
#!/bin/bash

if [ $# -ne 1 ]; then echo "Ingrese un parametro"; exit 1; fi
if ! [ -e $1 ] && ! [ -d $1 ] ; then exit 4; fi

archivos=($(ls))
let contador=0
for i in ${archivos[*]} 
do
  if [ -f $i ] && [ -w $i ] && [ -r $i ]; then let contador++;fi
done
echo $contador
```

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## 29) Ejercicio

Implemente un script que agregue a un arreglo todos los archivos del directorio /home cuya terminaci√≥n sea .doc. Adicionalmente, implemente las siguientes funciones que le permitan acceder a la estructura creada:

- verArchivo \<nombre_de_archivo>: Imprime el archivo en pantalla si el mismo se
encuentra en el arreglo. Caso contrario imprime el mensaje de error ‚ÄúArchivo no encontrado‚Äù y devuelve como valor de retorno 5
- cantidadArchivos: Imprime la cantidad de archivos del /home con terminaci√≥n .doc
- borrarArchivo \<nombre_de_archivo>: Consulta al usuario si quiere eliminar el archivo l√≥gicamente. Si el usuario responde Si, elimina el elemento solo del arreglo. Si el usuario responde No, elimina el archivo del arreglo y tambi√©n del FileSystem. Debe validar que el archivo exista en el arreglo. En caso de no existir, imprime el mensaje de error ‚ÄúArchivo no encontrado‚Äù y devuelve como valor de retorno 10

```sh
#!/bin/bash

archivos_doc=$( ls $HOME | grep '\.doc$' )

verArchivo(){
  encontro=false
  for i in ${archivos_doc[*]}
  do
    if [ $1 = $i ]; then 
      echo $(cat "$HOME/$1")
      encontro=true
    fi
  done
  if [ $encontro = false ]; then echo "No se encontro" ;return 5; fi
}

cantidadArchivos(){
  echo ${#archivos_doc[*]}
}

borrarArchivo(){
  echo "Ingrese un archivo"
  if ! [ -e "$HOME/$1" ]; then echo "Archivo no encontrado"; return 10; fi
  echo "Quiere eliminar el archivo logicamente? SI O NO"
  select desicion in SI NO SALIR  
  do
    case $desicion in
      SI) unset "$archivos_doc[$1]"; echo "Elementos ${archivos_doc[*]}" ;;
      NO) rm "$HOME/$1" ;;
      SALIR) break;;
    esac
  done
}

verArchivo "ejercio292.doc"
cantidadArchivos
borrarArchivo "ejercio9.doc"
echo $?
```

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## 30) Ejercicio

Realice un script que mueva todos los programas del directorio actual (archivos ejecutables) hacia el subdirectorio ‚Äúbin‚Äù del directorio HOME del usuario actualmente logueado. El script debe imprimir en pantalla los nombres de los que mueve, e indicar cu√°ntos ha movido, o que no ha movido ninguno. Si el directorio ‚Äúbin‚Äù no existe,deber√° ser creado.

```sh
#!/bin/bash

# El -F agrega un indicador al final para saber que permisos tiene
# / para directorios
# * para archivos ejecutables

archivos=$(ls -F | grep "*$")
if [ -n ${archivos[*]} ];then exit 1; fi
echo ${archivos[*]}
bin="$HOME/bin"
if ! [ -e $bin ]; then mkdir $bin; fi

mv ${archivos[*]} $bin
```

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

<h1 align="center"> üìï Practica 4</h1>

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">


### **Objetivo**

El objetivo de esta pr√°ctica es que el alumno comprenda los aspectos base acerca de la planificaci√≥n de procesos en un Sistema Operativo (tipos de planificadores, algoritmos y sus variantes, etc.). Adem√°s, para la autocorrecci√≥n de los ejercicios, es deseable la utilizaci√≥n del simulador
que se encuentra en c√°tedras virtuales


### 1. Responda en forma sint√©tica sobre los siguientes conceptos:
- **`(a)`** Programa y Proceso
- **`(b)`** Defina Tiempo de retorno (TR) y Tiempo de espera (TE) para un Job.
- **`(c)`** Defina Tiempo Promedio de Retorno (TPR) y Tiempo promedio de espera (TPE) para un lote de JOBS.
- **`(d)`** ¬øQu√© es el Quantum?
- **`(e)`** ¬øQu√© significa que un algoritmo de scheduling sea apropiativo o no apropiativo (Preem-ptive o Non-Preemptive)?
- **`(f)`** ¬øQu√© tareas realizan?:
    - i. Short Term Scheduler
    - ii. Long Term Scheduler
    - iii. Medium Term Scheduler
- **`(g)`** ¬øQu√© tareas realiza el Dispatcher?

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

### 2.Procesos

- `a)` Investigue y detalle para que sirve cada uno de los siguientes comandos. (Puede que alg√∫n comando no venga por defecto en su distribuci√≥n por lo que deber√° instalarlo)
    - `i)` top
    - `ii)` htop
    - `iii)` ps
    - `iv)` pstree
    - `v)` kill
    - `vi)` pgreppkillkillall
    - `vii)` killall
    - `viii)` renice
    - `ix)` xkill
    - `x)` atop
- `b)` Observe detenidamente el siguiente c√≥digo. Intente entender lo que hace sin necesidad de ejecutarlo. <br><br>
    ```c
    #include <stdio.h>
    #include <sys/types.h>
    #include <unistd.h>
    int main ( void ) {
        int c;
        pid_t pid;
        printf (" Comienzo . : \n " ) ;
        for ( c = 0; c < 3 ; c++ ){
            pid = fork ( ) ;
            }
        printf(" Proceso \n " ) ;
        return 0;
    }
    ```
    - i. ¬øCu√°ntas l√≠neas con la palabra ‚ÄúProceso‚Äù aparecen al final de la ejecuci√≥n de este programa?.
    - ii. ¬øEl n√∫mero de l√≠neas es el n√∫mero de procesos que han estado en ejecuci√≥n?.
Ejecute el programa y compruebe si su respuesta es correcta, Modifique el valor
del bucle for y compruebe los nuevos resultados
- `c)` Vamos a tomar una variante del programa anterior. Ahora, adem√°s de un mensaje, vamos a a√±adir una variable y, al final del programa vamos a mostrar su valor. El nuevo c√≥digo del programa se muestra a continuaci√≥n. <br><br>
    ```c
    #include <stdio.h>
    #include <sys/types.h>
    #include <unistd.h>
    int main ( void ) {
        int c ;
        int p=0;
        pid_t pid ;
        for ( c = 0; c < 3 ; c++ ){
            pid = fork ( ) ;
        }
        p++;
        printf (" Proceso %d \n " , p ) ;
        return 0;
    }
    ```
    - i. ¬øQu√© valores se muestran por consola?.
    - ii. ¬øTodas las l√≠neas tendr√°n el mismo valor o algunas l√≠neas tendr√°n valores distin- tos?.
    - iii. ¬øCu√°l es el valor (o valores) que aparece?. Ejecute el programa y compruebe si su respuesta es correcta, Modifique el valor del bucle for y el lugar d√≥nde se incrementa la variable p y compruebe los nuevos resultados.
- `(d)` Comunicaci√≥n entre procesos
    - i. Investigue la forma de comunicaci√≥n entre procesos a trav√©s de pipes.
    - ii. ¬øC√≥mo se crea un pipe en C?.
    - iii. ¬øQu√© parametro es necesario para la creaci√≥n de un pipe?. Explique para que se utiliza.
    - iv. ¬øQu√© tipo de comunicaci√≥n es posible con pipes?
- `(e)` ¬øCu√°l es la informaci√≥n m√≠nima que el SO debe tener sobre un proceso?¬øEn que es- tructura de datos asociada almacena dicha informaci√≥n?
- `(f)` ¬øQu√© significa que un proceso sea ‚ÄúCPU Bound‚Äù y ‚ÄúI/O Bound‚Äù?
- `(g)` ¬øCu√°les son los estados posibles por los que puede atravesar un proceso?
- `(h)` Explique mediante un diagrama las posibles transiciones entre los estados.
- `(i)` ¬øQue scheduler de los mencionados en 1 f se encarga de las transiciones?

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

### 3. Para los siguientes algoritmos de scheduling:

- FCFS (Fisrt Coome First Served)
- SJF (Shortest Job First)
- Round Robin
- Prioridades

***Realice***

- `(a)` Explique su funcionamiento mediante un ejemplo.
- `(b)` ¬øAlguno de ellos requiere alg√∫n par√°metro para su funcionamiento?
- `(c)` Cual es el mas adecuado seg√∫n los tipos de procesos y/o SO.
- `(d)` Cite ventajas y desventajas de su uso

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">


### 4. Para el algoritmo Round Robin, existen 2 variantes:

- Timer Fijo
- Timer Variable

***Realice***

- `(a)` ¬øQu√© significan estas 2 variantes?
- `(b)` Explique mediante un ejemplo sus diferencias.
- `(c)` En cada variante ¬øD√≥nde deber√≠a residir la informaci√≥n del Quantum?

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">


### 5. Se tiene el siguiente lote de procesos que arriban al sistema en el instante 0 (cero):

| Job | Unidades de CPU |
| --- | --- |
| 1 | 7 |
| 2 | 15 |
| 3 | 12 |
| 4 | 4 |
| 5 | 9 |

- `(a)` Realice los diagramas de Gantt seg√∫n los siguientes algoritmos de scheduling:
    - i. FCFS (First Come, First Served)
    - ii. SJF (Shortest Job First)
    - iii. Round Robin con quantum = 4 y Timer Fijo
    - iv. Round Robin con quantum = 4 y Timer Variable
- `(b)` Para cada algoritmo calcule el TR y TE para cada job as√≠ como el TPR y el TPE.
- `(c)` En base a los tiempos calculados compare los diferentes algoritmos.

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

### 6. Se tiene el siguiente lote de procesos

- `(a)` Realice los diagramas de Gantt seg√∫n los siguientes algoritmos de scheduling: <br><br>
    | Job | Llegada | Unidades de CPU |
    | --- | --- | --- |
    | 1 | 0 | 4 |
    | 2 | 2 | 6 |
    | 3 | 3 | 4 |
    | 4 | 6 | 5 |
    | 5 | 8 | 2 |
    - i. FCFS (First Come, First Served)
    - ii. SJF (Shortest Job First)
    - iii. Round Robin con quantum = 1 y Timer Variable
    - iv. Round Robin con quantum = 6 y Timer Variable

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">


### 7. Una variante al algoritmo SJF es el algoritmo SJF apropiativo o SRTF (Shortest Remaining Time First):
- `(a)` Realice el diagrama del Gantt para este algoritmo seg√∫n el lote de trabajos del ejercicio 6.
- `(b)` ¬øNota alguna ventaja frente a otros algoritmos?

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

### 8. Suponga que se agregan las siguientes prioridades al lote de procesos del ejercicio 6, donde un menor n√∫mero indica mayor prioridad:


| Job | Prioridad |
| --- | --- |
| 1 | 3 |
| 2 | 4 |
| 3 | 2 |
| 4 | 1 |
| 5 | 2 |

- `(a)` Realice el diagrama de Gantt correspondiente al algoritmo de planificaci√≥n por prioridades seg√∫n las variantes:
    - i. No Apropiativa
    - ii. Apropiativa
- `(b)` Calcule el TR y TE para cada job as√≠ como el TPR y el TPE.
- `(c)` ¬øNota alguna ventaja frente a otros algoritmos? Bajo que circunstancias lo utilizar√≠a y ante que situaciones considera que la implementaci√≥n de prioridades podr√≠a no ser de mayor relevancia?

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">


### 9. Inanici√≥n (Starvation)
- `(a)` ¬øQu√© significa?
- `(b)` ¬øCu√°l/es de los algoritmos vistos puede provocarla?
- `(c)` ¬øExiste alguna t√©cnica que evite la inanici√≥n para el/los algoritmos mencionados en b?

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%"

### 10. Los procesos, durante su ciclo de vida, pueden realizar operaciones de I/O como lecturas o escrituras a disco, cintas, uso de impresoras, etc.

El SO mantiene para cada dispositivo, que se tiene en el equipo, una cola de procesos que espera por la utilizaci√≥n del mismo (al igual que ocurre con la Cola de Listos y la CPU, ya que la CPU es un dispositivo mas).

Cuando un proceso en ejecuci√≥n realiza una operaci√≥n de I/O el mismo es expulsado de la CPU y colocado en la cola correspondiente a el dispositivo involucrado en la operaci√≥n.

El SO dispone tambi√©n de un ‚ÄúI/O Scheduling‚Äù que administrada cada cola de dispositivo a trav√©s de alg√∫n algoritmo (FCFS, Prioridades, etc.). Si al colocarse un proceso en la cola del dispositivo, la misma se encuentra vac√≠a el mismo ser√° atendido de manera inmediata, caso contrario, deber√° esperar a que el SO lo seleccione seg√∫n el algoritmo de scheduling establecido.

Los mecanismos de I/O utilizados hoy en d√≠a permiten que la CPU no sea utilizada durante la operaci√≥n, por lo que el SO puede ejecutar otro proceso que se encuentre en espera una vez que el proceso bloqueado por la I/O se coloca en la cola correspondiente.

Cuando el proceso finaliza la operaci√≥n de I/O el mismo retorna a la cola de listos para competir nuevamente por la utilizaci√≥n de la CPU.

Para los siguientes algoritmos de Scheduling:
- FCFS
- Round Robin con quantum = 2 y timer variable.

Y suponiendo que la cola de listos de todos los dispositivos se administra mediante FCFS, realice los diagramas de Gantt seg√∫n las siguientes situaciones:

- `(a)` Suponga que al lote de procesos del ejercicio 6 se agregan las siguientes operaciones de entrada salida:
    | Job | I/O (rec,ins,dur) |
    | --- | --- |
    | 1 | (R1, 2, 1) |
    | 2 | (R2, 3, 1) (R2, 5, 2) |
    | 4 | (R3, 1, 2) (R3, 3, 1) |
- `(b)` Suponga que al lote de procesos del ejercicio 6 se agregan las siguientes operaciones de entrada salida
    | Job | I/O (rec,ins,dur) |
    | --- | --- |
    | 1 | (R1, 2, 3) (R1, 3, 2) |
    | 2 | (R2, 3, 2) |
    | 3 | (R2, 2, 3) |
    | 4 | (R1, 1, 2) |

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%"

### 11. Algunos algoritmos pueden presentar ciertas desventajas cuando en el sistema se cuenta con procesos ligados a CPU y procesos ligados a entrada salida. Analice las mismas para los siguientes algoritmos:
- `(a)` Round Robin
- `(b)` SRTF (Shortest Remaining Time First)

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

### 12. Para equiparar la desventaja planteada en el ejercicio 11), se plantea la siguiente modificaci√≥n al algoritmo:

**Algoritmo VRR** (Virtual Round Robin): Este algoritmo funciona igual que el Round Robin, con la diferencia que cuando un proceso regresa de una I/O se coloca en una cola auxiliar. Cuando se tiene que tomar el pr√≥ximo proceso a ejecutar, los procesos que se encuentra en la cola auxiliar tienen prioridad sobre los otros. Cuando se elije un proceso de la cola auxiliar se le otorga el procesador por tantas unidades de tiempo como le falto ejecutar en su r√°faga de CPU anterior, esto es, se le otorga la CPU por un tiempo que surge entre la diferencia del quantum original y el tiempo usado en la √∫ltima r√°faga de CPU.

- `(a)` Analice el funcionamiento de este algoritmo mediante un ejemplo. Marque en cada instante en que cola se encuentran los procesos.
- `(b)` Realice el ejercicio 10)a) nuevamente considerando este algoritmo, con un quantum de 2 unidades y Timer Variable.

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

### Ejercicio 13

Suponga que un SO utiliza un algoritmo de VRR con Timer Variable para el planificar sus procesos. Para ello, el quantum es representado por un contador, que es decrementado en 1 unidad cada vez que ocurre una interrupci√≥n de reloj. ¬øBajo este esquema, puede suceder que el quantum de un proceso nunca llegue a 0 (cero)? Justifique su respuesta.

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

### Ejercicio 14

El algoritmo SJF (y SRTF) tiene como problema su implementaci√≥n, dada la dificultad de conocer la duraci√≥n de la pr√≥xima r√°faga de CPU. Es posible realizar una estimaci√≥n de la pr√≥xima, utilizando la media de las r√°fagas de CPU para cada proceso.

As√≠, por ejemplo, podemos tener la siguiente formula:

![image](https://user-images.githubusercontent.com/55964635/224461122-9a41d97a-45fe-4b50-8947-7be7b1fc5466.png)

Donde:

- **`Ti`** = duraci√≥n de la r√°faga de CPU i-√©sima del proceso.
- **`Si`** = valor estimado para el i-√©simo caso
- **`Si`** = valor estimado para la primer r√°faga de CPU. No es calculado.

***Enunciados***

- **`(a)`** Suponga un proceso cuyas r√°fagas de CPU reales tienen como duraci√≥n: 6, 4, 6, 4, 13, 13, 13 Calcule que valores se obtendr√≠an como estimaci√≥n para las r√°fagas de CPU del proceso si se utiliza la formula 1, con un valor inicial estimado de S1=10. La formula anterior 1 le da el mismo peso a todos los casos (siempre calcula la media). Es posible reescribir la formula permitiendo darle un peso mayor a los casos mas recientes y menor a casos viejos (o viceversa). Se plantea la siguiente formula: <br><br>
![image](https://user-images.githubusercontent.com/55964635/224461090-3b4464d1-ce37-4cb4-95e9-85e0254596e2.png)
    Con 0 „Äà Œ± „Äà 1.
- `(b)` Analice para que valores de Œ± se tienen en cuenta los casos mas recientes.
- `(c)` Para la situaci√≥n planteada en a) calcule que valores se obtendr√≠an si se utiliza la formula 2 con Œ± = 0,2; Œ± = 0,5 y Œ± = 0,8.
- `(d)` Para todas las estimaciones realizadas en a y c ¬øCu√°l es la que mas se asemeja a las
r√°fagas de CPU reales del proceso?

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

### 15. Colas Multinivel

Hoy en d√≠a los algoritmos de planificaci√≥n vistos se han ido combinando para formar al- goritmos m√°s eficientes. As√≠ surge el algoritmo de Colas Multinivel, donde la cola de procesos listos es divida en varias colas, teniendo cada una su propio algoritmo de planificaci√≥n.

- `(a)` Suponga que se tienen dos tipos de procesos: Interactivos y Batch. Cada uno de estos procesos se coloca en una cola seg√∫n su tipo. ¬øQu√© algoritmo de los vistos utilizar√≠a para administrar cada una de estas colas?.\ A su vez, se utiliza un algoritmo para administrar cada cola que se crea. As√≠, por ejemplo, el algoritmo podr√≠a determinar mediante prioridades sobre que cola elegir un proceso.
- `(b)` Para el caso de las dos colas vistas en a: ¬øQu√© algoritmo utilizar√≠a para planificarlas?

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

### Ejercicio 16

Suponga que en un SO se utiliza un algoritmo de planificaci√≥n de colas multinivel. El mismo cuenta con 3 colas de procesos listos, en las que los procesos se encolan en una u otra seg√∫n su prioridad. Hay 3 prioridades (1 , 2 , 3), donde un menor n√∫mero indica mayor prioridad.

Se utiliza el algoritmo de prioridades para la administraci√≥n entre las colas. 

Se tiene el siguiente lote de procesos a ser procesados con sus respectivas operaciones de I/O:

| Job | Llegada | CPU | I/O (rec,ins,dur) | Prioridad |
| --- | --- | --- | --- | --- |
| 1 | 0 | 9 | (R1, 4, 2) (R2, 6, 3) (R1, 8, 3) | 1 |
| 2 | 1 | 5 | (R3, 3, 2) (R3, 4, 2) | 2 |
| 3 | 2 | 5 | (R1, 4, 1) | 3 |
| 4 | 3 | 7 | (R2, 1, 2) (R2, 5, 3) | 2 |
| 5 | 5 | 5 | (R1, 2, 3) (R3, 4, 3) | 1 |

Suponiendo que las colas de cada dispositivo se administran a trabes de FCFS y que cada cola de procesos listos se administra por medio de un algoritmo RR con un quantum de 3 unidades y Timer Variable, realice un diagrama de Gantt:

- `(a)` Asumiendo que NO hay apropiaci√≥n entre los procesos.
- `(b)` Asumiendo que hay apropiaci√≥n entre los procesos.

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%"

### Ejercicio 17

En el esquema de Colas Multinivel, cuando se utiliza un algoritmo de prioridades para administrar las diferentes colas los procesos pueden sufrir starvation.

La t√©cnica de envejecimiento se puede aplicar a este esquema, haciendo que un proceso cambie de una cola de menor prioridad a una de mayor prioridad, despu√©s de cierto periodo de tiempo que el mismo se encuentra esperando en su cola. Luego de llegar a una cola en la que el proceso llega a ser atendido, el mismo retorna a su cola original.

Por ejemplo: Un proceso con prioridad 3 esta en cola su cola correspondiente. Luego de X unidades de tiempo, el proceso se mueve a la cola de prioridad 2. Si en esta cola es atendido, retorna a su cola original, en caso contrario luego de sucederse otras X unidades de tiempo el proceso de mueve a la cola de prioridad 1. Esta √∫ltima acci√≥n se repite hasta que el proceso obtiene la CPU, situaci√≥n que hace que el mismo vuelva a su cola original.

- `(a)` Para los casos a y b del ejercicio 16 realice el diagrama de Gantt considerando adem√°s que se tiene un envejecimiento de 4 unidades.

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

### 18. La situaci√≥n planteada en el ejercicio 17, donde un proceso puede cambiar de una cola a otra, se la conoce como Colas Multinivel con Realimentaci√≥n.

Suponga que se quiere implementar un algoritmo de planificaci√≥n que tenga en cuenta el tiempo de ejecuci√≥n consumido por el proceso, penalizando a los que m√°s tiempo de ejecuci√≥n tienen. (Similar a la tarea del algoritmo SJF que tiene en cuenta el tiempo de ejecuci√≥n que resta).

Utilizando los conceptos vistos de Colas Multinivel con Realimentaci√≥n indique que colas implementar√≠a, que algoritmo usar√≠a para cada una de ellas as√≠ como para la administraci√≥n de las colas entre s√≠.

Tenga en cuenta que los procesos no deben sufrir inanici√≥n.

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

### 19. Un caso real: ‚ÄúUnix Clasico ‚Äú (SVR3 y BSD 4.3)

Estos sistemas estaban dirigidos principalmente a entornos interactivos de tiempo compartido. El algoritmo de planificaci√≥n estaba dise√±ado para ofrecer buen tiempo de respuesta a usuarios interactivos y asegurar que los trabajos de menor prioridad (en segundo plano) no sufrieran inanici√≥n.

La planificaci√≥n tradicional usaba el concepto de colas multinivel con realimentaci√≥n, utilizando RR para cada uno de las colas y realizando el cambio de proceso cada un segundo (quantum). La prioridad de cada proceso se calcula en funci√≥n de la clase de proceso y de su historial de ejecuci√≥n. Para ello se aplican las siguientes funciones:

![image](https://user-images.githubusercontent.com/55964635/224461659-cd7c343b-607a-4612-846e-88877eceb586.png)

donde:

- CPUj (i) = Media de la utilizaci√≥n de la CPU del proceso j en el intervalo i.
- Pj (i) = Prioridad del proceso j al principio del intervalo i (los valores inferiores indican prioridad m√°s alta).
- Basej = Prioridad base del proceso j.
- Nicej = Factor de ajuste.

La prioridad del proceso se calcula cada segundo y se toma una nueva decisi√≥n de planificaci√≥n. El prop√≥sito de la prioridad base es dividir los procesos en bandas fijas de prioridad. Los valores de CPU y nice est√°n restringidos para impedir que un proceso salga de la banda que tiene asignada. Las bandas definidas, en orden decreciente de prioridad, son:

- Intercambio
- Control de Dispositivos de I/O por bloques
- Gesti√≥n de archivos
- Control de Dispositivos de I/O de caracteres
- Procesos de usuarios

Veamos un ejemplo: Supongamos 3 procesos creados en el mismo instante y con prioridad base 60 y un valor nice de 0. El reloj interrumpe al sistema 60 veces por segundo e incrementa un contador para el proceso en ejecuci√≥n.

Los sectores en celeste representan el proceso en ejecuci√≥n

(a) Analizando la jerarqu√≠a descripta para las bandas de prioridades: ¬øQue tipo de acti-
vidad considera que tendr√° m√°s prioridad? ¬øPor qu√© piensa que el scheduler prioriza
estas actividades?
(b) Para el caso de los procesos de usuarios, y analizando las funciones antes descriptas: \
¬øQu√© tipo de procesos se encarga de penalizar? (o equivalentemente se favorecen). Justifique
(c) La utilizaci√≥n de RR dentro de cada cola: ¬øVerdaderamente favorece al sistema de
Tiempo Compartido? Justifique.

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

### 20. A cu√°les de los siguientes tipos de trabajos:
- `(a)` cortos acotados por CPU
- `(b)` cortos acotados por E/S
- `(c)` largos acotados por CPU
- `(d)` largos acotados por E/S

benefician las siguientes estrategias de administraci√≥n:

- `(a)` prioridad determinada est√°ticamente con el m√©todo del m√°s corto primero (SJF).
- `(b)` prioridad din√°mica inversamente proporcional al tiempo transcurrido desde la √∫ltima operaci√≥n de E/S

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

### 21. Explicar porqu√© si el quantum "q.en Round-Robin se incrementa sin l√≠mite, el m√©todo se aproxima a FIFO

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

### 22. Los sistemas multiprocesador pueden clasificarse en:

- **`Homog√©neos:`** Los procesadores son iguales. Ning√∫n procesador tiene ventaja f√≠sica sobre el resto.
- **`Heterog√©neos:`** Cada procesador tiene su propia cola y algoritmo de planificaci√≥n.

Otra clasificaci√≥n posible puede ser:

- **`Multiprocesador`** d√©bilmente acoplados: Cada procesador tiene su propia memo- ria principal y canales.
- **`Procesadores`** especializados: Existe uno o m√°s procesadores principales de prop√≥- sito general y varios especializados controlados por el primero (ejemplo procesadores de E/S, procesadores Java, procesadores Criptogr√°ficos, etc.).
- **`Multiprocesador`** fuertemente acoplado: Consta de un conjunto de procesadores que comparten una memoria principal y se encuentran bajo el control de un Sistema Operativo

***Preguntas*** 

- **`(a)`** ¬øCon cu√°l/es de estas clasificaciones asocia a las PCs de escritorio habituales?
- **`(b)`** ¬øQu√© significa que la asignaci√≥n de procesos se realice de manera sim√©trica?
- **`(c)`** ¬øQu√© significa que se trabaje bajo un esquema Maestro/esclavo?

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

### 23. Asumiendo el caso de procesadores homog√©neos

- **`(a)`** ¬øCu√°l ser√≠a el m√©todo de planificaci√≥n m√°s sencillo para asignar CPUs a los procesos?
- **`(b)`** Cite ventajas y desventajas del m√©todo escogido

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

### 24. Indique brevemente a que hacen referencia los siguientes conceptos

- **`(a)`** Huella de un proceso en un procesador
- **`(b)`** Afinidad con un procesador
- **`(c)`** ¬øPor qu√© podr√≠a ser mejor en algunos casos que un proceso se ejecute en el mismo procesador?
- **`(d)`** ¬øPuede el usuario en Windows cambiar la afinidad de un proceso? ¬øy en GNU/Linux?
- **`(e)`** Investigue el concepto de balanceo de carga (load balancing).
- **`(f)`** Compare los conceptos de afinidad y balanceo de carga y como uno afecta al otro.

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

### 25. Si a la tabla del ejercicio 6 la modificamos de la siguiente manera: Y considerando que el

| Job | Llegada | CPU | Afinidad |
| --- | --- | --- | --- |
| 1 | 0 | 4 | CPU0 |
| 2 | 2 | 6 | CPU0 |
| 3 | 3 | 4 | CPU1 |
| 4 | 6 | 5 | CPU1 |
| 5 | 8 | 2 | CPU0 |

scheduler de los Sistemas Operativos de la familia Windows utiliza un mecanismo denomi-
nado preferred processor (procesador preferido). El scheduler usa el procesador preferido a
modo de afinidad cuando el proceso esta en estado ready. De esta manera el sheduler asigna
este procesador a la tarea si este est√° libre.

- **`(a)`** Ejecute el esquema anterior utilizando el algoritmo anterior.
- **`(b)`** Ejecute el esquema anterior. Pero ahora si el procesador preferido no est√° libre es asignado a otro procesador. Luego el procesador preferido de cada job es el √∫ltimo enel cual ejecuto.
- **`(c)`** Para cada uno de los casos calcule el tiempo promedio de retorno y el tiempo promedio de espera.
- **`(d)`** ¬øCu√°l de las dos alternativas planteadas es mas performante?

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">


