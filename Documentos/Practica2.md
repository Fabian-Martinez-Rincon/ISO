<h1 align="center"> üìì Practica 2
</h1>

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

<div align="center">

[Siguiente](/Documentos/Practica3.md)<br>
[Anterior](/Documentos/Practica1.md)

</div>

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

El objetivo de esta pr√°ctica es que el alumno comprenda los aspectos principales acerca de la estructura del sistema Operativo GNU/Linux en lo que respecta a procesos, usuarios, filesystems,
permisos, etc


- [1) Editor de textos](#1-editor-de-textos)
- [2) Proceso de Arranque SystemV](#2-proceso-de-arranque-systemv)
- [3) Usuarios](#3-usuarios)
- [4) FileSystem](#4-filesystem)
- [5) Procesos](#5-procesos)
- [6) Otros comandos de Linux](#6-otros-comandos-de-linux-indique-funcionalidad-y-par√°metros)
- [7) Indique qu√© acci√≥n realiza cada uno de los comandos...](#7-ejercicio)
- [8) Indique qu√© comando ser√≠a necesario ejecutar para realizar cada una de las siguientes acciones](#8-indique-qu√©-comando-ser√≠a-necesario-ejecutar-para-realizar-cada-una-de-las-siguientes-acciones)
- [9) Indique qu√© comando ser√≠a necesario ejecutar para realizar cada una de las siguientes acciones](#9-indique-qu√©-comando-ser√≠a-necesario-ejecutar-para-realizar-cada-una-de-las-siguientes-acciones)
- [10) Indique qu√© comando ser√≠a necesario ejecutar para realizar cada una de las siguientes acciones](#10-indique-qu√©-comando-ser√≠a-necesario-ejecutar-para-realizar-cada-una-de-las-siguientes-acciones)
- [11) Indique qu√© acci√≥n realiza cada uno de los comandos indicados a continuaci√≥n....](#11-ejercicio)
- [12) Cree una estructura desde el directorio /home que incluya varios directorios....](#12-ejercicio)
- [13) Indique qu√© comando/s es necesario para realizar cada una de las acciones de la siguiente secuencia de paso](#13-indique-qu√©-comandos-es-necesario-para-realizar-cada-una-de-las-acciones-de-la-siguiente-secuencia-de-pasos-considerando-su-orden-de-aparici√≥n)

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## `1)` Editor de textos:
#### `(a)` Nombre al menos 3 editores de texto que puede utilizar desde la l√≠nea de comandos.

-  **Vim:** Es un editor de texto que rompe las bolas pero aprendes
- **GNU Emacs:** La misma basura que vim pero con calculadora y administrador de archivos
- **mcedit:** Te permite navegar entre los ficheros con una interfaz.

---

#### `(b)` ¬øEn qu√© se diferencia un editor de texto de los comandos cat, more o less? Enumere los modos de operaci√≥n que posee el editor de textos vi.

Los **comandos cat, more y less** permiten mostrar el contenido de ficheros de texto desde la l√≠nea de comandos en sistemas **Unix**. 

En su lugar los **editores de texto**, justamente nos dejan **editar texto** adem√°s de poder **visualizarlo**. 

- `cat` imprimir√° por pantalla el contenido del fichero sin ning√∫n tipo de paginaci√≥n ni posibilidad de modificarlo. B√°sicamente concatena archivos o la salida est√°ndar en la salida est√°ndar. 
- `more` permite visualizar por pantalla el contenido de un fichero de texto, con la diferencia con el anterior de que `more` p√°gina los resultados. Primero mostrar√° por pantalla todo lo que se pueda visualizar sin hacer scroll y despu√©s, pulsando la tecla espacio avanzar√° de igual modo por el fichero. 
- `less` es el m√°s completo de los tres, pues puede hacer todo lo que hace `more` a√±adiendo mayor capacidad de navegaci√≥n por el fichero (avanzar y retroceder) adem√°s de que sus comandos est√°n basados en el editor `vi`, del cual se diferencia en que no tiene que leer todo el contenido del fichero antes de ser abierto.

---

`(c)` Nombre los comandos m√°s comunes que se le pueden enviar al editor de textos vi

- [Comandos basicos](https://docs.oracle.com/cd/E19620-01/805-7644/6j76klopr/index.html)

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## `2)` Proceso de Arranque SystemV:
#### `(a)` Enumere los pasos del proceso de inicio de un sistema GNU/Linux, desde que se prende la PC hasta que se logra obtener el login en el sistema.

- `Paso 1)` Se empieza a ejecutar el c√≥digo del BIOS
- `Paso 2)` El BIOS ejecuta el POST
- `Paso 3)` El BIOS lee el sector de arranque (MBR)
- `Paso 4)` Se carga el gestor de arranque (MBC)
- `Paso 5)` El bootloader carga el kernel y el initrd
- `Paso 6)` Se monta el initrd como sistema de archivos ra√≠z y se inicializan componentes esenciales (ej.: scheduler)
- `Paso 7)` El Kernel ejecuta el proceso init y se desmonta el initrd
- `Paso 8)` Se lee el /etc/inittab
- `Paso 9)` Se ejecutan los scripts apuntados por el ***runlevel 1***
- `Paso 10)` El final del ***runlevel 1*** le indica que vaya al runlevel por defecto
- `Paso 11)` Se ejecutan los scripts apuntados por el runlevel por defecto
- `Paso 12)` El sistema est¬¥a listo para usarse

---

#### `(b)` Proceso INIT. ¬øQui√©n lo ejecuta? ¬øCu√°l es su objetivo?
- Su funci√≥n es cargar todos los subprocesos necesarios para el correcto funcionamiento del SO
- El proceso init posee el PID 1 y se encuentra en **/sbin/init**
- En SysV se lo configura a traves del archivo **/etc/inittab**
- No tiene padre y es el padre de todos los procesos (pstree)
- Es el encargado de montar los filesystems y de hacer disponible los dem¬¥as dispositivos

---

#### `(c)` Ejecute el comando pstree. ¬øQu√© es lo que se puede observar a partir de la ejecuci√≥n de este comando?

El programa pstree facilita informaci√≥n sobre la finalizaci√≥n de una serie de procesos relacionados entre s√≠, esto es, todos los descendientes de un proceso particular. El programa deja claro desde un principio que proceso es el primario y cuales son los secundarios.

---

#### `(d)` RunLevels. ¬øQu√© son? ¬øCu√°l es su objetivo?
- Es el modo en que arranca Linux (3 en Redhat, 2 en Debian)
- El proceso de arranque lo dividimos en niveles
- Cada uno es responsable de levantar (iniciar) o bajar (parar) una serie de servicios
- Un nivel de ejecuci√≥n es b√°sicamente una configuraci√≥n de programas y servicios que se ejecutar√°n orientados a un determinado funcionamiento. 

Explicaci√≥n m√°s detallada

- `Paso 1)` Cuando un sistema GNU/Linux arranca, primero se carga el kernel del sistema, despu√©s se inicia el primer proceso, denominado **init**, que es el responsable de ejecutar y activar el resto del sistema, mediante la gesti√≥n de los niveles de ejecuci√≥n (o **runlevels**).
- `Paso 2)` En el caso del modelo runlevel de SystemV, cuando el proceso init arranca, utiliza un fichero de configuraci√≥n llamado **/etc/inittab** para decidir el modo de ejecuci√≥n en el que va a entrar.
- `Paso 3)` En este fichero se define el runlevel por defecto (initdefault) en arranque (por instalaci√≥n en Fedora el 5, en Debian el 2) y una serie de servicios de terminal por activar para atender la entrada del usuario.
- `Paso 4)` Despu√©s, el sistema, seg√∫n el runlevel escogido, consulta los ficheros contenidos en **/etc/rcn.d**, donde **n** es el n√∫mero asociado al runlevel (nivel escogido), en el que se encuentra una lista de servicios por activar o parar en caso de que arranquemos en el runlevel, o lo abandonemos
- `Paso 5)` Dentro del directorio encontraremos una serie de **scripts** o enlaces a los scripts que controlan el servicio. Cada script posee un nombre relacionado con el servicio, una S o K inicial que indica si es el script para iniciar **(S)** o matar **(K)** el servicio, y un n√∫mero que refleja el orden en que se ejecutar√°n los servicios. 


#### `(e)` ¬øA qu√© hace referencia cada nivel de ejecuci√≥n seg√∫n el est√°ndar? [Fuente](https://www.factor.mx/portal/base-de-conocimiento/niveles-de-ejecucion/)

- **`0`** Indica halt o apagado de la m√°quina.
- **`1`** Indica monousuario.
- **`2`** Indica modo multiusuario sin soporte de red.
- **`3`** Indica modo multiusuario completo con soporte de red.
- **`4`** No usado, con esta opci√≥n el administrador puede personalizar el inicio para cargar alg√∫n servicio.
- **`5`** Indica multiusuario completo con inicio gr√°fico (X11)
- **`6`** Indica shutdown y reboot: Se apaga inmediatamente la m√°quina para reinicio.

Un administrador (root) puede editar el archivo **/etc/inittab** como mejor convenga al usuario, sin embargo tambi√©n tiene el poder de establecerlo en 0 o en 6. Si se establece en 6, algo que hice como experimento en mi Mandriva, la pr√≥xima vez que la m√°quina se encienda, se leer√° el modo 6, shutdown y reboot, y se har√° exactamente eso. 

---

#### ¬øD√≥nde se define qu√© Runlevel ejecutar al iniciar el sistema operativo?

- Se encuentran definidos en **/etc/inittab**
- Los scripts que se ejecutan est√°n en **/etc/init.d**
- En **/etc/rcX.d** (donde X = 0..6) hay links a los archivos del /etc/init.d
- Formato de los links:

```
    [SjK]<orden><nombreScript>
```

- `S)` lanza el script con el argument start
- `K)` lanza el script con el argument stop

---

#### ¬øTodas las distribuciones respetan estos est√°ndares?

No todas las distribuciones respetan los est√°ndares.

---

#### `(f)` Archivo /etc/inittab. ¬øCu√°l es su finalidad?  

Es el archivo de configuraci√≥n de init, que decide el modo de ejecuci√≥n en el que va a entrar.

Cuando el sistema se arranca, se verifica si existe un runlevel predeterminado en el archivo **/etc/inittab**, si no, se debe introducir por medio de la consola del sistema. Despu√©s se procede a ejecutar todos los scripts relativos al runlevel especificado. 

---

#### ¬øQu√© tipo de informaci√≥n se almacena en el? ¬øCu√°l es la estructura de la informaci√≥n que en √©l se almacena?

`/etc/inittab`

**`id:nivelesEjecucion:acci√≥n:proceso`**
- **Id**: identifica la entrada en inittab (1 a 4 caracteres)
- **Niveles_ejecucion**: el/los nivel de ejecuci√≥n en los que se realiza la acci√≥n
- **Acci√≥n**: describe la acci√≥n a realizar
    - **wait**: Se inicia cuando se entra al runlevel e init espera a que termine
    - **initdefault**
    - **ctrlaltdel**: se ejecutar√° cuando init reciba la se√±al SIGINT
    - **off, repawn, once, boot, bootwait, powerwait, otras‚Ä¶**
- **Proceso**: el proceso exacto que ser√° ejecutado

---

#### `(g)` Suponga que se encuentra en el runlevel \<X>. Indique qu√© comando(s) ejecutar√≠a para cambiar al runlevel \<Y>. ¬øEste cambio es permanente? ¬øPor qu√©?

Existen dos formas de modificar los runlevels:

- **a) Cambiar de runlevel en ejecuci√≥n:**
Existe una utilidad para l√≠nea de comandos que permite cambiar de un nivel de ejecuci√≥n a otro. Esta es la herramienta init. Para cambiar de nivel de ejecuci√≥n s√≥lo hay que ejecutar init seguido del n√∫mero del runlevel.\
Por ejemplo
- **` init 0`** Cambia al runlevel 0 (se apaga el sistema, equivalente al comando halt).
- **` init 2`** Cambia al runlevel 2.
- **` init 6`** Cambia al runlevel 6 (reinicia el sistema, equivalente al comando reboot). 

Tambi√©n **`telinit`**, nos permite cambiar de nivel de ejecuci√≥n, s√≥lo tenemos que indicar el n√∫mero. Por ejemplo, necesitamos hacer una tarea cr√≠tica en root; sin usuarios trabajando, podemos hacer un **`tellinit 1`** (tambi√©n puede usarse S) para pasar a runlevel monousuario, y despu√©s de la tarea un tellinit 3 para volver a multiusuario

---

#### **`b) Modificar el runlevel por defecto`**

Por defecto, el sistema suele arrancar en el nivel de ejecuci√≥n 5 (modo gr√°fico). Si se quisiera modificar este comportamiento, habr√≠a que editar el fichero **`/etc/inittab.`**

M√°s concretamente, habr√≠a que modificar en el fichero /etc/inittab la l√≠nea donde el n√∫mero 5 indica que el nivel de ejecuci√≥n por defecto es el 5

No es permanente. En el caso de que el runlevel se cambie durante la secci√≥n de bash abierta y luego se apague la m√°quina, cuando se vuelva a prender la maquina se volver√° a restablecer al modo que tenga el sistema configurado (por defecto).

En el caso de que se quiera cambiar el modo de arranque del runlevel de manera permanente se tendr√° que configurar para que eso suceda. 


```shell
ls /etc/rc0.d
sudo runlevel
sudo telinit 2
```

---

#### `(h)` Scripts RC. ¬øCu√°l es su finalidad?

Los scripts RC se encargan de cargar o cerrar los servicios necesarios para que el sistema funcione, de acuerdo con el runlevel que se est√° iniciando. Por ejemplo: lpd (servicio para imprimir), fetchmail (servicio para leer correo-e), sshd (SecureShell para abrir sesiones remotas de una manera segura), networking (abre las conexiones de red).


---

#### ¬øD√≥nde se almacenan? 

Todos estos servicios se encuentran en **/etc/init.d/**

Sin embargo, no todos los servicios se cargan en todos los runlevels. **¬øC√≥mo sabe el RC que servicios tiene que cargar?** Los servicios a cargar se encuentran en el directorio /etc/rcX.d/, donde X es el runlevel a cargar. En realidad, en estos directorios no hay m√°s que enlaces simb√≥licos a /etc/init.d/

---

#### Cuando un sistema GNU/Linux arranca o se detiene se ejecutan scripts, indique c√≥mo determina qu√© script ejecutar ante cada acci√≥n. ¬øExiste un orden para llamarlos? Justifique.

`Orden para llamarlos:`

Los nombres en estos directorios tienen una sintaxis bastante concreta. Empiezan por una letra (S o K) seguidos de un n√∫mero y el nombre del servicio. La letra S significa iniciar (S de start). La letra K significa acabar (K de kill). El n√∫mero es de dos d√≠gitos, de 00 a 99 e indica el orden en el que se arrancar√° el servicio.

- `1)` Ejecuta, por orden de nombre, todos los scripts que comienzan por **K** en el directorio correspondiente al nivel, utilizando como argumento para dicho script la opci√≥n **stop**.
- `2)` Ejecuta, por orden de nombre, todos los scripts que comienzan por S en el directorio correspondiente al nivel, utilizando como argumento para dicho script la opci√≥n start.

---

### `(i)` ¬øQu√© es insserv? 

El comando **insserv** se usa para controlar el orden de inicio y detenci√≥n de los servicios que se encuentran en un sistema Linux. 

#### ¬øPara qu√© se utiliza?

Se utiliza para administrar el orden de los enlaces simb√≥licos del **`/etc/rcX.d`**, resolviendo las dependencias de forma autom√°tica

- Utiliza cabeceras en los scripts del **`/etc/init.d`** que permiten especificar la relaci√≥n con otros scripts rc -> LSBInit (Linux Standard Based Init)
- Es utilizado por update-rc.d para instalar / remover los links simb√≥licos

#### ¬øQu√© ventajas provee respecto de un arranque tradicional?

Mejora la performance del arranque en sistemas multiprocesadores. 

---

#### `(j)` ¬øC√≥mo maneja Upstart el proceso de arranque del sistema?

Upstart fue el primer reemplazo propuesto para SystemV (Ubuntu, Fedora, Debian, etc.). 

- Permite la ejecuci√≥n de trabajos en forma asincr√≥nica a trav√©s de eventos (event-based) como principal diferencia con sysVinit que es estrictamente sincr√≥nico (dependencybased).
- Estos trabajos se denominan **Jobs**.
- El principal objetivo de un job es definir servicios o tareas a ser ejecutadas por init
- Son scripts de texto plano que definen las acciones/tareas (unidad de trabajo) a ejecutar ante determinados eventos.
- Cada job es definido en el **/etc/init (.conf).**
- Suelen ser de dos tipos:
    - **Task**: ejecuci√≥n finita (task) -> not respawning -> exit 0 o uso de stop.
    - **Service**: ejecuci√≥n indeterminada ÔÉ† respawning
- Los jobs son ejecutados ante eventos (arranque del equipo, inserci√≥n de un dispositivo USB,etc)
    - Es posible crear eventos pero existen algunos de manera est√°ndar.
    - Definido por **start on y stop on.**
- Es compatible con SystemV ! **/etc/init/rc-sysinit.conf**, runlevels, scripts en /etc/init.d, objetivo start y stop. 
- Cada job posee un objetivo (goal start/stop) y un estado (state). 
    - En base a ellos se ejecuta un proceso espec√≠fico.
    - Al inicio, init emite el evento startup. 
- Un job puede tener uno o varias tareas ejecutables como parte de su ciclo de vida y siempre debe existir la tarea principal
- Las tareas de un job se definen mediante exec o script ... end script
- A trav√©s de **initctl** podemos administrar los jobs del demonio de Upstart: 
- **`start <job>`**: cambia el objetivo a start del job especificado
- **`stop <job>`**: cambia el objetivo a stop del job especificado
- **`emit <event>`**: event es emitido causando que otros Jobs cambien a objetivo start o stop 
- No m√°s **/etc/inittab**



---

#### `(k)` Cite las principales diferencias entre SystemV y Upstart.

Upstart se cre√≥ como reemplazo del modelo SysVinit. A diferencia de SysVinit, que se cre√≥ para operar en un entorno est√°tico Upstart se cre√≥ para operar en un entorno flexible.

Upstart proporciona beneficios principales sobre el SysVinit. Estos beneficios son: event-based (principal diferencia con SysVinit que es estrictamente sincr√≥nico - dependecy-based -) es la ejecucion de servicios en forma asincr√≥nica y otro beneficio es el reinicio autom√°tico de servicios que dejan de responder de la manera inesperada para el sistema.

Upstart en lugar de usar runlevels, usa jobs que cada uno de ellos posee un objetivo (start/stop y un estado state). Cuando ocurre una interrupci√≥n, upstart detecta ese interrupci√≥n y realiza los cambios necesarios. 


---

#### `(l)` Qu√© reemplaza a los scripts rc de SystemV en Upstart? ¬øEn que ubicaci√≥n del filesystem se encuentran?

- Los **`jobs`** reemplazan a los scripts de SystemV en Upstart.
- Cada job es definido en el **`/etc/init (.conf)`**

---

#### `(m)` Dado el siguiente job de upstart perteneciente al servicio de base de datos del mysql indique a qu√© hace referencia cada l√≠nea del mismo:

```powershell
# MySQL Servise
description "MySQL Server " {Descripcion}
autor "info autor" {Autor}
start on ( net ‚àí device ‚àí up {Iniciar base de datos}
        and local ‚àífilesystems   {}
        and runlevel [2345])
stop on runlevel [016]
[...]
exec / usr / sbin /mysqld
[...]
```

Este es un archivo de configuraci√≥n Upstart para el servicio de base de datos MySQL. Cada l√≠nea se explica a continuaci√≥n:

- MySQL Service: un comentario que describe el servicio que se va a iniciar.
- description "MySQL Server": una descripci√≥n del servicio, que aparecer√° en los registros del sistema. {Descripcion}
- author "info autor": informaci√≥n sobre el autor del archivo de configuraci√≥n. {Autor}
- start on (net-device-up and local-filesystems and runlevel [2345]): indica que el servicio debe iniciarse cuando la red y el sistema de archivos locales est√©n disponibles y el sistema se est√© ejecutando en el nivel de ejecuci√≥n 2, 3, 4 o 5. {Iniciar base de datos}
- stop on runlevel [016]: indica que el servicio debe detenerse cuando el sistema se est√© ejecutando en el nivel de ejecuci√≥n 0, 1 o 6.
- exec `/usr/sbin/mysqld`: la l√≠nea que indica al sistema qu√© comando ejecutar para iniciar el servicio MySQL. El comando `/usr/sbin/mysqld` es el comando para iniciar el servidor de base de datos MySQL.

---

#### `(n)` ¬øQu√© es sytemd?

- Es un sistema que centraliza la administraci√≥n de demonios y librerias del sistema.
- Puede ser controlado por `systemctl`
- Compatible con SysV -> si es llamado como `init`
- El demonio systemd reemplaza al proceso init -> este pasa a terner PID 1
- Los runlevels son reemplazados por `targets`
- Al igual que con Upstart el archivo `/etc/inittab` no existe m√°s. 

---

#### `(√±)` ¬øA qu√© hace referencia el concepto de activaci√≥n de socket en systemd?

Las unidades de trabajo son denominadas units de tipo:

Service: controla un servicio particular (.service)

- **`Socket`** encapsula IPC, un sockect del sistema o file system FIFO (.socket) -> sockect-based activation.
- **`Target`** agrupa units o establece puntos de sincronizaci√≥n durante el booteo (.target)
- **`dependencia`** de unidades
- **`Snapshot`** almacena el estado de un conjunto de unidades que puede ser establecido m√°s tarde (.snapshot) etc. 

Las **units** pueden tener dos estados -> **active** o **inactive** 


 ---

#### `(o)` ¬øA qu√© hace referencia el concepto de cgroup?

Permite organizar un grupo de procesos en forma jer√°rquica

Agrupa conjunto de procesos relacionados (por ejemplo, un servidor web Apache con sus dependientes).

Tareas que realiza:

- Tracking mediante subsistema cgroups ÔÉ† no se utiliza el PID ÔÉ† doble fork no funciona para escapar de systemd.
- Limitar el uso de recursos. 

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## `3)` Usuarios

#### `(a)` ¬øQu√© archivos son utilizados en un sistema GNU/Linux para guardar la informaci√≥n de los usuarios?

En un sistema GNU/Linux, la informaci√≥n de los usuarios se almacena principalmente en los siguientes archivos:

- **`/etc/passwd`** Este archivo contiene informaci√≥n b√°sica de los usuarios, como sus nombres de usuario, identificaci√≥n de usuario (UID), identificaci√≥n de grupo (GID), nombre completo, ruta del directorio de inicio y shell predeterminada.
- **`/etc/shadow`** Este archivo contiene informaci√≥n confidencial de los usuarios, como sus contrase√±as encriptadas, tiempo de √∫ltima modificaci√≥n de la contrase√±a, tiempo de expiraci√≥n, cuenta bloqueada, etc.
- **`/etc/group`** Este archivo contiene informaci√≥n de los grupos de usuarios, como el nombre del grupo, identificaci√≥n de grupo (GID) y una lista de nombres de usuario que pertenecen a ese grupo.
- **`/etc/gshadow`** Este archivo contiene informaci√≥n confidencial de los grupos de usuarios, como sus contrase√±as encriptadas, tiempo de √∫ltima modificaci√≥n de la contrase√±a, tiempo de expiraci√≥n, cuenta bloqueada, etc.

Es importante destacar que estos archivos son de lectura y escritura solo para el superusuario (root) y que modificarlos sin conocimiento puede comprometer la seguridad del sistema.

---

#### `(b)` ¬øA qu√© hacen referencia las siglas UID y GID? ¬øPueden coexistir UIDs iguales en un sistema GNU/Linux? Justifique.

Los sistemas operativos Linux y Unix utilizan el UID (User ID o ID de usuario) para identificar al usuario particular. El GID (Group ID o ID de grupo) se utiliza para identificar a un grupo. Supongo que no podrian existir dos iguales ya que no los podrias distinguir.

Puede haber un caso que seria el root en el que podemos tener varios usuarios root con el ID 0

---

#### `(c)` ¬øQu√© es el usuario root? ¬øPuede existir m√°s de un usuario con este perfil en GNU/Linux? ¬øCu√°l es la UID del root?.

En sistemas operativos del tipo Unix, el superusuario o root es el nombre
convencional de la cuenta de usuario que posee todos los derechos en todos los
modos (monousuario o multiusuario). Normalmente es la cuenta de administrador. 

- Su UID (User ID) y GID es 0 (cero).
- Es la √∫nica cuenta de usuario con privilegios sobre todo el sistema.
- Acceso total a todos los archivos y directorios con independencia de propietarios y permisos.
- Controla la administraci√≥n de cuentas de usuarios.
- Ejecuta tareas de mantenimiento del sistema.
- Puede detener el sistema.
- Instala software en el sistema.
- Puede modificar o reconfigurar el kernel, controladores, etc. 


---

#### `(d)` Agregue un nuevo usuario llamado iso2017 a su instalaci√≥n de GNU/Linux, especifique que su home sea creada en /home/iso_2017, y h√°galo miembro del grupo catedra (si no existe, deber√° crearlo). Luego, sin iniciar sesi√≥n como este usuario cree un archivo en su home personal que le pertenezca. Luego de todo esto, borre el usuario y verifique que no queden registros de √©l en los archivos de informaci√≥n de los usuarios y grupos.

- `sudo adduser iso2022` creo un usuario y en home le agrego /home/ (contra = nombre para pruebas)
- `sudo gropadd catedra` creo un grupo 
- `sudo usermod -a -G catedra iso2022`
- `id -nG iso2022` menciona los grupos a los que pertenece mi usuario
- `sudo login iso2022` entro como el usuario
- `cd ..` para ir a la home personal y crear un archivo (creo)
- `sudo userdel iso2022` lo elimina pero aun tenemos todos los archivos creados por este

---

#### `(e)` Investigue la funcionalidad y par√°metros de los siguientes comandos:
- **`useradd nombre √≥ adduser nombre`** Crea un nuevo usuario
- **`usermod nombre`** nos permite modificar todos los par√°metros de la cuenta de un usuario creado con anterioridad.
- **`userdel nombre`** Elimina un usuario
- **`su`** entrar al super usuario (tenes los permisos de TODO)
- **`groupadd nombre`** te deja crear un grupo
- **`who`** Verifiqua los usuarios conectado al sistema
- **`groupdel nombre`** elimina un grupo
- **`passwd`** de deja cambiar la constrase√±a del usuario actual

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## `4)` FileSystem:

#### `(a)` ¬øC√≥mo son definidos los permisos sobre archivos en un sistema GNU/Linux?

Este mecanismo permite que archivos y directorios ‚Äúpertenezcan‚Äù a un usuario en particular. Por ejemplo, como diego cre√≥ archivos en su directorio ‚Äúhome‚Äù, diego es el propietario de esos archivos y tiene acceso total a ellos. 

Unix tambi√©n permite que los archivos sean compartidos entre usuarios y grupos de usuarios. Si diego lo desea, podr√≠a restringir el acceso a sus archivos de forma que ning√∫n otro usuario pueda acceder a ellos. 

Los **permisos est√°n divididos en tres tipos: `lectura`, `escritura` y `ejecuci√≥n`**. Estos permisos pueden ser fijados para tres clases de usuarios: el propietario del archivo o directorio, los integrantes del grupo al que pertenece y todos los dem√°s usuarios. 

- **`lectura`** permite a un usuario leer el contenido del archivo o en el caso de un directorio, listar el contenido del mismo (usando ls).
- **`escritura`** permite a un usuario escribir y modificar el archivo (inclusive, eliminarlo). Para directorios, el permiso de escritura permite crear nuevos archivos o borrar archivos ya existentes en el mismo.
- **`ejecuci√≥n`** permite a un usuario ejecutar el archivo si es un programa. Para directorios, el permiso de ejecuci√≥n permite al usuario ingresar al mismo (por ejemplo, con el comando cd). 
- **`Interpretando los permisos de archivos`** Veamos un ejemplo del uso de permisos de archivos. Usando el comando ls con la opci√≥n **`-l`** se mostrara un listado **`largo`** de los archivos, el cual incluye los permisos. <br><br>
    ```
    fabrizio@debian: /$ ls -l
    -rwxr-xr-- 1 fabrizio users 505 May 5 19:05 prueba.exe
    ```

El primer campo representa los permisos del archivo. El tercer campo es el propietario del mismo (fabrizio), el cuarto es el grupo al cual pertenece el archivo (users) y el √∫ltimo campo es el nombre del archivo (prueba.exe). 

La cadena **`-rwxr-xr--`** nos informa, por orden, los permisos para el propietario, los usuarios del grupo y el resto de los usuarios.

El primer car√°cter de la cadena de permisos `(‚Äú-‚Äù)` representa el tipo de archivo. El `‚Äú-‚Äù` significa que es un archivo regular, `‚Äúd‚Äù` indicar√≠a que se trata de un directorio. Los siguientes tres caracteres `(‚Äúrwx‚Äù)` representan los permisos para el propietario del archivo, fabrizio. √âste tiene permisos para leer `(r)`, escribir `(w)` y ejecutar `(x)` el archivo prueba.exe.

Los siguientes tres caracteres, `‚Äúr-x‚Äù`, representan los permisos para los miembros del grupo al que pertenece el archivo (en este caso, users). Como s√≥lo aparece `‚Äúr-x‚Äù` cualquier usuario que pertenezca al grupo users puede leer este archivo, y ejecutarlo, pero no modificarlo.

Los √∫ltimos tres caracteres, `‚Äúr--‚Äù`, representan los permisos para cualquier otro usuario del sistema (que no sea fabrizio ni pertenezca al grupo users). Como s√≥lo est√° presente la `‚Äúr‚Äù`, los dem√°s usuarios pueden leer el archivo, pero no escribir en √©l o ejecutarlo

Aqu√≠ tenemos otros ejemplos de permisos de grupo

- **`-rw-------`**
- El propietario del archivo puede leer y escribir. Nadie m√°s puede acceder al archivo.
- **`rwxrwxrwx`**
- Todos los usuarios pueden leer, escribir y ejecutar el archivo. 
- **`drwxr-xr-x`**
- El propietario del directorio puede leer, escribir y entrar al mismo. Los usuarios pertenecientes al grupo del directorio y todos los dem√°s usuarios pueden leer e ingresar al directorio.

---

#### `(b)` Investigue la funcionalidad y par√°metros de los siguientes comandos relacionados con los permisos en GNU/Linux:
- **chmod:** nos permite gestionar permisos
- **chown:** permite cambiar el propietario de un archivo o directorio en sistemas
- **chgrp:** nos permite cambiar el grupo al que pertenece un archivo

#### `(c)` Al utilizar el comando chmod generalmente se utiliza una notaci√≥n octal asociada para definir permisos. ¬øQu√© significa esto? ¬øA qu√© hace referencia cada valor?

Existen 3 tipos de permisos y se basan en una notacion octal para referenciar a cada uno:

| Permiso  | Valor | Octal |
| ------------- | ------------- | ------------- |
| Lectura  | R  | 4 |
| Escritura  | W  | 2 |
| Ejecucion  | X  | 1 |

Se aplican sobre los usuarios:

- Usuarios: permisos del due√±o -> `U`
- Usuarios: permisos del grupo -> `G`
- Usuarios: permisos de otro usuario -> `O`


La notaci√≥n octal se refiere a ver estos valores en 3 bits , 010 equivale a 2 , por lo tanto si un archivo tendr√° solo permisos de escritura, figura de esa manera. Si los valores fueran 110= serian permisos de lectura y escritura, y si fueran 111 el archivo tendr√≠a todos los permisos (lectura escritura y ejecuci√≥n). 

- En general cuando se le da un permiso a un archivo requiere 3 n√∫meros (ejemplo **`chmod 755`**) cada uno de esos n√∫meros representa los permisos para diferentes cosas.
- El primer n√∫mero es para indicar los permisos para el due√±o del archivo (**`U`**).
- El segundo n√∫mero es para indicar los permisos para los usuarios del grupo de un archivo (**`G`**)
- El tercer n√∫mero es para indicar los permisos para todo el resto de los usuarios (**`O`**). 

Por lo tanto, en el ejemplo **`chmod 755`**, indica que el **`due√±o (U)`** tiene permiso para lectura, escritura y ejecuci√≥n ( 4 + 2 + 1 = 7). Los **`usuarios del grupo (G)`** y para el **`resto de los usuarios (O)`** tienen permiso para lectura y ejecuci√≥n (4 + 1= 5). Ver tabla.

---

#### `(d)` ¬øExiste la posibilidad de que alg√∫n usuario del sistema pueda acceder a determinado archivo para el cual no posee permisos? Nombrelo, y realice las pruebas correspondientes.


Existe la posibilidad, si es que el usuario puede utilizar el comando su, o sudo. Sino, sin poseer los permisos necesarios no puede acceder al archivo. S√≥lo root.

---

#### `(e)` Explique los conceptos de ‚Äúfull path name‚Äù y ‚Äúrelative path name‚Äù. De ejemplos claros de cada uno de ellos.

- **`Full path name`** es la ruta completa a ese archivo o carpeta desde el directorio / del sistema de archivos. ejemplo `/home/your_username/my_script`
- **`Relative path name`** Rastrea la ruta desde el directorio actual a trav√©s de su padre o sus subdirectorios y archivos. ..\Documents

---

#### `(f)` ¬øCon qu√© comando puede determinar en qu√© directorio se encuentra actualmente? ¬øExiste alguna forma de ingresar a su directorio personal sin necesidad de escribir todo el path completo? ¬øPodr√≠a utilizar la misma idea para acceder a otros directorios? ¬øC√≥mo? Explique con un ejemplo.

- Con el comando pwd podemos saber el directorio actual.
- Con `cd`o `cd ~` vamos al directorio personal.
- Se puede usar este mismo comando para acceder a directorios a partir de la ruta en donde estemos parados

Se podr√≠a acceder a diferentes directorios gracias la ubicaci√≥n relativa o atajos ya prestablecidos como `cd ..` para volver al directorio anterior sin necesidad de poner ning√∫n atajo

---

#### `(g)` Investigue la funcionalidad y par√°metros de los siguientes comandos relacionados con el uso del FileSystem:

- **`cd`** Nos permite meternos en un directorio interno
- **`umount`** permite eliminar un sistema de archivos remoto que est√© montando en la actualidad (no usar xd)
- **`mkdir`** Cree una carpeta
- **`du`** Para ver el tama√±o de ficheros y carpetas
- **`rmdir`** Borrar directorios
- **`df`** Informa la cantidad de espacio libre en disco
- **`mount`** Se utiliza para montar dispositivos y particiones para su uso por el sistema operativo (se instala con **sudo apt install nfs-common**)
- **`ln`** crear un enlace simb√≥lico al fichero o directorio (como un acceso directo)
- **`ls`** Lista el contenido del directorio actual
- **`pwd`** Visualiza la ruta donde estoy situado
- **`cp`** sirve para copiar archivos y directorios dentro del sistema de archivos
- **`mv`** se utiliza para mover o renombrar los archivos y directorios

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## `5)` Procesos

#### `(a)` ¬øQu√© es un proceso? ¬øA que hacen referencia las siglas PID y PPID? ¬øTodos los procesos tienen estos atributos en GNU/Linux? Justifique. Indique qu√© otros atributos tiene un proceso.

Un proceso es un programa en ejecuci√≥n. Para nosotros ser√°n sin√≥nimos de tarea, job y proceso.
- Es din√°mico
- Tiene program counter.
- Su ciclo de vida comprende desde que se lo **`dispara`** hasta que termina.

La sigla `PID` hace referencia al `ID` del Proceso y la sigla `PPID` hace referencia al `ID` del Proceso Padre del proceso.

Todos los procesos tienen estos atributos, adem√°s de estos (que son los m√°s importantes pero no todos): Usuario (`UID`), Grupo (`GID`), Prioridad, etc. Con ps ‚ÄìejH

PUEDO VER EL PPID.

----

#### `(b)` Indique qu√© comandos se podr√≠an utilizar para ver qu√© procesos est√°n en ejecuci√≥n en un sistema GNU/Linux.

- **`pstree`** que nos muestra los procesos en una estructura de √°rbol top El comando top te permite ver las tareas del sistema que se ejecutan en tiempo real.
- **`top`** El comando top te permite ver las tareas del sistema que se ejecutan en tiempo real.Proporciona un buen resumen de tu sistema para verificar r√°pidamente si algo se destaca que pueda estar causando problemas con tu sitio web o servidor
- **`ps`** muestra por pantalla un listado de los procesos que est√°n ejecut√°ndose en el sistema.

Las opciones (par√°metros) m√°s importantes y utilizadas de este comando son:
- **`a`** para mostrar los procesos de todos los teminales.
- **`u`** para mostrar el usuario al que pertenece el proceso y la hora de inicio.
- **`x`** para mostrar procesos que no estan controlados por ning√∫n terminal.

Suelen usarse combiandas para tener una visi√≥n global de los procesos que est√°n en ejecutan.

---

#### `(c)` ¬øQu√© significa que un proceso se est√° ejecutando en Background? ¬øY en Foreground?

- **`Proceso ejecut√°ndose en Background`** significa que el proceso contin√∫a la ejecuci√≥n mientras que el shell se libera para otras actividades. **`Proceso en segundo plano`**.
- **`Proceso ejecut√°ndose en Foreground`** Es exactamente lo contrario, quiere decir que no se admitir√° ning√∫n otro comando hasta que se complete el proceso. **`Proceso en primer plano`**.

---

#### `(d)` ¬øC√≥mo puedo hacer para ejecutar un proceso en Background? ¬øComo puedo hacer para pasar un proceso de background a foreground y viceversa?

Para ejecutar un proceso en background en Linux, se puede agregar el s√≠mbolo "&" al final del comando en la l√≠nea de comandos. Por ejemplo, para ejecutar un proceso llamado "mi_proceso" en background, se puede escribir:

```bash
mi_proceso &
```

Esto permitir√° que el proceso se ejecute en segundo plano mientras se sigue usando la terminal para ejecutar otros comandos.

Para pasar un proceso de background a foreground y viceversa, se pueden usar los siguientes comandos:

- **`fg`** mueve un proceso en background a foreground. Se debe proporcionar el n√∫mero de trabajo (job number) del proceso como argumento. El n√∫mero de trabajo se puede obtener con el comando "jobs". Por ejemplo: <br><br>
    ```bash
    fg %1
    ```
    Esto mueve el proceso n√∫mero 1 en background al foreground.
- **`bg`** mueve un proceso en foreground a background. Tambi√©n se debe proporcionar el n√∫mero de trabajo del proceso como argumento. Por ejemplo:
    ```bash
    bg %1
    ```
    Esto mueve el proceso n√∫mero 1 en foreground a background.

Tambi√©n se puede suspender un proceso en foreground con la combinaci√≥n de teclas `Ctrl + Z`. Esto detendr√° el proceso y lo mover√° a background. Para reanudar el proceso en background, se puede usar el comando `bg`

---

#### `(e)` Pipe ( | ). ¬øCu√°l es su finalidad? Cite ejemplos de su utilizaci√≥n.

 El **`|`** nos permite comunicar dos procesos por medio de un pipe o tuber√≠a desde la shell

El pipe conecta stdout (salida est√°ndar) del primer comando con la stdin (entrada est√°ndar) del segundo.

Por ejemplo:

```
ls | more
```

- Se ejecuta el comando ls y la salida del mismo, es enviada como entrada del comanda **`more`**. 
- Se pueden anidar tantos pipes como se deseen

¬øC√≥mo har√≠amos si quisi√©ramos contar la cantidad de usuarios del sistema que en su
nombre de usuario aparece una letra ‚Äúa"?

```shell
cat /etc/passwd | cut -d: -f1 | grep a | wc ‚Äìl
```

---

#### `(f)` Redirecci√≥n. ¬øQu√© tipo de redirecciones existen? ¬øCu√°l es su finalidad? Cite ejemplos de utilizaci√≥n.

En Linux, al final todo es tratado como si fuera un fichero y como tal, tenemos descriptores de fichero para aquellos puntos donde queramos acceder.

Hay unos descriptores de fichero por defecto:
- **`0`** Entrada est√°ndar (normalmente el teclado).
- **`1`** Salida est√°ndar (normalmente la consola).
- **`2`** Salida de error. 

Para redirigir las salidas utilizaremos el descriptor de fichero seguido del s√≠mbolo > o < si redirigimos la entrada hacia un comando. Veamos unos ejemplos

- **`ls -l > fichero`** Guarda la salida de ls -l en fichero. Si no existe lo crea, y si existe lo sobreescribe.
- **`ls -l >> fichero`** A√±ade la salida del comando a fichero. Si no existe lo crea, y si existe, lo a√±ade al final.
- **`ls -l 2 > fichero`** Si hay alg√∫n error, lo guarda en fichero (podr√≠a salir un error si no tuvi√©ramos permiso de lectura en el directorio). 


Las¬†**redirecciones** consisten en trasladar informaci√≥n de un tipo a otro

Hay 2 tipos de redirecciones 

- Al utilizar redirecciones mediante > (destructiva):
    - Si el archivo de destino no existe, se lo crea
    - Si el archivo existe, se lo trunca y se escribe el nuevo contenido
- Al utilizar redirecciones mediante >> (no destructiva):
    - Si el archivo de destino no existe, se lo crea
    - Si el archivo existe, se agrega la informaci√≥n al final

EJEMPLOS

>  Redirecciona **stdout** hac√≠a un archivo. Lo crea si no existe, si existe lo sobreescribe.
```
ls -l > lista.txt
```

>> (La salida del comando se env√≠a a un archivo en vez de la terminal.)

Redirecciona **stdout** hac√≠a un archivo. Lo crea si no existe, si existe concatena la salida al final de este.

```
ps -ef >> processos.txt
```
(Concatena al archivo procesos.txt la salida del comando.)

Es importante ver que si no se especifica el descriptor de fichero se asume que se redirige la salida est√°ndar. En el caso del operador `<` se redirige la entrada est√°ndar, es decir, el contenido del fichero que especific√°ramos, se pasar√≠a como par√°metro al comando.

Si quisi√©ramos redirigir todas las salidas a la vez hacia un mismo fichero, podr√≠amos utilizar **`>&`**.

Adem√°s, con el car√°cter `&` podemos redirigir salidas de un tipo hacia otras, por ejemplo, si quisi√©ramos redirigir la salida de error hacia la salida est√°ndar podr√≠amos indicarlo con: **`2>&1`**. Es importante tener en cuenta que el orden de las redirecciones es significativo: se ejecutar√°n de izquierda a derecha.

---

#### `(g)` Comando kill. ¬øCu√°l es su funcionalidad? Cite ejemplos.

El comando **`kill`** en Linux (ubicado en / bin / kill), es un comando incorporado que se usa para terminar los procesos manualmente. El comando kill env√≠a una se√±al a un proceso que termina el proceso. Si el usuario no especifica ninguna se√±al que se enviar√° junto con el comando kill, se env√≠a la se√±al TERM predeterminada que finaliza el proceso.

- **`kill -l`** Para mostrar todas las se√±ales disponibles, puede usar la siguiente opci√≥n de comando.
- **`kill pid`** Para mostrar c√≥mo usar un PID con el comando kill.
- **`kill -s`** Para mostrar c√≥mo enviar se√±ales a los procesos.
- **`kill -L`** este comando se usa para listar las se√±ales disponibles en un formato de tabla. 

---

#### `(h)` Investigue la funcionalidad y par√°metros de los siguientes comandos relacionados con el manejo de procesos en GNU/Linux. Adem√°s, comp√°relos entre ellos:

- **ps:** Muestra informaci√≥n de los procesos activos.
- **kill:** Usa el PID para matar el proceso. Permite interactuar con cualquier proceso mandando se√±ales. Kill `<pid>` termina un proceso y Kill -9 `<pid>` fuerza a terminar un proceso en caso de que la anterior opci√≥n falle. 
- **pstree:** muestra un √°rbol de procesos.
- **killall:** nos permite matar un proceso escribiendo su nombre
- **top:** Sirve para ver los procesos de ejecuci√≥n del sistema (y m√°s cosas) en tiempo real
- **nice:** Ejecuta un comando con una prioridad determinada, o modifica la prioridad a de un proceso. `nice -10 named` Esto bajar√≠a la prioridad de named en 10 unidades(Si estaba en -10, pasar√° a - 20) `MENOS GENTIL = MAS PRIORIDAD`

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## `6)` Otros comandos de Linux (Indique funcionalidad y par√°metros)

#### `(a)` ¬øA qu√© hace referencia el concepto de empaquetar archivos en GNU/Linux?

Los archivos `TAR` no son archivos comprimidos sino empaquetados. `TAR` es un empaquetador, es algo m√°s parecido a un compresor como `arj` √≥ `zip` pero sin compresi√≥n. Su funci√≥n es la de incluir todos los ficheros juntos en el mismo archivo, conservando las estructuras de directorios y permisos de los mismos. 

- **``crear``** un archivo .tar <br><br> 
    ```shell
    tar ‚Äìcvf mi_archivo.tar /directorio/a/empaquetar 
    ```
- **``extraer``** el contenido de un archivo .tar ya creado <br><br> 
    ```shell
    tar ‚Äìxvf mi_archivo.tar
    ```
- **`actualizar`** el contenido de un archivo .tar ya existente <br><br> 
    ```shell
    tar ‚Äìuvf mi_archivo.tar
    ```
- **`agregar`** un directorio a un archivo .tar ya existente <br> <br> 
    ```shell
    tar ‚Äìrvf archivo. tar  directorio/a/agregar
    ```
- **`empaquetar`** y comprimir el archivo .tar <br><br> 
    ```shell
    tar ‚Äìcvzf archivo.tgz /directorio/a/empaquetar/y/comprimir
    ```
- **`desempaquetar`** el archivo .tgz <br><br>
    ```shell
    tar ‚Äìxvzf archivo.tgz
    ```
- Ojo : Observa la extensi√≥n ".tgz" para el tar comprimido. Aunque tambi√©n podemos ponerle como extensi√≥n ".tar.gz"

---

#### `(b)` Seleccione 4 archivos dentro de alg√∫n directorio al que tenga permiso y sume el tama√±o de cada uno de estos archivos. Cree un archivo empaquetado conteniendo estos 4 archivos y compare los tama√±os de los mismos. ¬øQu√© caracter√≠stica nota?

Claro, para sumar el tama√±o de cuatro archivos en Linux y crear un archivo empaquetado que los contenga, puede seguir los siguientes pasos:

- Abrir una terminal y navegar hasta el directorio que contiene los cuatro archivos usando el comando `cd`.
- Para sumar el tama√±o de los cuatro archivos, use el comando <br> <br>
    ```shell
    du -sh file1 file2 file3 file4
    ```
    Esto le dar√° la suma total de los tama√±os de los cuatro archivos.
- Para crear un archivo empaquetado que contenga los cuatro archivos, puede utilizar el comando 
    ```shell
    tar -cvzf archivo_empaquetado.tar.gz file1 file2 file3 file4
    ```
    Esto crear√° un archivo empaquetado llamado `archivo_empaquetado.tar.gz` que contiene los cuatro archivos.
- Para comparar los tama√±os de los cuatro archivos individuales y el archivo empaquetado, use el comando `ls -lh`. Esto mostrar√° el tama√±o de cada archivo en una lista. Compare el tama√±o total de los cuatro archivos individuales con el tama√±o del archivo empaquetado para notar la diferencia en el tama√±o.


Es importante tener en cuenta que el comando `tar` utiliza la compresi√≥n para reducir el tama√±o del archivo empaquetado, por lo que es posible que el tama√±o del archivo empaquetado sea menor que la suma total de los tama√±os de los cuatro archivos individuales.

---

#### `(c)` ¬øQu√© acciones debe llevar a cabo para comprimir 4 archivos en uno solo? Indique la secuencia de comandos ejecutados.

Teniendo en cuenta que tenemos 4 archivos en el directorio Descargas/ejercicio6 y nos situamos en Descargas ejecutamos lo siguiente

```shell
tar cvfz archivo.tar.gz ejercicio6
```
Esto nos dejaria un archivo empaquetado de archivos comprimidos en un solo archivo archivo.tar.gz y para acceder a dicha informacion haremos

```powershell
tar xvfz archivo.tar.gz
```

---

#### `(d)` ¬øPueden comprimirse un conjunto de archivos utilizando un √∫nico comando?

Si los archivos est√°n en el mismo directorio utilizamos el comando visto anteriormente


----

#### `(e)` Investigue la funcionalidad de los siguientes comandos:

- **`tar`** Empaqueta/desempaqueta varios archivos en uno solo, puede realizar compresi√≥n sin perdida
- **`grep`** El comando grep nos permite buscar cadenas de texto y palabras dentro de un fichero de texto o de la entrada est√°ndar de la terminal. Una vez encontrado el contenido que estamos buscando: 
    grep mostrar√° en pantalla la totalidad de la l√≠nea/s que contiene/n la cadena de texto o palabra que estamos buscando
- **`gzip`** Comprime solo archivos utilizando la extensi√≥n .gz que se utiliza para truncar el tama√±o de un archivo.
- **`zgrep`** Se usa para buscar expresiones de un archivo dado, incluso si est√° comprimido
- **`wc`** Cuenta los caracteres, palabras y l√≠neas del archivo de texto.

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## `7)` Ejercicio

Enunciado: Indique qu√© acci√≥n realiza cada uno de los comandos indicados a continuaci√≥n considerando su orden. Suponga que se ejecutan desde un usuario que no es root ni pertenece al grupo de root. (Asuma que se encuentra posicionado en el directorio de trabajo del usuario con el que se logue√≥). En caso de no poder ejecutarse el comando, indique la raz√≥n

```shell
l s ‚àíl > prueba {No se puede acceder a pruebas pq no existe el fichero}                         
ps > PRUEBA 
chmod 710 prueba
chown root : root PRUEBA
chmod 777 PRUEBA 
chmod 700 / etc / passwd 
passwd root 
rm PRUEBA 
man / etc / shadow 
find / ‚àíname ‚àó .conf 
usermod root ‚àíd /home/ newroot ‚àíL 
cd / root 
rm ‚àó 
cd / etc 
cp ‚àó /home ‚àíR 
shutdown 
```

- `ls -l > prueba` Genera un archivo de nombre prueba que contiene un listado detallado con los contenidos del directorio home del usuario. Se redirige la salida est√°ndar de ls mediante el car√°cter > hacia el archivo prueba.
- `ps > PRUEBA` Genera un archivo de nombre PRUEBA que contiene un listado de los procesos en ejecuci√≥n en el directorio home del usuario. AL igual que en el ejemplo anterior, se redirige la salida est√°ndar mediante >.
- `chmod 710 prueba` Cambia los permisos del archivo prueba a 710 para UGO (usuario, Grupo, Otros).
- `chown root:root PRUEBA` Se intenta cambiar el propietario del archivo prueba pero la operaci√≥n no est√° permitida.
- `chmod 777 PRUEBA` Cambia los permisos del archivo PRUEBA a 777. Es decir, todos los usuarios pueden leer, escribir y ejecutar el archivo.
- `chmod 700 /etc/passwd` Intenta cambiar los permisos a 700, pero la operaci√≥n no est√° permitida para un usuario que no es root, esto por el archivo que est√° intentando cambiar.
- `passwd root` passwd: No debe ver o cambiar la informaci√≥n de la contrase√±a para root.
- `rm PRUEBA` Se elimina el archivo PRUEBA.
- `man /etc/shadow` Permiso denegad, porque ‚Äúman‚Äù no debe recibir una ruta, si hago ‚Äúman shadow‚Äù si anda.
- `find / -name *.conf` Lista todos los archivos cuyo nombres terminan con .conf, empezando la b√∫squeda en el directorio ra√≠z /.
- `usermod root ‚Äìd /home/newroot ‚ÄìL`
- `cd /root` Se intenta acceder a la carpeta root, pero la operaci√≥n falla porque el usuario no tiene los permisos.
- `rm *` Borra todos los archivos del directorio donde est√° posicionado el usuario.
- `cd /etc` Cambia el directorio a /etc, osea ‚Äúse mueve‚Äù a /etc
- `cp * /home ‚ÄìR` Intenta copiar el contenido de /etc a home, pero el usuario no tiene los permisos necesarios para crear archivos en el directorio /home.
- `shutdown` Apaga el equipo

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## `8)` Indique qu√© comando ser√≠a necesario ejecutar para realizar cada una de las siguientes acciones:

#### `(a)` Terminar el proceso con PID 23.

- Todos los procesos tienen un pid (id de proceso) para terminar un proceso se usa el comando:
    ```
    kill -9 23 (kill menos 9 n√∫mero de id del proceso).
    ```
- `ps ‚Äìaux` Para ver los procesos del sistema que corren en el momento comando:

---

#### `(b)` Terminar el proceso llamado init. ¬øQu√© resultados obtuvo?

- `1)` Primero buscamos el PID de init con el comando `ps ‚Äìaux`
- `2)` Ingresamos como superusuario: su ‚Äì e ingresamos contrase√±a
- `3)` Utilizamos el comando kill ‚Äì9 1
- `4)` Y vamos a ver que no va a suceder nada, porque el proceso init, no puede terminarse, as√≠ que ni responde al comando. 


---

#### `(c)` Buscar todos los archivos de usuarios en los que su nombre contiene la cadena ‚Äú.conf‚Äù

Para buscar un `archivo` se utiliza el comando:
```
 find / -type f -name NombreDelArchivoABuscar
```
B√∫squeda por tipo

Linux permite a los usuarios listar toda la informaci√≥n basada en sus tipos. Hay varios filtros que puedes usar:
- **`d`** directorio o carpeta
- **`f`** archivo normal
- **`l`** enlace simb√≥lico
- **`c`** dispositivos de caracteres
- **`b`** dispositivos de bloque

Si deseamos buscar la palabra ‚Äúconf‚Äù en todo el sistema se utiliza el comando:
```
find / -name NombreABuscar 
```

---

#### `(d)` Guardar una lista de procesos en ejecuci√≥n el archivo /home/\<su nombre de usuario>/procesos

```
ps > /home/user/procesos
```

- `cat Procesos` Para poder comprobar el contenido que tiene el directorio Procesos
- `rm ‚Äìr Procesos` Para eliminar dicho directorio

---

#### `(e)` Cambiar los permisos del archivo /home/\<su nombre de usuario>/xxxx a:

- **Usuario:** Lectura, escritura, ejecuci√≥n
- **Grupo:** Lectura, ejecuci√≥n
- **Otros:** ejecuci√≥n

- `mkdir xxxx` Primero creamos el directorio ‚Äúxxxx‚Äù 
- `ls ‚Äìl` Para ver los permisos que tiene dicho directorio
- `chmod 751 xxxx` Para cambiar sus permisos donde Usuario tenga los permisos de lectura, escritura, ejecuci√≥n, Grupo los permisos de lectura y ejecuci√≥n y Otros el permiso
- `7` = 4(Lectura) + 2(Escritura) + 1(Ejecuci√≥n) --> `Usuario`
- `5` = 4(Lectura) + 1(Ejecuci√≥n) --> `Grupo`
- `1` = 1(Ejecuci√≥n) --> `Otros`
- `ls -l` Para chequear si los permisos fueron modificados

Para lograr visualizar los permisos se lee de la siguiente forma: 

![image](https://user-images.githubusercontent.com/55964635/227809799-8f8fb1d2-8ea0-4a2e-8a26-33bc6d1f83f0.png)
- No ver la primera d!
- Los primeros `rwx`(Lectura, Escritura, Ejecuci√≥n) pertenecen a Usuario
- Luego rx (LecturaEjecuci√≥n) pertenece a Grupo
- Y x (Ejecuci√≥n) pertenece a Otros

---

#### `(f)` Cambiar los permisos del archivo /home/<su nombre de usuario>/yyyy a:
- **Usuario:** Lectura, escritura.
- **Grupo:** Lectura, ejecuci√≥n
- **Otros:** Ninguno

- `mkdir yyyy` Primero creamos el directorio `‚Äúyyyy‚Äù`
- `ls ‚Äìl` Para ver los permisos que tiene dicho directorio 
- `chmod 650 yyyy` Para cambiar sus permisos donde Usuario tenga los permisos de lectura, escritura, ejecuci√≥n, Grupo los permisos de lectura y ejecuci√≥n y Otros el permiso de ejecuci√≥n.

---

#### `(g)` Borrar todos los archivos del directorio /tmp

```shell
cd /tmp
rm *
```

---

#### `(h)` Cambiar el propietario del archivo /opt/isodata al usuario iso2010

```shell
chown iso2010 /opt/isodata
```

#### `(i)` Guardar en el archivo /home/\<su nombre de usuario>/donde el directorio donde me encuentro en este momento, en caso de que el archivo exista no se debe eliminar su contenido anterior.

```
pwd >> /home/user/donde
```

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## `9)` Indique qu√© comando ser√≠a necesario ejecutar para realizar cada una de las siguientes acciones

#### `(a)` Ingrese al sistema como usuario ‚Äúroot‚Äù

```shell
su
```

---

#### `(b)` Cree un usuario. Elija como nombre, por convenci√≥n, la primer letra de su nombre seguida de su apellido. As√≠gnele una contrase√±a de acceso.

```powershell
sudo adduser il {crear}
passwd il {nueva contra}
```

---

#### `(c)` ¬øQu√© archivos fueron modificados luego de crear el usuario y qu√© directorios se crearon?

se modificaron los archivos `/etc/passwd` y se creo el directorio personal del perfil en /home/nombrelegido

---

#### `(d)` Crear un directorio en `/tmp` llamado cursada2017

```shell
cd /tmp
mkdir cursada2017
```

---

#### `(e)` Copiar todos los archivos de `/var/log` al directorio antes creado.

En modo superusuario/root

```shell
cp /var/log/* /tmp/cursada2017
```

---

#### `(f)` Para el directorio antes creado (y los archivos y subdirectorios contenidos en √©l) cambiar el propietario y grupo al usuario creado y grupo users.

```shell
chown nombreUsuario:nombreUsuario /tmp/cursada2017
```

---

#### `(g)` Agregue permiso total al due√±o, de escritura al grupo y escritura y ejecuci√≥n a todos los dem√°s usuarios para todos los archivos dentro de un directorio en forma recursiva.

```shell
chmod -R 745 /tmp/cursada2017
```

---

#### `(h)` Acceda a otra terminal virtual para loguearse con el usuario antes creado.

```
sudo login user
```

---

#### `(i)` Una vez logueado con el usuario antes creado, averig√ºe cu√°l es el nombre de su terminal.

```shell
ps -p 544
```

---

#### `(j)` Verifique la cantidad de procesos activos que hay en el sistema.

```shell
ps aux | wc -l
```

---

#### `(k)` Verifiqu√© la cantidad de usuarios conectados al sistema.

```shell
who
```

---

#### `(l)` Vuelva a la terminal del usuario root, y env√≠ele un mensaje al usuario anteriormente creado, avis√°ndole que el sistema va a ser apagado.

```shell
sudo shutdown 1 'El sistema se va a apagar'
tmb sin apagar
wall "En un minuto apagaremos el sistema."
```

---

#### `(m)` Apague el sistema

```shell
sudo shutdown now
```

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## `10)` Indique qu√© comando ser√≠a necesario ejecutar para realizar cada una de las siguientes acciones

#### `(a)` Cree un directorio cuyo nombre sea su n√∫mero de legajo e ingrese a √©l.

```shell
mkdir 19508/3 {No se puede dado q confunde / con un desplazamiento de directorio}
```

---

#### `(b)` Cree un archivo utilizando el editor de textos vi, e introduzca su informaci√≥n personal:

Nombre, Apellido, N√∫mero de alumno y direcci√≥n de correo electr√≥nico. El archivo debe llamarse "LEAME".

```
cd legajo
vi LEAME
```

---

#### `(c)` Cambie los permisos del archivo LEAME, de manera que se puedan ver reflejados los siguientes permisos:

- **Due√±o:** ning√∫n permiso
- **Grupo:** permiso de ejecuci√≥n
- **Otros:** todos los permisos

```shell
chmod 017 LEAME
```

---

#### `(d)` Vaya al directorio /etc y verifique su contenido. Cree un archivo dentro de su directorio personal cuyo nombre sea leame donde el contenido del mismo sea el listado de todos los archivos y directorios contenidos en /etc. ¬øCu√°l es la raz√≥n por la cu√°l puede crear este archivo si ya existe un archivo llamado "LEAME.en este directorio?.

Se puede porque unix es case sensitive y distingue entre may√∫sculas y min√∫sculas.

---

#### `(e)` ¬øQu√© comando utilizar√≠a y de qu√© manera si tuviera que localizar un archivo dentro del filesystem? ¬øY si tuviera que localizar varios archivos con caracter√≠sticas similares? Explique el concepto te√≥rico y ejemplifique.

```shell
find / -name "[0-9]*"
```

---

#### `(f)` Utilizando los conceptos aprendidos en el punto e), busque todos los archivos cuya extensi√≥n sea .so y almacene el resultado de esta b√∫squeda en un archivo dentro del directorio creado en a). El archivo deber√° llamarse .ejercicio_f".

```shell
find / -name "*.os" > /home/user/legajo/ejerciciof
```

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## `11)` Ejercicio

Indique qu√© acci√≥n realiza cada uno de los comandos indicados a continuaci√≥n considerando su orden. Suponga que se ejecutan desde un usuario que no es root ni pertenece al grupo de root. (Asuma que se encuentra posicionado en el directorio de trabajo del usuario con el que se logue√≥). En caso de no poder ejecutarse el comando indique la raz√≥n:


- `mkdir iso` Crea el directorio iso
- `cd . / iso; ps > f0` Me situo en iso y creo el archivo f0 con los procesos en ejecucion
- `ls > f1` Guardo en F1 la lista de archivos en el directorio iso
- `cd /` Me posiciono en la raiz 
- `echo $HOME` muestra en pantalla la direccion del directorio personal del usuario
- `ls ‚àíl $> $HOME/iso/ls` No se puede acceder a $ no existe el fichero o directorio
- `cd $HOME; mkdir f2` Nos situamos en el directorio personal y creamos el directorio f2
- `ls ‚àíld f2` Se da un listado detallado de f2
- `chmod 341 f2` Se modifican los permisos de f2;Es,Ej para usuario,L para Grupo, y Ej para otros
- `touch dir` se crea el archivo dir
- `cd f2` accedemos al directoriio f2
- `cd ~/ iso` accedemos a la carpeta iso
- `pwd > f3` se guarda en el archivo f3 la direccion de la carpeta iso
- `ps | grep ' ps ' | wc ‚àíl >> ../f2/f3` se obtienen los procesos, se usa de entrada para grep el cual filtra todos los que posean ps,pra luego almacenar la cantidad de lineas obtenidas luegro de dicho filtro y a√±adirlas al archivo f3
- `chmod 700 .. / f2 ; cd ..` Se modifica el acceso de f2 dando al usuario todos los permisos y a los demas nada, volviendo despues al directorio personal
- `find . ‚àíname etc / passwd` Lanza un warning por mal uso del comando
- `find / ‚àíname etc / passwd` filtra todos los archivos de passwd por nombre en orden
- `mkdir ejercicio5` crea el directorio ejercicio5


#### `(a)` Inicie 2 sesiones utilizando su nombre de usuario y contrase√±a. En una sesi√≥n vaya siguiendo paso a paso las √≥rdenes que se encuentran escritas en el cuadro superior. En la otra sesi√≥n, cree utilizando alg√∫n editor de textos un archivo que se llame. ejercicio10_explicacion"dentro del directorio creado en el ejercicio 9.a) y, para cada una de las √≥rdenes que ejecute en la otra sesi√≥n, realice una breve explicaci√≥n de los resultados obtenidos. (ARRIBA)

---

#### `(b)` Complete en el cuadro superior los comandos 19 y 20, de manera tal que realicen la siguiente acci√≥n:
- `19:` Copiar el directorio iso y todo su contenido al directorio creado en el inciso 9.a).
- `20:` Copiar el resto de los archivos y directorios que se crearon en este ejercicio al directorio creado en el ejercicio 9.a).

#### `(c)` Ejecute las √≥rdenes 19 y 20 y comentelas en el archivo creado en el inciso a).

![image](https://user-images.githubusercontent.com/55964635/189272687-459c381d-b44c-4a8d-b3d0-aa3acc44e1ae.png)

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## `12)` Ejercicio

**Enunciado:** Cree una estructura desde el directorio /home que incluya varios directorios, subdirectorios y archivos, seg√∫n el esquema siguiente. Asuma que ‚Äúusuario‚Äù indica cu√°l es su nombre de usuario. Adem√°s deber√° tener en cuenta que dirX hace referencia a directorios y fX hace
referencia a archivos:

#### `(a)` Utilizando la estructura de directorios anteriormente creada, indique que comandos son necesarios para realizar las siguientes acciones:

#### Mueva el archivo "f3.al directorio de trabajo /home/usuario.

```shell
mv f3 $HOME
```

---

#### Copie el archivo "f4.en el directorio "dir11".

```shell
cp f4 $HOME/dir11
```

---

#### Haga los mismo que en el inciso anterior pero el archivo de destino, se debe llamar "f7".

```shell
cp f4 $HOME/dir11/f7
```

---

#### Cree el directorio copia dentro del directorio usuario y copie en √©l, el contenido de "dir1".

```shell
mkdir copia; cp -a dir11 copia
```

---

#### Renombre el archivo "f1"por el nombre archivo y vea los permisos del mismo.

```shell
cd iso;mv f0 archivo; ls  -ld archivo
```

---

#### Cambie los permisos del archivo llamado archivo de manera de reflejar lo siguiente:

- **``Usuario``** Permisos de lectura y escritura
- **``Grupo``** Permisos de ejecuci√≥n
- **``Otros``** Todos los permisos

```shell
chmod 617 archivo
```

---

#### Renombre los archivos "f3 2 "f4"de manera que se llamen "f3.exe 2 "f4.exerespectivamente.

```shell
mv f3 f3.exe; cd $HOME/dir11 ; mov f4 f4.exe
```

---

#### Utilizando un √∫nico comando cambie los permisos de los dos archivos renombrados en el inciso anterior, de manera de reflejar lo siguiente:

- **`Usuario`** Ning√∫n permiso
- **`Grupo`** Permisos de escritura
- **`Otros`** Permisos de escritura y ejecuci√≥n

```shell
chmod 023 f3.exe f4.exe
```

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

## `13)` Indique qu√© comando/s es necesario para realizar cada una de las acciones de la siguiente secuencia de pasos (considerando su orden de aparici√≥n):

#### `(a)` Cree un directorio llamado logs en el directorio /tmp.

```shell
cd /tmp; mkdir logs
```

---

#### `(b)` Copie todo el contenido del directorio /var/log en el directorio creado en el punto anterior.

```shell
cp -a /var/log/. /tmp/logs
```

---

#### `(c)` Empaquete el directorio creado en 1, el archivo resultante se debe llamar "misLogs.tar".

```shell
tar cvf misLogs.tar logs
```

---

#### `(d)` Empaquete y comprima el directorio creado en 1, el archivo resultante se debe llamar "misLogs.tar.gz".

```shell
tar cvfz misLogs.tar.gz logs
```

---

#### `(e)` Copie los archivos creados en 3 y 4 al directorio de trabajo de su usuario.

```shell
cp misLoggs.tar $HOME
cp misLogs.tar.gz $HOME
```

---

#### `(f)` Elimine el directorio creado en 1, logs

```shell
rm -r logs
```

---

#### `(g)` Desempaquete los archivos creados en 3 y 4 en do directorios diferentes.

```shell
tar xvf misLogs.tar -C 1 
tar xvfz misLogs.tar.gz -C 2
```

<img src= 'https://i.gifer.com/origin/8c/8cd3f1898255c045143e1da97fbabf10_w200.gif' height="20" width="100%">

#### Fecha

Con el comando `Date`