<h1 align="center"> üêß Resumen Teorico</h1>

---

# Sistemas Operativos

- [Sistema Operativo](#sistema-operativo)
- [Funciones principales](#funciones-principales)
- [Problemas que debe evitar](#problemas-que-debe-evitar-un-so)
- [Componentes](#componentes)
  - [Kernel (N√∫cleo)](#kernel-nucleo)
    - [Monol√≠tico](#monolitico)
    - [Microkernel](#microkernel)
    - [Monol√≠tico Vs. Microkernel](#monolitico-vs-microkernel)
- [Servicios](#servicios)
  - [Apoyo del Hardware](#apoyo-del-hardware)
  - [Modos de ejecuci√≥n](#modos-de-ejecuci√≥n)
  - [Protecci√≥n](#protecciones)
    - [Protecci√≥n de la memoria](#protecci√≥n-de-la-memoria)
    - [Protecci√≥n de la E/S](#protecci√≥n-de-la-es)
    - [Protecci√≥n de la CPU](#protecci√≥n-de-la-cpu)
  - [System Calls](#system-calls)
- [Elementos B√°sicos de una computadora](#elementos-basicos-de-una-computadora)
  - [Registros del Procesador](#registros-del-procesador)
    - [Visibles por el usuario](#visibles-por-el-usuario)
    - [De Control y Estado](#de-control-y-estado)
    - [Ciclo de Instrucciones](#ciclo-de-instrucci√≥n)
  - [Interrupciones](#interrupciones)
  - [Sistema Batch](#sistema-batch)
  - [Multiprogramaci√≥n](#multiprogramaci√≥n)

# Procesos



---


## Sistema Operativo
- Es software
  - Necesita un procesador y memoria para ejecutarse
- Dos Perspectivas
  - De arriba hacia abajo
  - De abajo hacia arriba
- Gestiona el HW
- Controla la ejecuci√≥n de los procesos
- Interfaz entre aplicaciones y HW
- Act√∫a como intermediario entre un usuario de una computadora y el HW de la misma

### Perspectiva de arriba hacia abajo
- Abstracci√≥n con respecto a la arquitectura
  - **Arquitectura** conjunto de instrucciones, organizaci√≥n de memoria, E/S, estructura de bus
- El SO **oculta** el HW y presenta a los programas como abstracciones m√°s simples de manejar.
- Los programas de aplicaci√≥n son los **clientes** del SO.
- **Comparaci√≥n**: uso de escritorio y uso de comandos de texto
- Comodidad, **amigabilidad** (friendliness)

### Perspectiva de Abajo hacia arriaba
- Visi√≥n del SO como un administrador de recursos
- Administra los recursos de HW de uno o m√°s procesos
- Provee un conjunto de servicios a los usuarios del sistema
- Maneja la memoria secundaria y dispositivos de I/O.
- Ejecuci√≥n simult√°nea de procesos
- Multiplexaci√≥n en tiempo (CPU) y en espacio (memoria)

### Objetivos 
- **Comodidad** Hacer mas f√°cil el uso del hardware (PC, servidor, switch, router, controlador espec√≠fico)
- **Eficiencia** Hacer un uso m√°s eficiente de los recursos del sistema
- **Evoluci√≥n** Permitir la introducci√≥n de nuevas funciones al sistema sin interferir con funciones anteriores

---

## Funciones principales
- Brindar abstracciones de alto nivel a  los procesos de usuario
- Administrar eficientemente el uso de  la CPU
- Administrar eficientemente el uso de la memoria
- Brindar asistencia al proceso de E/S por parte de los procesos

## Problemas que debe evitar un so

- Que un proceso se apropie de la CPU
- Que un proceso intente ejecutar instrucciones privilegiadas (Ej: E/S)
- Que un proceso intente acceder a una posici√≥n de memoria fuera de su espacio permitido.
  - Proteger los espacios de direcciones

Para ello debe

- Gestionar/controlar el uso de la CPU
- Detectar intentos de ejecuci√≥n de instrucciones privilegiadas
- Detectar accesos ilegales a memoria
- Proteger el vector de interrupciones
  - As√≠ como las RAI (Rutinas de atenci√≥n de interrupciones)



---

## Componentes
- **Kernel**
- **Shell** GUI / CUI o CLI
- **Herramientas** Editores, Compiladores, Librer√≠as, etc.

---

### Kernel (Nucleo)

Es una **`Porci√≥n de c√≥digo`** que se encuentra en memoria principal y se encarga de la administraci√≥n de los recursos

Implementa servicios esenciales:
- Manejo de memoria 
- Manejo de la CPU
- Administraci√≥n de procesos
- Comunicaci√≥n y Concurrencia
- Gesti√≥n de la E/S

Sobre el Kernel del Sistema Operativo

- Es un conjunto de m√≥dulos de software
- Se ejecuta en el procesador como cualquier otro proceso
- Entonces: 
  - ¬øEl kernel es un proceso? Y de ser as√≠ ¬øQuien lo controla? 
- Diferentes enfoques de dise√±o

Enfoque 1 ‚Äì El Kernel como entidad independiente

- El Kernel se ejecuta fuera de todo proceso
- Es una arquitectura utilizada por los primeros SO
- Cuando un proceso es ‚Äúinterrumpido‚Äù o realiza una System Call, el contexto del proceso se salva y el control se pasa al Kernel del sistema operativo.
- El Kernel tiene su propia regi√≥n de memoria
- El Kernel tiene su propio Stack 
- Finalizada su actividad, le devuelve el control al proceso (o a otro diferente)
- Importante: 
  - El Kernel NO es un proceso. EL concepto de proceso solo se asocia a programas de usuario
  - Se ejecuta como una entidad independiente en modo privilegiado

![](2023-06-05-11-09-04.png)

Enfoque 2 ‚Äì El Kernel **dentro** del Proceso

- El **C√≥digo** del Kernel se encuentra dentro del espacio de direcciones de cada proceso.
- El Kernel se ejecuta  en el MISMO contexto que alg√∫n proceso de usuario
- El Kernel se puede ver como una colecci√≥n de rutinas que el proceso utiliza
- Dentro de un proceso se encuentra el c√≥digo del programa (user) y el c√≥digo de los m√≥dulos de SW del SO
- Cada proceso tiene su propio stack (uno en modo usuario y otro en modo kernel)
- El proceso es el que se Ejecuta en Modo Usuario y el kernel del SO se ejecuta en Modo Kernel (cambio de modo)
- El c√≥digo del Kernel es compartido por  todos los procesos
  - En administraci√≥n de memoria veremos el ‚Äúcomo‚Äù
- Cada interrupci√≥n (incluyendo las de  System Call) es atendida en el contexto del proceso que se encontraba en ejecuci√≥n 
  - Pero en modo Kernel!!! (se pasa a este modo sin necesidad de hacer un cambio de contexto completo)
  - Si el SO determina que el proceso debe seguir ejecut√°ndose luego de atender la interrupci√≥n, cambia a modo usuario y devuelve el control. Es mas econ√≥mico y performante

![](2023-06-05-11-14-01.png)

---

#### Monolitico

![](2023-06-04-16-10-08.png)

#### Microkernel

![](2023-06-04-16-10-41.png)

### Monolitico vs Microkernel
![](2023-06-04-16-11-14.png)

---

### Servicios

- **Administraci√≥n y planificaci√≥n del procesador**
  - Multiplexaci√≥on de la carga de trabajo
  - Imparcialidad, **justicia** en la ejecuci√≥n (Fairness) 
  - Que no haya bloqueos
  - Manejo de Prioridades
- **Administraci√≥n de Memoria**
  - Administraci√≥n de memoria eficientemente
  - Memoria f√≠sica vs memoria virtual. Jerarqu√≠as de memoria
  - Protecci√≥n de programas que compiten o se ejecutan concurrentemente
- **Administraci√≥n del almacenamiento** (Sistema de archivos)
  - Acceso a medios de almacenamiento externos
- **Administraci√≥n de dispositivos**
  - Ocultamiento de dependencias de HW
  - Administraci√≥n  de accesos simult√°neos
- **Detecci√≥n de errores y respuestas**
  - Errores de HW internos y Externos
    - Errores de Memoria/CPU
    - Errores de Dispositivos
  - Errores de SW
    - Errores Aritm√©ticos
    - Acceso no permitido a direcciones de memoria
  - Incapacidad del SO para conceder una solicitud de una aplicaci√≥n
- **Interacci√≥n del Usuario (Shell)**
- **Contabilidad**
  - Recoger estad√≠sticas del uso
  - Monitorear par√°metros de rendimiento
  - Anticipar necesidades de mejoras futuras
  - Dar elementos si es necesario facturar  tiempo de procesamiento

---

### Apoyo del Hardware

#### Modos de Ejecuci√≥n
Define limitaciones en el conjunto de instrucciones que se puede ejecutar en cada modo

- El bit en la CPU indica el modo actual
- Las instrucciones privilegiadas deben ejecutarse en modo **Supervisor o Kernel**
  - Necesitan acceder a estructuras del kernel, o ejecutar c√≥digo que no es del proceso
- En modo **Usuario**, el proceso puede acceder s√≥lo a su espacio de direcciones, es decir a las direcciones ‚Äúpropias‚Äù.
- El kernel del SO se ejecuta en modo supervisor
- El resto del SO y los programas de usuario se ejecutan en modo usuario (subconjunto de instrucciones permitidas)

Datos de Color

- Procesador Intel 8088 no ten√≠a modo dual de operaci√≥n ni protecci√≥n por hardware.
- En MsDos las aplicaciones pueden acceder directamente a las funciones b√°sicas de E/S para escribir directamente en pantalla o en disco.

Tener en cuenta que
- Cuando se arranque el sistema, arranca con el bit en modo supervisor. 
- Cada vez que comienza a ejecutarse un proceso de usuario, este bit se DEBE PONER en modo usuario.
  - Mediante una Instrucci√≥n especial.
- Cuando hay un trap o una interrupci√≥n, el bit de modo se pone en modo Kernel.
  - √önica forma de pasar a Modo Kernel
  - No es el proceso de usuario quien hace el cambio explicitamente.

Como Actua

Cuando el proceso de usuario intenta por s√≠ mismo ejecutar instrucciones que pueden causar problemas (las llamadas instrucciones privilegiadas), el HW lo detecta como una operaci√≥n ilegal y produce un trap al SO.

![](2023-06-04-15-26-37.png)

En windows

- En WIN2000 el modo n√∫cleo ejecuta los servicios ejecutivos. El modo usuario ejecuta los procesos de usuario. 
- Cuando un programa se bloquea en modo usuario, a lo sumo se escribe un suceso en el registro de sucesos. Si el bloqueo se produce estando en modo supervisor se genera la BSOD (pantalla azul de la muerte).

### En resumen

Modo kernel
- Gesti√≥n de procesos: Creaci√≥n y terminaci√≥n ,  planificaci√≥n, intercambio, sincronizaci√≥n y soporte para la comunicaci√≥n entre procesos
- Gesti√≥n de memoria: Reserva de espacio de direcciones para los procesos, Swapping, Gesti√≥n y p√°ginas de segmentos
- Gesti√≥n E/S: Gesti√≥n de buffers, reserva de canales de E/S y de dispositivos de los procesos
- Funciones de soporte: Gesti√≥n de interrupciones, auditor√≠a, monitoreo

Modo usuario
- Debug de procesos, definici√≥n de protocolos de comunicaci√≥n gesti√≥n de aplicaciones (compilador, editor, aplicaciones de usuario
- En este modo se llevan a cabo todas las tareas que no requieran accesos privilegiados
- En este modo no se puede interactuar con el hardware
- El proceso trabaja en su propio espacio de direcciones

---

#### Interrupci√≥n  de Clock
Se debe evitar que un proceso se apropie de la CPU

---

### Protecciones

#### Protecci√≥n de la Memoria

Se deben definir l√≠mites de memoria a los que puede acceder cada proceso (registros base y l√≠mite)

- Delimitar el espacio de direcciones del proceso
- Poner limites a las direcciones que puede utilizar un proceso
  - Por ejemplo: Uso de un registro base y un registro l√≠mite
  - El kernel carga estos registros por medio de instrucciones privilegiadas. Esta acci√≥n s√≥lo puede realizarse en modo Kernel 

La memoria principal aloja al SO y a los procesos de usuario
- El kernel debe proteger para que los procesos de usuario no puedan acceder donde no les corresponde
- El kernel debe proteger el espacio de direcciones de un proceso del acceso de otros procesos.

![](2023-06-04-15-46-47.png)

### Protecci√≥n de la E/S

- Las instrucciones de E/S se definen como privilegiadas. 
- Deben ejecutarse en Modo Kernel
  - Se deber√≠an gestionar en el kernel del sistema operativo 
  - Los procesos de usuario realizan E/S a trav√©s de llamadas al SO (es un servicio del SO)

### Protecci√≥n de la CPU

- Uso de interrupci√≥n por clock para evitar que un proceso se apropie de la CPU
- Se implementa normalmente a trav√©s de un clock y un contador. 
- El kernel le da valor al contador que se decrementa con cada tick de reloj y al llegar a cero puede expulsar al proceso para ejecutar otro.
- Las instrucciones que modifican el funcionamiento del reloj son privilegiadas. 
- Se le asigna al contador el valor que se quiere que se ejecute un proceso. 
- Se la usa tambi√©n para el c√°lculo de la hora actual, bas√°ndose en cantidad de interrupciones ocurridas cada tanto tiempo y desde una fecha y hora determinada. 

---

## System Calls

- Es la forma en que los programas de usuario acceden a los servicios del SO.
- Los par√°metros asociados a las llamadas pueden pasarse de varias maneras: por registros, bloques o tablas en memoria √≥ la pila.
  - **count=read(file, buffer, nbytes);**
- Se ejecutan en modo kernel o supervisor

![](2023-06-04-15-58-39.png)

**Categorias**

- Control de Procesos
![](2023-06-04-16-01-21.png)
- Manejo de archivos
![](2023-06-04-16-01-42.png)
- Manejo de dispositivos
![](2023-06-04-16-02-34.png)
- Mantenimiento de informaci√≥n del sistema
![](2023-06-04-16-02-58.png)
- Comunicaciones

Ejemplo 

![](2023-06-04-16-03-35.png)

- Para activar iniciar la system call se indica:
  - El n√∫mero de syscall que se quiere ejecutar
  - Los par√°metros de esa syscall
- Luego se emite una interrupci√≥n para pasar a modo Kernel y gestionar la systemcall
- El manejador de interrupciones (syscall handler) eval√∫a la system call deseada y la ejecuta

Mas ejemplos

![](2023-06-04-16-08-59.png)

---

# Elementos basicos de una computadora

## Registros del Procesador

### Visibles por el usuario

- Registros que pueden ser usados por las aplicaciones
- Pueden ser referenciados por lenguaje de m√°quina
- Disponible para programas/aplicaciones
- Tipos de registros
  - Datos 
  - Direcciones
    - Index
    - Segment pointer
    - Stack pointer

### De Control y estado

- Para control operativo del procesador
- Usados por rutinas privilegiadas del SO para controlar la ejecuci√≥n de procesos

#### Program Counter (PC)
- Contiene la direcci√≥n de la proxima instrucci√≥n a ser ejecutada

---

#### Instruction Register (IR)
- Contiene la instrucci√≥n a ser ejecutada
- La instrucci√≥n referenciada por el PC se almacena en el IR y se ejecuta
- Categor√≠as de instrucciones
  - **Procesador - Memoria** (Transfiere datos entre procesador y memoria)
  - **Procesador - E/S** (Transfiere datos a/o desde perif√©ricos)
  - **Procesamiento de Datos** (Operaciones aritm√©ticas o l√≥gicas sobre datos)
  - **Control** (Alterar secuencia de ejecuci√≥n)

#### Program Status Word (PSW)
- Contiene c√≥digos de resultado de operaciones
- habilita/deshabilita Interrupciones 
- Indica el modo de ejecuci√≥n (Supervisor/usuario)

---

### Ciclo de Instrucci√≥n

Dos pasos

#### Fetch (Procesador lee la instrucci√≥n desde la memoria)

- El procesador busca (fetch) la instrucci√≥n en la memoria
  - (PC) ‚Üí IR
- El PC se incrementa despu√©s de cada fetch para apuntar a la pr√≥xima instrucci√≥n
  - PC = PC + 4


#### Execute (Procesador ejecuta la instrucci√≥n)

![](2023-06-04-16-55-20.png)

---

![](2023-06-04-16-23-31.png)

## Interrupciones

- Interrumpen el secuenciamiento del procesador durante la ejecuci√≥n de un proceso
- Dispositivos de E/S m√°s lentos que el procesador (Procesador debe esperar al dispositivo)

| Flujo de control SIN  interrupciones | Flujo de control CON  interrupciones |
| --- | --- |
| ![](2023-06-05-01-03-14.png) | ![](2023-06-05-01-04-37.png) |

### Interrupt Handler

- Programa (o rutina) que determina la naturaleza de una interrupci√≥n y realiza lo necesario para atenderla
  - Por ejemplo, para un dispositivo particular de E/S
- Generalemente es parte del SO

Suspende la secuencia normal de ejecuci√≥n

![](2023-06-05-01-10-21.png)

Ciclo de interrupci√≥n

![](2023-06-05-01-13-38.png)

- El procesador chequea la existencia de interrupciones. 
- Si no existen interrupciones, la pr√≥xima instrucci√≥n del programa es ejecutada
- Si hay pendiente alguna interrupci√≥n, se suspende la ejecuci√≥n del progama actual y se ejecuta la rutina de manejo de interrupciones

Simple Interrupt Processing

![](2023-06-05-01-14-47.png)

Multiples Interrupciones

Deshabilitar las interrupciones mientras una interrupci√≥n est√° siendo procesada.


| ![](2023-06-05-01-15-22.png) | ![](2023-06-05-01-16-24.png) |
| --- | --- |

---

## Sistema Batch

Baja utilizaci√≥n de la CPU

Dispositivos de E/S mucho mas lentos con respecto a la CPU

Ante instrucci√≥n de E/S, el procesador permanece ocioso. Cuando se completa la E/S, se continua con la ejecuci√≥n del programa que se estaba ejecutando

![](2023-06-05-01-54-48.png)


## Multiprogramaci√≥n

- La operaci√≥n de los sistemas batch se vio beneficiada del spooling de las tareas, al solapar la E/S de una tarea de la ejecuci√≥n de otra
- Al estar las tareas cargadas en disco, ya no era necesario ejecutarlas en el orden en el que fueron cargadas (job scheduling)
- El SO mantiene varias tareas en memoria al mismo tiempo.
- La secuencia de programas es de acuerdo a prioridad u orden de llegada
- Cuando el proceso necesita realizar una operaci√≥n de E/S, la CPU en lugar de permanecer ociosa, es utilizada para otro proceso.
- Despu√©s que se completa la atenci√≥n de la interrupci√≥n, el control puede o no retornar al programa que se estaba ejecutando al momento de la interrupci√≥n

![](2023-06-05-10-17-40.png)

Tiempo Compartido

- Utiliza la multiprogramaci√≥n para manejar m√∫ltiples trabajos interactivos
- El tiempo del procesador es compartido entre m√∫ltiples trabajos. 
- M√∫ltiples usuarios podr√≠an acceder simult√°neamente al sistema utilizando terminales
- Los procesos usan la CPU por un periodo m√°ximo de tiempo, luego del cual se le da la CPU a otro proceso


---

# Procesos

Definicion

- Es un programa en ejecuci√≥n
- Para nosotros ser√°n sin√≥nimos: tarea, job  y proceso

### Diferencias entre un programa y un proceso

| Programa | Proceso |
| --- | --- |
| Es estatico | Es dinamico |
| No tiene program counter | Tiene Program Counter |
| Existe desde que se edita hasta que se borra | Su ciclo de vida comprende desde que se solicita ejecutar hastas que termina |

El modelo de proceso

![](2023-06-05-10-33-49.png)

- Multiprogramaci√≥n de 4 procesos
- Modelo conceptual de 4 procesos secuenciales e independientes. 
- Solo un proceso se encontrara activo en cualquier instante. (Si tenemos una sola CPU)

### Componentes de un proceso

Proceso: Entidad de abstracci√≥n

Un proceso (para poder ejecutarse) incluye como m√≠nimo: 
- Secci√≥n de C√≥digo (texto)
- Secci√≥n de Datos (variables globales)
- Stack(s) (datos temporarios: par√°metros , variables temporales y direcciones de retorno)

#### Stacks

- Un proceso cuenta con 1 o mas stacks
  - En general: modo Usuario y modo Kernel
- Se crean autom√°ticamente y su medida se ajusta en run-time.
- Est√° formado por stack frames que son pushed (al llamar a una rutina) y popped (cuando se retorna de ella)
- El stack frame tiene los par√°metros de la rutina(variables locales), y datos necesarios para recuperar el stack frame anterior (el contador de programa y el valor del stack pointer en el momento del llamado)

#### Atributos de un proceso

- Identificaci√≥n del proceso, y del proceso padre
- Identificaci√≥n del usuario que lo ‚Äúdispar√≥‚Äù
- Si hay estructura de grupos, grupo que lo dispar√≥
- En ambientes multiusuario, desde que terminal y quien lo ejecuto

#### PCB (Process Control Block)

- Estructura de datos asociada al proceso (abstracci√≥n)
- Existe una por proceso.
- Es lo primero que se crea cuando se crea un proceso y lo √∫ltimo que se borra cuando termina
- Contiene  la informaci√≥n asociada con cada proceso:
  - PID, PPID, etc
  - Valores de los registros de la CPU (PC, AC, etc)
  - Planificaci√≥n (estado, prioridad, tiempo consumido, etc)
  - Ubicaci√≥n (representaci√≥n) en memoria
  - Accounting
  - Entrada salida (estado, pendientes, etc)

![](2023-06-05-10-48-31.png)

#### Qu√© es el espacio de direcciones de un proceso?

- Es el conjunto de direcciones de memoria que ocupa el proceso
  - stack, text y datos
- No incluye su PCB o tablas asociadas
- Un proceso en modo usuario puede acceder s√≥lo a su espacio de direcciones; 
- En modo kernel, se puede acceder a estructuras internas (PCB del proceso por ejemplo) o a espacios de direcciones de otros procesos.

Espacio de direcciones del proceso + PCB

![](2023-06-05-10-51-03.png)

#### El contexto de un proceso

- Incluye toda la informaci√≥n que el SO necesita para administrar el proceso, y la CPU para ejecutarlo correctamente.
- Son parte del contexto, los registros de cpu, inclusive el contador de programa, prioridad del proceso, si tiene E/S pendientes, etc.

#### Cambio de Contexto (Context Switch)

- Se produce cuando la CPU cambia de un proceso a otro.
- Se debe resguardar el contexto del proceso saliente, que pasa a espera y retornar√° despu√©s a la CPU.
- Se debe cargar el contexto del nuevo proceso y comenzar desde la instrucci√≥n siguiente a la √∫ltima ejecutada en dicho contexto.
- Es tiempo no productivo de CPU
- El tiempo que consume depende del soporte de HW

![](2023-06-05-11-06-03.png)

---

### Estados de un proceso

En su ciclo de vida, un proceso pasa por diferentes estados.
- Nuevo (new)
- Listo para ejecutar (ready)
- Ejecut√°ndose (running)
- En espera (waiting)
- Terminado (terminated)

![](2023-06-05-12-43-23.png)

### Comportamiento de los procesos

Procesos alternan r√°fagas de CPU y de I/O

![](2023-06-05-14-36-00.png)

- CPU-bound (Mayor parte del tiempo utilizando la CPU)
- I/O-bound (I/O = E/S) (Mayor parte del tiempo esperando por I/O)
- La velocidad de la CPU es mucho mas r√°pida que la de los dispositivos de E/S
  - Pensar: Necesidad de atender r√°pidamente procesos I/O-bound para mantener el dispositivo ocupado y aprovechar la CPU para procesos CPU-bound

---

### Colas en la planificaci√≥n de procesos

- Para realizar la planificaci√≥n, el SO utiliza la PCB de cada proceso como una abstracci√≥n del mismo
- Las PCB se enlazan en Colas siguiendo un orden determinado
- Ejemplos
- Cola de trabajos o procesos (Contiene todas  las PCB de procesos en el sistema)
- Cola de procesos listos (PCB de procesos residentes en memoria principal esperando para ejecutarse)
- Cola de dispositivos (PCB de procesos esperando por un dispositivo de I/O)

![](2023-06-05-12-45-07.png)

![](2023-06-05-12-45-31.png)

### Planificaci√≥n
- Planificaci√≥n: (Necesidad de determinar cual de todos los procesos que est√°n listos para ejecutarse, se ejecutar√° a continuaci√≥n en un ambiente multiprogramado)
- Algoritmo de Planificaci√≥n (Algoritmo utilizado para realizar la planificaci√≥n del sistema)

#### Categor√≠as de los Algoritmos de Planificaci√≥n

- Seg√∫n el ambiente es posible requerir algoritmos de planificaci√≥n diferentes, con diferentes metas:
  - Equidad: Otorgar una parte justa de la CPU a cada proceso
  - Balance: Mantener ocupadas todas las partes del sistema
- Ejemplos:
  - Procesos por lotes (batch)
  - Procesos Interactivos
  - Procesos en Tiempo Real

#### Procesos Batch

- No existen usuarios que esperen una respuesta en una terminal.
- Se pueden utilizar algoritmos no apropiativos
- Metas propias de este tipo de algoritmos:
  - Rendimiento: Maximizar el n√∫mero de trabajos por hora
  - Tiempo de Retorno: Minimizar los tiempos entre el comienzo y la finalizaci√≥n
  - El Tiempo es espera se puede ver afectado
  - Uso de la CPU: Mantener la CPU ocupada la
- Ejemplos de Algoritmos:
  - FCFS ‚Äì First Come First Served
  - SJF ‚Äì Shortest Job First

![](2023-06-05-14-43-59.png)

#### Procesos Interactivos

- No solo interacci√≥n con los usuarios
  - Un servidor, necesita de varios procesos para dar respuesta a diferentes requerimientos
- Son necesarios algoritmos apropiativos para evitar que un proceso acapare la CPU
- Metas propias de este tipo de algoritmos:
  - Tiempo de Respuesta: Responder a peticiones con rapidez
  - Proporcionalidad: Cumplir con expectativas de los usuarios
    - Si el usuario le pone STOP al reproductor de m√∫sica, que la m√∫sica deje de ser reproducida en un tiempo considerablemente corto.

![](2023-06-05-14-46-39.png)

**M√≥dulos de la planificaci√≥n**

- Son m√≥dulos (SW) del Kernel que realizan distintas tareas asociadas a la planificaci√≥n.
- Se ejecutan ante determinados eventos que as√≠ lo requieren:
  - Creaci√≥n/Terminaci√≥n de procesos
  - Eventos de Sincronizaci√≥n o de E/S
  - Finalizaci√≥n de lapso de tiempo 
  - Etc
- Scheduler de long term
- Scheduler de short term
- Scheduler de medium term
- Su nombre proviene de la frecuencia de ejecuci√≥n.
- Otros m√≥dulos: **Dispatcher** y **Loader**
- Pueden no existir como m√≥dulos separados de los schedulers vistos, pero la funci√≥n debe cumplirse.
- **Dispatcher** hace cambio de contexto, cambio de modo de ejecuci√≥n...‚Äùdespacha‚Äù el proceso elegido por el Short Term (es decir, ‚Äúsalta‚Äù a la instrucci√≥n a ejecutar).
- **Loader** carga en memoria el proceso elegido por el long term

---

### Pol√≠tica Versus Mecanismo

- Existen situaciones en las que es necesario que la planificaci√≥n de uno o varios procesos se  comporte de manera diferente
- El algoritmo de planificaci√≥n debe estar parametrizado, de manera que los procesos/usuarios pueden indicar los par√°metros para modificar la planificaci√≥n
- El Kernel implementa el mecanismo
- El usuario/proceso/administrador utiliza los par√°metros para determinar la Pol√≠tica
- Ejemplo:
  - Un algoritmo de planificaci√≥n por prioridades y una System Call que permite modificar la prioridad de un proceso (man nice)
  - Un proceso puede determinar las prioridades de los procesos que el crea, seg√∫n la importancia de los mismos.


---

#### Long Term Scheduler

- Controla el grado de multiprogramaci√≥n, es decir, la cantidad de procesos en memoria.
- Puede no existir este scheduler y absorber esta tarea el de short term.

![](2023-06-05-12-48-42.png)

#### Medium Term Scheduler (swapping)

- Si es necesario, reduce el grado de multiprogramaci√≥n
- Saca temporalmente de memoria los procesos que sea necesario para mantener el equilibrio del sistema.
- T√©rminos asociados: swap out (sacar de memoria), swap in (volver a memoria).

![](2023-06-05-12-58-57.png)

#### Short Term Scheduler

- Decide a cu√°l de los procesos en la cola de listos se elige para que use la CPU.
- T√©rminos asociados: apropiativo, no apropiativo, algoritmo de scheduling

![](2023-06-05-13-00-04.png)

#### Procesos en espera y swapeado

![](2023-06-05-13-00-57.png)

#### Sobre el estado nuevo (new)

- Un usuario ‚Äúdispara‚Äù el proceso. Un proceso es creado por otro proceso: su proceso padre.
- En este estado se crean las estructuras asociadas, y el proceso queda en la cola de procesos, normalmente en espera de ser cargado en memoria

#### Sobre el estado listo (ready)

- Luego que el scheduller de largo plazo eligi√≥ al proceso para cargarlo en memoria, el proceso queda en estado listo
- El proceso s√≥lo necesita que se le asigne CPU
- Est√° en la cola de procesos listos (ready queue)

#### Sobre el estado en ejecuci√≥n (running)

- El scheduler de corto plazo lo eligi√≥ para asignarle CPU
- Tendr√° la CPU hasta que se termine el per√≠odo de tiempo asignado (quantum o time slice), termine o hasta que necesite realizar alguna operaci√≥n de E/S

#### Sobre el estado de espera (waiting)

ÔÉæEl proceso necesita que se cumpla el evento esperado para continuar.
ÔÉæEl evento puede ser la terminaci√≥n de una E/S solicitada, o la llegada de una se√±al por parte de otro proceso.
ÔÉæSigue en memoria, pero no tiene la CPU.
ÔÉæAl cumplirse el evento, pasar√° al estado de listo.


#### Transiciones

- **New-Ready** Por elecci√≥n del scheduler de largo plazo (carga en memoria)
- **Ready-Running** Por elecci√≥n del scheduler de corto plazo (asignaci√≥n de CPU)
- **Running-Waiting** el proceso ‚Äúse pone a dormir‚Äù, esperando por un evento.
- **Waiting-Ready** Termin√≥ la espera y compite nuevamente por la CPU.

#### Caso especial: running-ready

- Cuando el proceso termina su quantum (franja de tiempo) sin haber necesitado ser interrumpirlo por un evento, pasa al estado de ready, para competir por CPU, pues no est√° esperando por ning√∫n evento...
- Se trata de un caso distinto a los anteriores, porque el procesos es expulado de la CPU contra su voluntad
- Esta situaci√≥n se da en algoritmos apropiativos

#### Explicaci√≥n por estado

- **`1)`** Ejecuci√≥n en modo usuario 
- **`2)`** Ejecuci√≥n en modo kernel 
- **`3)`** El proceso est√° listo para ser ejecutado cuando sea elegido. 
- **`4)`** Proceso en espera en memoria principal. 
- **`5)`** Proceso listo, pero el swapper debe llevar al proceso a memoria ppal antes que el kernel lo pueda elegir para ejecutar
- **`6)`** Proceso en espera en memoria secundaria.
- **`7)`** Proceso retornando desde el modo kernel al user. Pero el kernel se apropia, hace un context switch para darle la CPU a otro proceso. 
- **`8)`** Proceso recientemente creado y en transici√≥n: existe, pero aun no est√° listo para ejecutar, ni est√° dormido. 
- **`9)`** El proceso ejecut√≥ la system call exit y est√° en estado zombie. Ya no existe m√°s, pero se registran datos sobre su uso, codigo resultante del exit. Es el estado final.

![](2023-06-05-13-15-04.png)

---

## Algoritmos Apropiativos y No Apropiativos

- La apropiaci√≥n esta relaciona al recurso CPU
- En los algoritmos Apropiativos (preemtive) existen situaciones que hacen que el proceso en ejecuci√≥n sea expulsado, por el planificador de corto plazo, de la CPU
- En los algoritmos No Apropiativos (nonpreemptive) los procesos se ejecutan hasta que el mismo (por su propia cuenta) abandone la CPU

- Apropiativos
  - Round Robin
  - SRTF
  - Prioridades Apropiativo
- No Apropiativos
  - FCFC
  - SJF
  - Prioridades No apropiativo

### No Apropiativos

El proceso deja el estado de ejecuci√≥n solo cuando:
- Termina (Syscall Exit)
- Se bloquea voluntariamente (SysCall wait, sleep, etc)
- Solicita una operaci√≥n de E/S (Syscall Read, Write, etc)

En los algoritmos No Apropiativo (nonpreemptive) los procesos se ejecutan hasta que el mismo (por su propia cuenta) abandone la CPU
- Se bloquea por E/S o finaliza
- No hay decisiones de planificaci√≥n durante las interrupciones de reloj


### Apropiativos

El proceso puede ser expulsado de la CPU seg√∫n la planificaci√≥n implementada

- Se le termina su quantum (Algoritmo round robin)
- Llega a la cola de listos un proceso de mayor prioridad (Algoritmo prioridades apropiativo)
- Llega a la cola de listos un proceso con menor tiempo restante (Algoritmo SRTF)

En los algoritmos Apropiativos (preemtive) existen situaciones que hacen que el proceso en ejecuci√≥n sea expulsado de la CPU


## Creaci√≥n de Procesos

- Un proceso es creado por otro proceso
- Un proceso padre tiene uno o m√°s procesos hijos.
- Se forma un √°rbol de procesos
- En UNIX:
  - system call fork() crea nuevo proceso
  - system call execve(), generalmente usada despu√©s del fork, carga un nuevo programa en el espacio de direcciones.
- En Windows:
  - system call CreateProcess() crea un nuevo proceso y carga el programa para ejecuci√≥n

### Actividades de la creaci√≥n

- Crear la PCB
- Asignar PID (Process IDentification) √∫nico
- Asignarle memoria para regiones (Stack, Text y Datos)
- Crear estructuras de datos asociadas (Fork (copiar el contexto, regiones de datos, text y stack))

### Relaci√≥n entre procesos Padre e Hijo

Con respecto a la Ejecuci√≥n:
- El padre puede continuar ejecut√°ndose concurrentemente con su hijo
- El padre puede esperar a que el proceso hijo (o los procesos hijos) terminen para continuar la ejecuci√≥n.

Con respecto al Espacio de Direcciones:
- El hijo es un duplicado del proceso padre (caso Unix)
- Se  crea el proceso y se le carga adentro el programa (caso Windows)

### Terminaci√≥n de procesos
- Ante un (**exit**), se retorna el control al sistema operativo
  - El proceso padre puede esperar recibir un c√≥digo de retorno (via **wait**). Generalmente se lo usa cuando se requier que el padre espere a los hijos.
- Proceso padre puede terminar la ejecuci√≥n de sus hijos (**kill**)
  - La tarea asignada al hijo se termin√≥
  - Cuando el padre termina su ejecuci√≥n
    - Habitualmente no se permite a los hijos continuar, pero existe la opci√≥n.
    - Terminaci√≥n en cascada

Exec Code

encuentre el programa ejecutable verifique el permiso de ejecuci√≥n lea y verifique los argumentos de copia del encabezado, del entorno al kernel libere el espacio de direcciones antiguo asigne nuevos argumentos de copia del espacio de direcciones, del entorno a la pila Restablezca las se√±ales inicialice los registros

#### Procesos Cooperativos e Independientes
- **Independiente**  el proceso no afecta ni puede ser afectado por la ejecuci√≥n de otros procesos. No comparte ning√∫n tipo de dato.
- **Cooperativo**  afecta o es afectado por la ejecuci√≥n de otros procesos en el sistema. 

#### Para qu√© sirven los procesos cooperativos?
- Para compartir informaci√≥n (por ejemplo, un archivo)
- Para acelerar el c√≥mputo (separar una tarea en sub-tareas que cooperan ejecut√°ndose paralelamente)
- Para planificar tareas de manera tal que se puedan ejecutar en paralelo.



---

# Tema 3

## Memoria
- La organizaci√≥n y administraci√≥n de la ‚Äúmemoria principal es uno de los factores m√°s importantes en el dise√±o de los S. O.
- Los programas y datos deben estar en el almacenamiento principal para: 
- Poderlos ejecutar. 
- Referenciarlos directamente
- El SO debe: 
  - Llevar un registro de las partes de memoria que se est√°n utilizando y de aquellas que no. 
  - Asignae espacio en memoria principal a los procesos cuando estos la necesitan. 
  - Libera espacio de memoria asignada a procesos que han terminado.
  - Lograr que el programador se abstraiga de la alocaci√≥n de los programas
  - Brindar seguridad entre los procesos para que unos no accedan a secciones privadas de otros
  - Brindar la posibilidad de acceso compartido a determinadas secciones de la memoria (librer√≠as, c√≥digo en com√∫n, etc.)
  - Garantizar la performance del sistema
- Se espera de un S.O. un uso eficiente de la memoria con el fin de alojar el mayor n√∫mero de procesos

### Administraci√≥n de Memoria

- Divisi√≥n L√≥gica de la Memoria F√≠sica para alojar m√∫ltiples procesos
  - Garantizando protecci√≥n
  - Depende del mecanismo provisto por el HW
- Asignaci√≥n eficientemente 
  - Contener el mayor numero de procesos para garantizar el mayor uso de la CPU por los mismos

### Requisitos

- **Reubicaci√≥n**
  - El programador no debe ocuparse de conocer donde ser√° colocado en la Memoria RAM
  - Mientras un proceso se ejecuta, puede ser sacado y tra√≠do a la memoria (swap) y, posiblemente, colocarse en diferentes direcciones.
  - Las referencias a la memoria se deben ‚Äútraducir‚Äù seg√∫n ubicaci√≥n actual del proceso.
- **Protecci√≥n**
  - Los procesos NO deben referenciar ‚Äì acceder -  a direcciones de memoria de otros procesos 
    - Salvo que tengan permiso
- El chequeo se debe realizar durante la ejecuci√≥n:
  - NO es posible anticipar todas las referencias a memoria que un proceso puede realizar.
- Compartici√≥n
  - Permitir que varios procesos accedan a la misma porci√≥n de memoria. 
    - Ej: Rutinas comunes, librer√≠as, espacios expl√≠citamente  compartidos, etc.
- Permite un mejor uso ‚Äì aprovechamiento - de la memoria RAM, evitando copias innecesarias (repetidas) de instrucciones

### Abstracci√≥n - Espacio de Direcciones

- Rango de direcciones (a memoria) posibles que un proceso puede utilizar para direccionar sus instrucciones y datos.
- El tama√±o depende de la Arquitectura del 
Procesador
  - 32 bits: 0 .. 2^32 - 1  
  - 64 bits: 0 .. 2^64 ‚Äì 1
- Es independiente de la ubicaci√≥n ‚Äúreal‚Äù del 
proceso en la Memoria RAM

![](2023-06-05-16-27-07.png)

### Direcciones

- L√≥gicas
  - Referencia a una localidad de memoria independiente de la asignaci√≥n actual de los datos en la memoria.
  - Representa una direcci√≥n en el ‚ÄúEspacio de Direcciones del Proceso‚Äù 
- F√≠sicas
  - Referencia una localidad en la Memoria F√≠sica (RAM)
    - Direcci√≥n absoluta
  - En caso de usar direcciones L√≥gicas, es necesaria alg√∫n tipo de conversi√≥n a direcciones F√≠sicas

### Conversi√≥n de Direcciones

Una forma simple de hacer esto es utilizando registros auxiliares

- **Registro Base**
  - Direcci√≥n de comienzo del Espacio de Direcciones del proceso en la RAM 
- **Registro Limite**
  - Direcci√≥n final del proceso o medida del proceso 
  - Tama√±o de su Espacio de Direcciones 
- Ambos valores se fijan cuando el espacio de direcciones del proceso es cargado a memoria.
- Var√≠an entre procesos (Context Switch)

![](2023-06-05-16-29-37.png)

#### Dir. L√≥gicas vs. F√≠sicas
- Si la CPU trabaja con direcciones l√≥gicas, para acceder a memoria principal, se deben transformar en direcciones f√≠sicas. 
  - Resoluci√≥n de direcciones (address-binding): transformar la direcci√≥n l√≥gica en la direcci√≥n f√≠sica correspondiente
- Resoluci√≥n en momento de compilaci√≥n (Archivos .com de DOS) y en tiempo de carga
  - Direcciones L√≥gicas y F√≠sicas son id√©nticas
  - Para reubicar un proceso es necesario recompilarlo o recargarlo.
- Resoluci√≥n en tiempo de ejecuci√≥n
  - Direcciones L√≥gicas y F√≠sicas son diferentes
  - Direcciones L√≥gicas son llamadas ‚ÄúDirecciones Virtuales‚Äù
  - La reubicaci√≥n se puede realizar f√°cilmente
  - El mapeo entre ‚ÄúVirtuales‚Äù y ‚ÄúF√≠sicas‚Äù es realizado por hardware
    -  Memory Management Unit (MMU)

### Memory Management Unit (MMU)

- Dispositivo de Hardware que mapea direcciones virtuales a f√≠sicas
  - Es parte del Procesador
  - Re-programar el MMU es una operaci√≥n privilegiada 
    - solo puede ser realizada en Kernel Mode
- El valor en el ‚Äúregistro de realocaci√≥n‚Äù es sumado a cada direcci√≥n generada por el proceso de usuario  al momento de acceder a la memoria.
  - Los procesos nunca usan direcciones f√≠sicas

![](2023-06-05-16-33-38.png)

### Mecanismos de asignaci√≥n de memoria

- Particiones Fijas: El primer esquema implementado
  - La memoria se divide en particiones o regiones de tama√±o Fijo (pueden ser todas del mismo tama√±o o no)
  - Alojan un proceso cada una
  - Cada proceso se coloca de acuerdo a alg√∫n criterio (First Fit, Best Fit, Worst Fit, Next Fit) en alguna partici√≥n
- Particiones din√°micas: La evoluci√≥n del esquema anterior
  - Las particiones  var√≠an en tama√±o y en n√∫mero
  - Alojan un proceso cada una
  - Cada partici√≥n se genera en forma din√°mica del tama√±o justo que necesita el proceso

¬øQu√© problemas se generan en cada caso?

## Fragmentaci√≥n

La fragmentaci√≥n se produce cuando una localidad de memoria no puede ser utilizada por no encontrarse en forma contigua

### Fragmentaci√≥n Interna:
- Se produce en el esquema de particiones Fijas
- Es la porci√≥n de la partici√≥n que queda sin utilizar

### Fragmentaci√≥n Externa:
- Se produce en el esquema de particiones din√°micas
- Son huecos que van quedando en la memoria a medida que los procesos finalizan
- Al no encontrarse en forma contigua puede darse el caso de que tengamos memoria libre para alocar un proceso, pero que no la podamos utilizar
- Para solucionar el problema se puede acudir a la compactaci√≥n, pero es muy costosa


### Problemas del esquema

- El esquema de Registro Base + Limite presenta 
problemas:
  - Necesidad de almacenar el Espacio de Direcciones de forma continua en la Memoria F√≠sica
  - Los primeros SO defin√≠an particiones fijas de memoria, luego evolucionaron a particiones din√°micas
  - Fragmentaci√≥n 
  - Mantener ‚Äúpartes‚Äù del proceso que no son necesarias
  - Los esquemas de particiones fijas y din√°micas no se usan hoy en d√≠a
- Soluci√≥n:
  - Paginaci√≥n
  - Segmentaci√≥n

## Paginaci√≥n

- Memoria F√≠sica es dividida l√≥gicamente en peque√±os trozos de igual tama√±o ÔÉ® Marcos
- Memoria L√≥gica (espacio de direcciones) es dividido en trozos de igual tama√±o que los marcos -> Paginas
- El SO debe mantener una tabla de paginas por cada proceso, donde cada entrada contiene (entre otras) el Marco en la que se coloca cada pagina.
- La direcci√≥n l√≥gica se interpreta como: 
  - un numero de pagina y un desplazamiento dentro de la misma.

## Segmentaci√≥n

- Esquema que se asemeja a la ‚Äúvisi√≥n del usuario‚Äù. El programa se divide en partes/secciones
- Un programa es una colecci√≥n de segmentos. Un segmento es una unidad l√≥gica como:
  - Programa Principal, Procedimientos y Funciones, variables locales y globales, stack, etc.
- Puede causar Fragmentaci√≥n
- Todos los segmentos de un programa pueden no tener el mismo tama√±o (c√≥digo, datos, rutinas).
- Las direcciones L√≥gicas consisten en 2 partes: 
  - Selector de Segmento 
  - Desplazamiento dentro del segmento
- Tabla de Segmentos
  - Permite mapear la direcci√≥n l√≥gica en f√≠sica. Cada entrada contiene:
    - Base: Direcci√≥n f√≠sica de comienzo del segmento
    - Limit: Longitud del Segmento
- Segment-table base register (STBR): apunta a la ubicaci√≥n de la tabla de segmentos.
- Segment-table length register (STLR) : cantidad de segmentos de un programa


![](2023-06-05-16-41-09.png)

### Segmentaci√≥n Paginada

- La paginaci√≥n
  - Transparente al programador
  - Elimina Fragmentaci√≥n externa.
- Segmentaci√≥n
  - Es visible al programador
  - Facilita modularidad, estructuras de datos grandes y da mejor soporte a la compartici√≥n y protecci√≥n
- Segmentaci√≥n Paginada: Cada segmento es dividido en paginas de tama√±o fijo.

![](2023-06-05-16-48-38.png)

## Hasta ahora

- Con paginaci√≥n vimos que el espacio de direcciones de un  proceso no necesariamente debe estar ‚Äúcontiguo‚Äù en la memoria para poder ejecutarse
  - El hardware traduce direcciones l√≥gicas a direcciones f√≠sicas utilizando las tablas de p√°ginas que el SO administra

## Motivaci√≥n para Memoria Virtual

- Podemos pensar tambi√©n que, no todo el espacio de direcciones del proceso se necesito en todo momento:
  - Rutinas o Librer√≠as que se ejecutan una √∫nica vez (o nunca)
  - Partes del programa que no vuelven a ejecutarse
  - Regiones de memoria alocadas din√°micamente y luego liberadas
  - Etc.
- No hay necesidad que la totalidad la imagen del proceso sea cargada en memoria

### Como se puede trabajar..

- El SO puede traer a memoria las ‚Äúpiezas‚Äù de un proceso a medida que √©ste las necesita. 
- Definiremos como ‚ÄúConjunto Residente‚Äù a la porci√≥n del espacio de direcciones del proceso que se encuentra en memoria.
  - Alguna bibliograf√≠a lo llama ‚ÄúWorking Set‚Äù
- Con el apoyo del HW:
  - Se detecta cuando se necesita una porci√≥n del proceso que no est√° en su Conjunto Residente
  - Se debe cargar en memoria dicha porci√≥n para continuar con la ejecuci√≥n.

### Ventajas

- M√°s procesos pueden ser mantenidos en memoria.
  - S√≥lo son cargadas algunas secciones de cada proceso.
  - Con m√°s procesos en memoria principal es m√°s probable que existan m√°s procesos Ready
- Un proceso puede ser mas grande que la memoria Principal
  - El usuario no se debe preocupar por el tama√±o de sus programas
  - La limitaci√≥n la impone el HW y el bus de direcciones

### ¬øQue se necesita para Memoria Virtual?

- El hardware debe soportar paginaci√≥n por demanda (y/o segmentaci√≥n por demanda)
- Un dispositivo de memoria secundaria (disco) que d√© el apoyo para almacenar las secciones del proceso que no est√°n en Memoria Principal (√°rea de intercambio)
- El SO debe ser capaz de manejar el movimiento de las p√°ginas (o segmentos) entre la memoria principal y la secundaria.

### Memoria Virtual con Paginaci√≥n

- Cada proceso tiene su tabla de p√°ginas
- Cada entrada en la tabla referencia al frame o marco en el que se encuentra la p√°gina en la memoria principal
- Cada entrada en la tabla de p√°ginas tiene bits de control (entre otros):
- Bit V: Indica si la p√°gina est√° en memoria
- Bit M: Indica si la p√°gina fue modificada. Si se modific√≥, en alg√∫n momento, se deben reflejar los cambios en Memoria Secundaria

### Memoria Virtual con Paginaci√≥n

![](2023-06-05-16-54-58.png)

### Fallo de p√°ginas (Page Fault)

- Ocurre cuando el proceso intenta usar una direcci√≥n que est√° en una p√°gina que no se encuentra en la memoria principal. Bit V=0 (tambi√©n marcado con i = inv√°lido)
- La p√°gina no se encuentra en su conjunto residente
- El HW detecta la situaci√≥n y genera un trap al S.O.
- El S.O. Podr√° colocar al proceso en estado de ‚ÄúBlocked‚Äù (espera) mientras gestiona que la p√°gina que se necesite se cargue.
- El S.O. busca un ‚ÄúFrame o Marco Libre‚Äù en la memoria y genera una operaci√≥n de E/S al disco para copiar en dicho Frame la p√°gina del proceso que se necesita utilizar.
- El SO puede asignarle la CPU a otro proceso mientras se completa la E/S
  - La E/S se realizar√° y avisar√° mediante interrupci√≥n su finalizaci√≥n.
- Cuando la operaci√≥n de E/S finaliza, se notifica al SO y este:
  - Actualiza la tabla de p√°ginas del proceso
    - Coloca el Bit V en 1 en la p√°gina en cuesti√≥n
    - Coloca la direcci√≥n base del Frame donde se coloc√≥ la p√°gina
  - El proceso que gener√≥ el Fallo de P√°gina vuelve a estado de Ready (listo)
  - Cuando el proceso se ejecute, se volver√° a ejecutar la instrucci√≥n que antes gener√≥ el fallo de p√°gina


![](2023-06-05-17-01-14.png)


### Performance

- Si los page faults son excesivos, la performance del sistema decae
- Tasa de Page Faults  0 ÔÇ£ p ÔÇ£ 1
  - Si p = 0 no hay page faults
  - Si p = 1, cada a memoria genera un page fault
- Effective Access Time (EAT)
```
EAT = (1 ‚Äì p) x memory access 
   + p x (page_fault_overhead +
    [swap_page_out]     +
      swap_page_in +
    restart_overhead)
```

Podr√≠a ocurrir que no haya marcos disponibles, con lo cual habr√° que descargar uno para lograr espacio para la nueva p√°gina entrante

### Tabla de P√°ginas 

- Cada proceso tiene su tabla de p√°ginas
- El tama√±o de la tabla de p√°ginas depende del espacio de direcciones del proceso.
- Puede alcanzar un tama√±o considerable
- Formas de organizar:
  - Tabla de 1 nivel: Tabla √∫nica lineal
  - Tabla de 2 niveles (o m√°s, multinivel)
  - Tabla invertida: Hashing
- La forma de organizarla depende del HW subyacente

### Tabla de 1 nivel ‚Äì 32 bits

- Direcciones de 32bits
- Ejemplo
  - Cantidad de Page Table Entries (PTEs) m√°ximas que puede tener un proceso = 220
  - El tama√±o de cada p√°gina es de 4KB
  - El tama√±o de cada PTE es de 4 bytes
    - Cantidad de PTEs que entran en un marco: 4KB/4B = 210
- Tama√±o de tabla de p√°ginas
  - Cantidad de marcos necesarios para todas las PTEs de la tabla de p√°ginas de un proceso = 220/210 = 210
  - Tama√±o tabla de p√°ginas del proceso:210 * 4bytes = 4MB por proceso 
  - M√°s de 16.000GB por proceso!!!

### Tabla de p√°ginas - Tabla de 2 niveles

- El prop√≥sito de la tabla de p√°ginas multinivel es dividir la tabla de p√°ginas lineal en m√∫ltiples tablas de p√°ginas
- Cada tabla de p√°ginas suele tener el mismo tama√±o pero se busca que tengan un menor n√∫mero de p√°ginas por tabla
- La idea general es que cada tabla sea m√°s peque√±a
- Se busca que la tabla de p√°ginas no ocupe demasida memoria RAM
- Adem√°s solo se carga una parcialidad de la tabla de p√°ginas (solo lo que se necesite resolver)
- Existe un esquema de direccionamientos indirectos

### Tabla de Paginas (cont.) - Tabla invertida

- Utilizada en Arquitecturas donde el espacio de direcciones es muy grande
  - Las tablas de paginas ocupar√≠an muchos niveles y la traducci√≥n ser√≠a costosa
  - Por esta raz√≥n se adopta esta t√©cnica
- Por ejemplo, si el espacio de direcciones es de 264 bytes, con p√°ginas de 4 KB, necesitamos una tabla de p√°ginas con 252 entradas
- Si cada entrada es de 8 bytes, la tabla es de m√°s de 30 millones de Gigabyes (30 PB)
- Hay una entrada por cada marco de p√°gina en la memoria real. Es la visi√≥n inversa a la que ven√≠amos viendo
- Hay una sola tabla para todo el sistema
- El espacio de direcciones de la tabla se refiera al espacio f√≠sico de la RAM, en vez del espacio de direcciones virtuales de un proceso
- Usada en PowerPC, UltraSPARC, y IA-64
- El n√∫mero de p√°gina es transformado en un valor de HASH
- El HASH se usa como √≠ndice de la tabla invertida para encontrar el marco asociado
- Se define un mecanismo de encadenamiento para solucinar colisiones (cuando el hash da igual para 2 direcciones virtuales)
- S√≥lo se mantienen los PTEs de p√°ginas presentes en memoria f√≠sica
  - La tabla invertida es organizada como tabla hash en memoria principal
    - Se busca indexadamente por n√∫mero de p√°gina virtual
    - Si est√° presente en tabla, se extrae el marco de p√°gina y sus protecciones
    - Si no est√° presente en tabla, corresponde a un fallo de p√°gina

![](2023-06-05-17-14-50.png)

### Tama√±o de la Pagina

- Peque√±o
  - Menor Fragmentaci√≥n Interna.
  - M√°s paginas requeridas por proceso -> Tablas de p√°ginas mas grandes.
  - M√°s paginas pueden residir en memoria
- Grande
  - Mayor Fragmentaci√≥n interna
  - La memoria secundaria esta dise√±ada para transferir grandes bloques de datos m√°s eficientemente ÔÉ® Mas r√°pido mover p√°ginas hacia la memoria principal.
- Relaci√≥n con la E/S
  - Vel. De transferencia: 2 Mb/s
  - Latencia: 8 ms
  - B√∫squeda: 20 ms 
- Pagina de 512 bytes
  - 1 pagina ‚Üí total: 28,2 ms 
  - Solo 0,2 ms de transferencia (1%)
  - 2 paginas ‚Üí 56,4 ms
- Pagina de 1024 bytes
  - total: 28,4 ms
  - Solo 0,4 ms de transferencia

### Asignaci√≥n de Marcos

- ¬øCu√°ntas paginas de un proceso se pueden encontrar en memoria? 
  - Tama√±o del Conjunto Residente
- Asignaci√≥n Din√°mica
  - El n√∫mero de marcos para cada proceso var√≠a
- Asignaci√≥n Fija 
  - N√∫mero fijo de marcos para cada proceso

#### Asignaci√≥n de Marcos - Asignaci√≥n Fija

- Asignaci√≥n equitativa ‚Äì Ejemplo: si tengo 100 frames y 5 procesos, 20 frames para cada proceso
- Asignaci√≥n Proporcional: Se asigna acorde al tama√±o del proceso

![](2023-06-05-17-17-44.png)

#### Reemplazo de p√°ginas

- Qu√© sucede si ocurre un fallo de p√°gina y todos los marcos est√°n ocupados -> ‚ÄúSe debe seleccionar una p√°gina v√≠ctima‚Äù
- ¬øCual ser√≠a Reemplazo Optimo?
  - Que la p√°gina a ser removida no sea referenciada en un futuro pr√≥ximo
- La mayor√≠a de los reemplazos predicen el comportamiento futuro mirando el comportamiento pasado.

#### Alcance del Reemplazo

- Reemplazo Global
  - El fallo de p√°gina de un proceso puede reemplazar la p√°gina de cualquier proceso.
  - El SO no controla la tasa de page-faults de cada proceso
  - Puede tomar frames de otro proceso aumentando la cantidad de frames asignados a √©l.
  - Un proceso de alta prioridad podr√≠a tomar los frames de un proceso de menor prioridad
- Reemplazo Local
  - El fallo de p√°gina de un proceso solo puede reemplazar sus propias p√°ginas ‚Äì De su Conjunto Residente
  - No cambia la cantidad de frames asignados
  - El SO puede determinar cual es la tasa de page-faults de cada proceso
  - Un proceso puede tener frames asignados que no usa, y no pueden ser usados por otros procesos.

#### Algoritmos de Remplazo

- **OPTIMO** Es solo te√≥rico
- **FIFO** Es el m√°s sencillo
- **LRU** (Least Recently Used): Requiere soporte del hardware para mantener timestamps de acceso a las p√°ginas. Favorece a las p√°ginas mas recientemente accedidas
- **2da. Chance** Un avance del FIFO tradicional que beneficia a las p√°ginas mas referenciadas
- **NRU** (Non Recently Used):ÔÉºUtiliza bits R y M
- **Favorece** a las p√°ginas que fueron usadas recientemente

